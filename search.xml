<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>你真的理解 shell 中的 $?</title>
      <link href="/posts/articles/6dd1398b.html"/>
      <url>/posts/articles/6dd1398b.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/sbash.png" alt="sbash"></p><hr><p><code>$?</code> 是一个特殊变量，用于获取上一个命令或函数的退出状态码，这里要注意的是<code>状态码</code>和<code>返回值</code>是不同的概念。在函数中我们可以使用返回标志 return，return 的返回值会作为退出状态码供 <code>$?</code> 截取，当函数没有 return 返回值时，其退出状态码根据函数体中最后一条命令而定。</p><ul><li><p>当一条命令执行成功后，其退出状态码为 0</p></li><li><p>当一条命令执行失败后，其退出状态码为非 0（即大于 0 的整数）</p><blockquote><p>不同的整数代表不同的错误类型，取决于具体的命令和操作系统，如：</p><p>127：当指定的可执行文件未找到时的退出状态码</p><p>126：当指定了无法执行（即没有权限）的可执行文件时的退出状态码</p></blockquote></li></ul><p>这个状态码本身来说是没什么意义的，它主要是帮助我们在 shell 脚本应用中起到相关的判断辅助作用，如服务安装、文件执行后的相关状态，接下来通过一个简单案例来理解。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，计算两个数的和</span></span><br><span class="line"><span class="function"><span class="title">sum</span></span>() &#123;</span><br><span class="line">  <span class="built_in">local</span> a=<span class="variable">$1</span></span><br><span class="line">  <span class="built_in">local</span> b=<span class="variable">$2</span></span><br><span class="line">  <span class="built_in">local</span> result=$((a + b))</span><br><span class="line">  <span class="built_in">return</span> <span class="variable">$result</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数，并将返回值保存到变量中</span></span><br><span class="line"><span class="built_in">sum</span> 5 3</span><br><span class="line">result=$?</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;函数的退出码为: <span class="variable">$result</span>&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230824144528806.png" alt="image-20230824144528806"></p><p>再来看一个可执行命令不存在的错误案例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是一个不存在的命令</span></span><br><span class="line">lsbad</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;命令返回的状态码为：$?&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230824144831066.png" alt="image-20230824144831066"></p><p>其实退出状态码的好处还有很多，比如当返回不同的状态码时，我们去执行不同的命令，实现脚本&#x2F;状态可控的效果。</p><p>-–END</p>]]></content>
      
      
      <categories>
          
          <category> Linux 服务器运维实战 </category>
          
          <category> 系统基础运维篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文教你如何创建 Python 虚拟环境</title>
      <link href="/posts/articles/42d77d78.html"/>
      <url>/posts/articles/42d77d78.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/pyme.png" alt="pyme"></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实这都是 Python 基础该掌握的，今天博客记录一下，方便自己或其他人阅读。虚拟环境的好处在于达到环境上的隔离，如：不同的项目有自己独特的环境，有自己项目的第三方包等等，而如果所有项目的环境都在一起，那势必会造成环境冲突。因此对于开发人员而言，学会配置虚拟环境显然是有很必要的。</p><h2 id="一、配置虚拟环境"><a href="#一、配置虚拟环境" class="headerlink" title="一、配置虚拟环境"></a>一、配置虚拟环境</h2><h3 id="1-1-Windows"><a href="#1-1-Windows" class="headerlink" title="1.1 Windows"></a><font color="red">1.1 Windows</font></h3><p><strong>1、虚拟工具安装</strong></p><ul><li><p>cmd 终端窗口安装虚拟环境管理工具</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install virtualenv virtualenvwrapper-win</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下图可见，当你安装virtualenvwrapper-win时，也会自动安装virtualenv</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230812132508454.png" alt="image-20230812132508454"></p></li><li><p>验证是否安装</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip freeze</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230812133644852.png" alt="image-20230812133644852"></p></li><li><p>添加环境变量（可选）</p><blockquote><p>默认情况下，使用 mkvirtualenv 创建虚拟环境后，会在C盘用户目录下的 Envs 文件夹中生成相应的虚拟环境。</p><p>因此我们可以添加 WORKON_HOME 环境变量来指定你的虚拟环境路径，当我们没有指定虚拟环境目录的时候，就会默认创建在环境变量 WORKON_HOME 指定的目录中。</p><p>当我们创建虚拟环境且指定了其他虚拟环境目录（不管是否配置了 WORKON_HOME 环境变量），最终会在我们指定的路径下创建虚拟环境。</p></blockquote><p><code>计算机右键 &gt; 属性 &gt; 高级系统设置 &gt; 环境变量 &gt; 系统变量 &gt; 新建</code></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230812145922425.png" alt="image-20230812145922425"></p></li></ul><p><strong>2、创建虚拟环境</strong></p><blockquote><p>工具安装完成后，就可以来创建虚拟环境里</p></blockquote><ul><li><p>cmd 命令行方式</p><blockquote><p>你要在哪里创建虚拟环境，你就进入哪个目录执行该命令即可</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkvirtualenv myvenv3</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230812143726134.png" alt="image-20230812143726134"></p><p>这个时候，就可以用我们的 Pycharm 集成开发工具来打开我们的虚拟环境：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230812151229768.png" alt="image-20230812151229768"></p><p>紧接着往下配置：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230812150508601.png" alt="image-20230812150508601"></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230812150623295.png" alt="image-20230812150623295"></p><p>点击 Create 后，我们打开终端，就可看见当前的</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230812150935831.png" alt="image-20230812150935831"></p></li><li><p>Pycharm 客户端方式</p><blockquote><p><code>File</code> - - &gt; <code>New Project</code> - - &gt; <code>Pure Python</code> - - &gt; <code>New environment using</code></p><p>选择要创建虚拟环境的目录，客户端方式会为我们自动创建虚拟环境，无需我们手动安装工具和创建虚拟环境以及上面的各种点点操作。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230812134239484.png" alt="image-20230812134239484"></p></li></ul><h3 id="1-2-Linux"><a href="#1-2-Linux" class="headerlink" title="1.2 Linux"></a><font color="red">1.2 Linux</font></h3><p><strong>1、虚拟工具安装</strong></p><ul><li><p>shell 终端执行安装</p><blockquote><p>与 Windows不同的是 Linux 下 virtualenvwrapper 不需要后缀 -win</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install virtualenv virtualenvwrapper</span><br></pre></td></tr></table></figure></li><li><p>验证是否安装</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip freeze</span><br></pre></td></tr></table></figure></li><li><p>配置环境变量</p><blockquote><p>在 .bashrc、.bash_profile 或 .zshrc 文件中添加如下三行内容</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export WORKON_HOME=~/.virtualenvs</span><br><span class="line">export VIRTUALENVWRAPPER_PYTHON=/usr/<span class="built_in">bin</span>/python3</span><br><span class="line">source /usr/local/<span class="built_in">bin</span>/virtualenvwrapper.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：</span></span><br><span class="line"><span class="comment"># WORKON_HOME：虚拟环境的存储位置</span></span><br><span class="line"><span class="comment"># VIRTUALENVWRAPPER_PYTHON：指定 Python 解释器的路径</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure></li></ul><p><strong>2、创建虚拟环境</strong></p><p>同 Windows 操作。</p><h2 id="二、常用管理命令"><a href="#二、常用管理命令" class="headerlink" title="二、常用管理命令"></a>二、常用管理命令</h2><p><strong>1、创建新的虚拟环境</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkvirtualenv &lt;your_env_name&gt;</span><br></pre></td></tr></table></figure><p><strong>2、查看所有虚拟环境</strong></p><blockquote><p>仅限于查看通过命令行方式创建的虚拟环境。</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workon</span><br></pre></td></tr></table></figure><p><strong>3、进入虚拟环境</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workon /yourpath/&lt;your_env_name&gt;</span><br></pre></td></tr></table></figure><p><strong>4、退出虚拟环境</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure><p><strong>5、删除虚拟环境</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmvirtualenv &lt;your_env_name&gt;</span><br></pre></td></tr></table></figure><h2 id="三、FAQ"><a href="#三、FAQ" class="headerlink" title="三、FAQ"></a>三、FAQ</h2><p><strong>virtualenv 和 virtualenvwrapper 的区别</strong></p><ol><li>virtualenv 是一个独立的 Python 包，它提供了创建和管理虚拟环境的功能。你可以使用 virtualenv 命令来创建虚拟环境，并使用 activate 命令来激活虚拟环境。virtualenv 可以在任何操作系统上使用。</li><li>virtualenvwrapper 是 virtualenv 的一个扩展工具，它提供了更方便的命令和功能来管理虚拟环境。它是基于 virtualenv 构建的，并提供了一组额外的命令，如 mkvirtualenv（创建虚拟环境）、workon（激活虚拟环境）、lsvirtualenv（列出虚拟环境）等。virtualenvwrapper 还提供了一些钩子和扩展功能，使得管理多个虚拟环境更加容易。virtualenvwrapper 主要在 Linux 和 macOS 上使用，但也可以在 Windows 上使用。</li></ol><p>总结来说，virtualenv 是一个基本的虚拟环境管理工具，而 virtualenvwrapper 是对 virtualenv 的扩展，提供了更多的便利功能和命令来管理虚拟环境。选择使用哪个工具取决于你的需求和个人偏好。</p><p>-–END</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 中 let 和 var 的区别</title>
      <link href="/posts/articles/8acdfc09.html"/>
      <url>/posts/articles/8acdfc09.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230811170942387.png" alt="image-20230811170942387"></p><hr><p>首先，let 和 var 都是用于声明变量的关键字，在老版 JavaScript 中也许你会见到 var 方式来声明变量，而现如今几乎都是使用 let 进行声明，接下来看看这两个关键字之间的区别。</p><p><strong>1、作用域</strong></p><ul><li><p><font color="red">var</font></p><blockquote><p>var 声明的变量在函数内部有效，如果在函数内部使用 var 声明一个变量，那么该变量在整个函数内部都是可见的。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出: 10</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// 输出: 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><font color="red">let</font></p><blockquote><p>let 声明的变量在块级作用域内有效，如果在块级作用域内使用let声明一个变量，那么该变量只在该块级作用域内可见。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">20</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出: 10</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// 报错: ReferenceError: y is not defined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>小结</strong></p><blockquote><p>使用 var 声明的变量具有函数作用域，而使用 let 声明的变量具有块级作用域。</p></blockquote></li></ul><p><strong>2、变量提升</strong></p><ul><li><p><font color="red">var</font></p><blockquote><p>var声明的变量会在其作用域内的顶部被提升，即可以在声明之前使用变量。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出: undefined</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p><font color="red">let</font></p><blockquote><p>let声明的变量不会被提升，即在声明之前使用变量会导致引用错误。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 报错: ReferenceError: x is not defined</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>小结</strong></p><blockquote><p>使用 var 声明的变量存在变量提升，而使用 let 声明的变量不存在变量提升。</p></blockquote></li></ul><p><strong>3、重复声明</strong></p><ul><li><p><font color="red">var</font></p><blockquote><p>使用var重复声明同一个变量不会报错，而是会覆盖之前的值。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">20</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出: 20</span></span><br></pre></td></tr></table></figure></li><li><p><font color="red">let</font></p><blockquote><p>使用let重复声明同一个变量会导致语法错误。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">20</span>; <span class="comment">// 报错: SyntaxError: Identifier &#x27;x&#x27; has already been declared</span></span><br></pre></td></tr></table></figure></li><li><p><strong>小结</strong></p><blockquote><p>使用 var 可以重复声明同一个变量，而使用 let 不允许在同一个作用域内重复声明同一个变量。</p></blockquote></li></ul><p>—END</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prometheus 联邦集群配置及应用</title>
      <link href="/posts/articles/299d2304.html"/>
      <url>/posts/articles/299d2304.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/prometheus.jpeg" alt="prometheus"></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>什么是 <code>Prometheus 联邦集群</code>？又是在什么样的场景下应用呢？首先，我们知道 Prometheus 是一个强大的监控平台，它是针对容器和微服务的开源监控预警工具，功能稳健，而且现在很多大厂都在使用一套监控系统（像网易、360等）。</p><p>一般地，对于初创型公司或中小型公司而言，单机部署基本上已经满足需求。而对于大规模监控而言，如：两个数据中心，其内部服务器的内网并不互通，此时单机部署的情景是无法满足我们需求的，而如果你每个数据中心都部署一套完整的监控体系，那你的数据很难进行集中管理。一般像这种夸机房、夸数据中心的情况我们就会采用 prometheus 的联邦集群模式，来进行数据集中管理、监控及告警。</p><h2 id="一、Prometheus-联邦配置"><a href="#一、Prometheus-联邦配置" class="headerlink" title="一、Prometheus 联邦配置"></a>一、Prometheus 联邦配置</h2><p>本次我以两台 Prometheus 实例进行简单演示：</p><ul><li>实例1：172.xxx.xxx.31&#x2F;20</li><li>实例2：172.xxx.xxx.250&#x2F;20</li></ul><p>说明：实例 1 为主，实例2为从，实例 1 会从实例 2 采集数据，并最终在实例 1 进行整合。</p><h3 id="1-1-安装-Prometheus"><a href="#1-1-安装-Prometheus" class="headerlink" title="1.1 安装 Prometheus"></a>1.1 安装 Prometheus</h3><blockquote><p>实例 1、2 均安装 Prometheus 服务（实例）</p></blockquote><p>这里安装过程省略，我之前的文章已经有介绍，没必要重复同样工作。</p><p>需要注意的是，实例 1 我认为你已经是安装好了 Prometheus 的整个系统（包括 alertmanaget、钉钉&#x2F;微信等接口），实例 2 只需要安装一个 Prometheus 实例即可，无需再安装任何插件。</p><h3 id="1-2-配置-Prometheus"><a href="#1-2-配置-Prometheus" class="headerlink" title="1.2 配置 Prometheus"></a>1.2 配置 Prometheus</h3><p><strong>1、实例 1 配置</strong></p><blockquote><p>在 Prometheus 实例（主）配置 Prometheus 实例（从）</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim prometheus.yml</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  - job_name: <span class="string">&#x27;prometheus-federate-xahmat&#x27;</span></span><br><span class="line">    honor_labels: <span class="literal">true</span></span><br><span class="line">    metrics_path: <span class="string">&#x27;/federate&#x27;</span></span><br><span class="line">    params:</span><br><span class="line">     <span class="string">&#x27;match[]&#x27;</span>:</span><br><span class="line">      - <span class="string">&#x27;&#123;job=~&quot;.*&quot;&#125;&#x27;</span></span><br><span class="line">    static_configs:</span><br><span class="line">    - targets: [<span class="string">&quot;公网IP:9090&quot;</span>]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>配置说明：</p><ul><li>job_name：自定义工作名；</li><li>honor_labels：保持原标签不变；</li><li>metrics_path：匹配 URL（即配置完成后可通过此 URL 来验证是否采集到实例 2 上的数据）；</li><li>params：匹配（可进行正则匹配），下面的 <code>&#123;job=~&quot;.*&quot;&#125;</code> 采集所有来自实例 2 的指标数据，根据实际情况自定义即可；</li><li>static_configs：即实例 2 的地址（IP+Port）这里的 IP 为实例 2 的公网 IP，如果有多个实例，依次往下添加即可。</li></ul><p><strong>2、实例 2 配置</strong></p><blockquote><p>实例 2 就是正常的配置，如在实例 2 内网下的各 Host 中部署 export 数据采集插件等，不做演示，我前面也有提到。</p></blockquote><p>如：我这里安装 node_export 插件来采集 Hos 基本数据，如下编写动态主机发现文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ./node_file/node_xahmat_discovery.json</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">        <span class="string">&quot;targets&quot;</span>: [<span class="string">&quot;172.xxx.xxx.250:9100&quot;</span>],</span><br><span class="line">        <span class="string">&quot;labels&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;instance&quot;</span>: <span class="string">&quot;172.xxx.xxx.250&quot;</span>,</span><br><span class="line">                <span class="string">&quot;server_type&quot;</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Hostname&quot;</span>: <span class="string">&quot;Test-XahmatCMS&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;,&#123;</span><br><span class="line">        <span class="string">&quot;targets&quot;</span>: [<span class="string">&quot;172.xxx.xxx.251:9100&quot;</span>],</span><br><span class="line">        <span class="string">&quot;labels&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;instance&quot;</span>: <span class="string">&quot;172.xxx.xxx.251&quot;</span>,</span><br><span class="line">                <span class="string">&quot;server_type&quot;</span>: <span class="string">&quot;produce&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Hostname&quot;</span>: <span class="string">&quot;Produce-Xahmatserver&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;,&#123;</span><br><span class="line">        <span class="string">&quot;targets&quot;</span>: [<span class="string">&quot;172.xxx.xxx.249:9100&quot;</span>],</span><br><span class="line">        <span class="string">&quot;labels&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;instance&quot;</span>: <span class="string">&quot;172.xxx.xxx.249&quot;</span>,</span><br><span class="line">                <span class="string">&quot;server_type&quot;</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Hostname&quot;</span>: <span class="string">&quot;Test-Xahmatserver&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>注意1：Prometheus 主配置文件中的动态主机发现路径必须与你上面编写的文件路径保持一致（如下），否则无法获取数据。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  - job_name: <span class="string">&#x27;xahmat项目&#x27;</span></span><br><span class="line">    file_sd_configs:</span><br><span class="line">      - files:</span><br><span class="line">        - ./node_file/node_xahmat_discovery.json</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注意2：如果你修改了 Prometheus 主配置文件，你需要重启 Prometheus 服务或热加载一下 Prometheus 服务（如下）使生效。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:9090/-/reload</span><br></pre></td></tr></table></figure><h2 id="二、Prometheus-联邦验证"><a href="#二、Prometheus-联邦验证" class="headerlink" title="二、Prometheus 联邦验证"></a>二、Prometheus 联邦验证</h2><p><strong>1、数据验证</strong></p><p>在实例 1（主）上验证实例 2 的数据是否已经采集：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230710155031007.png" alt="image-20230710155031007"></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230710154929994.png" alt="image-20230710154929994"></p><p><strong>2、面板展示</strong></p><p>数据无误后可在 Grafana 面板进行数据展示：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230710162448752.png" alt="image-20230710162448752"></p><p>至此，Prometheus 的联邦配置已完成！</p><p>—END</p>]]></content>
      
      
      <categories>
          
          <category> 监控系统 </category>
          
          <category> Prometheus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Prometheus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文搞懂 Python 递归函数</title>
      <link href="/posts/articles/9ee398b7.html"/>
      <url>/posts/articles/9ee398b7.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/mypython-1.png" alt="mypython-1"></p><hr><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>什么是递归函数？如果你是计算机相关专业，我想你应该了解 DNS 的递归查询，实际上两者工作模式差不多。在 Python 开发语言中递归函数就是 - - &gt; 函数自己调自己。但要注意，递归函数一旦启动就会无休止执行下去，因此我们需要在适当&#x2F;理想的条件下终止递归操作。下面通过一个简单的案例进行演示，无需深入的底层原理分析。</p><h2 id="二、案例"><a href="#二、案例" class="headerlink" title="二、案例"></a>二、案例</h2><p><strong>1、需求</strong></p><p>通过递归函数，实现 1~5 数字相加之和（为了方便图示，简单求和即可）。</p><p><strong>2、编程</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数定义</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="comment"># 当满足条件时终止调用</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 函数调用（自己调用自己）</span></span><br><span class="line">        <span class="keyword">return</span> n + <span class="built_in">sum</span>(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取返回值</span></span><br><span class="line">result = <span class="built_in">sum</span>(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印输出结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1~5之和为：&quot;</span>, result, sep=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230621180401479.png" alt="image-20230621180401479"></p><p><strong>3、流程分析</strong></p><blockquote><p>看图即可</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/diguihanshu.png" alt="diguihanshu"></p><p>-–END</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 常用内置函数与匿名函数的应用</title>
      <link href="/posts/articles/56f600ec.html"/>
      <url>/posts/articles/56f600ec.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/mypython-1.png" alt="mypython-1"></p><hr><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>我们知道，Python 函数总体可分为两类，一类是标准函数，一类是匿名函数。其中标准函数中又可细分为内置标准函数、自定义标准函数。接下来列举一些常用的<code>内置函数</code>与匿名函数的实际应用。</p><h2 id="二、常用内置函数"><a href="#二、常用内置函数" class="headerlink" title="二、常用内置函数"></a>二、常用内置函数</h2><h3 id="2-1-max"><a href="#2-1-max" class="headerlink" title="2.1 max()"></a>2.1 max()</h3><p><strong>1、常规用法</strong></p><p><code>max()</code> 函数的比较方法是遍历可迭代数据类型进行 <code>&gt;</code> 比较，获取可迭代数据类型的最大值。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">5</span>]</span><br><span class="line">m = <span class="built_in">max</span>(list1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;列表的最大值为：&#x27;</span>, m)</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230221112457418.png" alt="image-20230221112457418"></p><p><strong>2、结合 <code>key</code> 使用</strong></p><p>如果我的列表里面嵌套字典，又如何比较呢？答案：<code>max() 函数设置 key</code>，具体如下。</p><p>两个数字可以直接比较大小，而两个字典是无法直接比较大小的，这个时候就可以结合匿名函数来获取返回值来进行比较。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list2 = [&#123;<span class="string">&#x27;a&#x27;</span> : <span class="number">10</span>, <span class="string">&#x27;b&#x27;</span> : <span class="number">20</span>&#125;, &#123;<span class="string">&#x27;a&#x27;</span> : <span class="number">13</span>, <span class="string">&#x27;b&#x27;</span> : <span class="number">20</span>&#125;, &#123;<span class="string">&#x27;a&#x27;</span> : <span class="number">9</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">20</span>&#125;, &#123;<span class="string">&#x27;a&#x27;</span> : <span class="number">29</span>, <span class="string">&#x27;b&#x27;</span> : <span class="number">20</span>&#125;]</span><br><span class="line">m = <span class="built_in">max</span>(list2, key = <span class="keyword">lambda</span> x : x[<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;列表的最大值为：&#x27;</span>, m)</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230221112929656.png" alt="image-20230221112929656"></p><p>在 max() 函数底层，key 默认为 None，如果要指定 key，那 key 必须是一个函数，如下图解释：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230221113211123.png" alt="image-20230221113211123"></p><p>因此，这里就凸显出匿名函数的优势了，就不需要额外定义函数了。</p><h3 id="2-2-enumerate"><a href="#2-2-enumerate" class="headerlink" title="2.2 enumerate()"></a>2.2 enumerate()</h3><p>使用内置函数 enumerate() 遍历数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标（一般用在 for 循环当中）：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line"><span class="built_in">enumerate</span>(sequence, [start=<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释</span></span><br><span class="line">sequence -- 一个序列、迭代器或其他支持迭代对象。</span><br><span class="line">start -- 下标起始位置的值。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回值</span></span><br><span class="line">返回 <span class="built_in">enumerate</span>(枚举) 对象。</span><br></pre></td></tr></table></figure><p>简单案例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">seasons = [<span class="string">&#x27;Spring&#x27;</span>, <span class="string">&#x27;Summer&#x27;</span>, <span class="string">&#x27;Fall&#x27;</span>, <span class="string">&#x27;Winter&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">enumerate</span>(seasons))     <span class="comment"># 可见输出是一个枚举对象</span></span><br><span class="line"><span class="comment"># 下标默认从0开始</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">enumerate</span>(seasons)))  <span class="comment"># 将枚举对象强转为列表对象</span></span><br><span class="line"><span class="comment"># 设置下标从1开始</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">enumerate</span>(seasons, start=<span class="number">1</span>)))   <span class="comment"># 设置索引下标开始位置</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230221122015129.png" alt="image-20230221122015129"></p><p>普通的 for 循环：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line">seq = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> seq:</span><br><span class="line">    <span class="built_in">print</span>(i, seq[i])</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230221122159341.png" alt="image-20230221122159341"></p><p>for 循环使用 enumerate：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seq = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i, element <span class="keyword">in</span> <span class="built_in">enumerate</span>(seq):</span><br><span class="line">    <span class="built_in">print</span>(i, element)</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230221122159341.png" alt="image-20230221122159341"></p><h3 id="2-3-map"><a href="#2-3-map" class="headerlink" title="2.3 map()"></a>2.3 map()</h3><p>如使用 map() 函数对列表中元素做运算操作。</p><p>不使用 <code>map()</code> 函数：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, i <span class="keyword">in</span> <span class="built_in">enumerate</span>(list1):</span><br><span class="line">    list1[index] = i + <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(list1)</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230221141759047.png" alt="image-20230221141759047"></p><p>使用 <code>map()</code> 函数：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用map()内置函数实现列表做加法运算</span></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">result = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x + <span class="number">2</span>, list1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result))</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230221141759047.png" alt="image-20230221141759047"></p><p><mark>可见，两者的功能完全一样。</mark></p><p>如果我只对基数+1，偶数不变，如何实现？</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用map()内置函数实现列表做加法运算</span></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">result = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> x + <span class="number">1</span>, list1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result))</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230221143318606.png" alt="image-20230221143318606"></p><h3 id="3-4-reduce"><a href="#3-4-reduce" class="headerlink" title="3.4 reduce()"></a>3.4 reduce()</h3><p>对序列中的元素进行加减乘除运算的函数。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用map()内置函数实现列表做加法运算</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">tuple1 = (<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">result = reduce(<span class="keyword">lambda</span> x, y: x + y, tuple1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230221144256222.png" alt="image-20230221144256222"></p><p>内部实现原理：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230221144343984.png" alt="image-20230221144343984"></p><p><mark>需要注意，reduce 必须且至少要传入两个参数，否则报错（因为这个函数的功能是实现两个参数依次相加），如下：</mark></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用map()内置函数实现列表做加法运算</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">tuple1 = (<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>)</span><br><span class="line">result = reduce(<span class="keyword">lambda</span> x, y: x + y, tuple1)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">tuple2 = (<span class="number">1</span>)</span><br><span class="line">result = reduce(<span class="keyword">lambda</span> x, y: x + y, tuple2)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230221144836442.png" alt="image-20230221144836442"></p><p>正确做法是：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用map()内置函数实现列表做加法运算</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">tuple1 = (<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>)</span><br><span class="line">result = reduce(<span class="keyword">lambda</span> x, y: x + y, tuple1)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">tuple2 = (<span class="number">1</span>,)  <span class="comment"># 即便你不输入任何内容，你也要把元素置为空（从内部实现原理initial就知道）</span></span><br><span class="line">result = reduce(<span class="keyword">lambda</span> x, y: x + y, tuple2)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230221145613502.png" alt="image-20230221145613502"></p><p>当然，你可以指定 initial 值，当你只有一个元素的时候，你可以来进行指定。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用map()内置函数实现列表做加法运算</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">tuple1 = (<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>)</span><br><span class="line">result = reduce(<span class="keyword">lambda</span> x, y: x + y, tuple1)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">tuple2 = (<span class="number">1</span>,)  <span class="comment"># 即便你不输入任何内容，你也要把元素置为空（从内部实现原理initial就知道）</span></span><br><span class="line">result = reduce(<span class="keyword">lambda</span> x, y: x + y, tuple2, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230221145732309.png" alt="image-20230221145732309"></p><p><mark>那这个 10 是指的 x 呢，还是 y 呢？我们做一遍减法运算就知道：</mark></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用map()内置函数实现列表做加法运算</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">tuple1 = (<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>)</span><br><span class="line">result = reduce(<span class="keyword">lambda</span> x, y: x + y, tuple1)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">tuple2 = (<span class="number">1</span>,)  <span class="comment"># 即便你不输入任何内容，你也要把元素置为空（从内部实现原理initial就知道）</span></span><br><span class="line">result = reduce(<span class="keyword">lambda</span> x, y: x - y, tuple2, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230221145940527.png" alt="image-20230221145940527"></p><p>可见 initial 初始值指的是 x（即排在第一位）。</p><h3 id="2-5-filter"><a href="#2-5-filter" class="headerlink" title="2.5 filter()"></a>2.5 filter()</h3><p>过滤操作，比如将列表中 &gt; 10 的数全部过滤出来。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">2</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">36</span>]</span><br><span class="line">result = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x &gt; <span class="number">10</span>, list1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result))</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230221150735703.png" alt="image-20230221150735703"></p><p>其内部相当于以下操作：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">2</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">36</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">list1</span>):</span><br><span class="line">    list2 = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">10</span>:</span><br><span class="line">            list2.append(i)</span><br><span class="line">    <span class="keyword">return</span> list2</span><br><span class="line"></span><br><span class="line">f = func(list1)</span><br><span class="line"><span class="built_in">print</span>(f)</span><br></pre></td></tr></table></figure><p>找出所有年龄大于20岁的学生：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">students = [</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">19</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">12</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;lily&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">21</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;lucy&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;steven&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">27</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出所有年龄大于20岁的学生</span></span><br><span class="line">result = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x[<span class="string">&#x27;age&#x27;</span>] &gt; <span class="number">20</span>, students)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result))</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230221152546266.png" alt="image-20230221152546266"></p><h3 id="2-6-sorted"><a href="#2-6-sorted" class="headerlink" title="2.6 sorted()"></a>2.6 sorted()</h3><p>用于排序（从小到大&#x2F;从大到小）。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">students = [</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">19</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">12</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;lily&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">21</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;lucy&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;steven&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">27</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按年龄从小到大排序（升序）</span></span><br><span class="line">result = <span class="built_in">sorted</span>(students, key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按年龄从大到小排序（倒序）</span></span><br><span class="line">result = <span class="built_in">sorted</span>(students, key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;age&#x27;</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230221154446482.png" alt="image-20230221154446482"></p><p><mark>以上的这些常用内置函数都用到了匿名函数，可见匿名函数的重要性与实用性。</mark></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>官方都不告诉你的 Windows ISO 下载方式</title>
      <link href="/posts/articles/29a76d20.html"/>
      <url>/posts/articles/29a76d20.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230614183145530.png" alt="image-20230614183145530"></p><hr><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>我们都知道，在日常生活中，经常会遇到各种操作系统的安装，如 Windows、Linux 等，一般都会通过 ISO 来安装。而在很多第三方地址中下载的 ISO 镜像通常会捆绑一些<code>流氓</code>软件，很是难受。那官方的纯净 ISO 包怎么下载呢？接着往下看。</p><p>搜索官方 ISO 镜像文件，点击进去你会发现：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230614175615509.png" alt="image-20230614175615509"></p><p>并没有 ISO 下载的按钮，只有<code>在线升级/PE 媒介制作</code>下载的按钮，如下图：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230614175929311.png" alt="image-20230614175929311"></p><p>那这个时候怎么调出 ISO 的下载按钮呢？接下来演示一下。</p><h2 id="二、下载"><a href="#二、下载" class="headerlink" title="二、下载"></a>二、下载</h2><p><strong>1、F12 进入开发者模式</strong></p><blockquote><p>下图第二步选择完成后，需要刷新一下当前网页，才会显示<code>选择版本</code>这个选项。</p><p>版本选择这里，我们选择 <code>multi-edition ISO</code> 这个版本，因为这个版本**集成了专业版和家庭版。**如果是在当前系统下升级安装，安装程序自动选择与当前系统版本对应得版本安装。如果是全新安装，安装开始时可以手动选择安装专业版还是家庭版。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230614181055343.png" alt="image-20230614181055343"></p><p><strong>2、版本选择完成后点击 <code>确认</code></strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230614181413406.png" alt="image-20230614181413406"></p><p><strong>3、上一步确认后会接着让你选择 ISO 的语言</strong></p><blockquote><p>我们选择<code>简体中文</code>，并点击确认</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230614181544079.png" alt="image-20230614181544079"></p><p><strong>4、上一步确认之后，就会显示镜像下载按钮</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230614181728965.png" alt="image-20230614181728965"></p><p>我们可以直接点击你所需的位数下载即可，也可以退出 F12，然后右键通过迅雷下载：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230614182219518.png" alt="image-20230614182219518"></p><p>下载完成就可以将 ISO 镜像烧录到你的 PE 盘了！</p><p>-–END</p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 Kafka 构建 EL(F)K 高并发分布式日志系统</title>
      <link href="/posts/articles/ac3cbe0c.html"/>
      <url>/posts/articles/ac3cbe0c.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626161553527.png" alt="image-20220626161553527"></p><blockquote><p>主讲：rab</p><p>职位：DevOps工程师</p><p>Date：2022&#x2F;06&#x2F;07</p></blockquote><hr><h2 id="一、ELK-介绍"><a href="#一、ELK-介绍" class="headerlink" title="一、ELK 介绍"></a>一、ELK 介绍</h2><h3 id="1-1-什么是-ELK-？"><a href="#1-1-什么是-ELK-？" class="headerlink" title="1.1 什么是 ELK ？"></a>1.1 什么是 ELK ？</h3><p><strong>ELK</strong>（Elasticsearch、Logstash、Kibana），即三款开源软件首字母缩写，ELK 不是一个软件，而是一套开源的解决方案。</p><h3 id="1-2-为什么选择-ELK-？"><a href="#1-2-为什么选择-ELK-？" class="headerlink" title="1.2 为什么选择 ELK ？"></a>1.2 为什么选择 ELK ？</h3><p>通过日志排查，发现问题根源并解决问题：</p><p><strong>1、单台或几台服务器日志查看</strong></p><p>我们可以通过 linux命令，<code>tail、cat、grep、awk</code>等过滤去查询定位日志查问题。</p><p><strong>2、几十台或几百台服务器日志查看</strong></p><p>此时再通过<code>tail、cat、grep、awk</code>等过滤去查询定位日志查问题是不现实的，时间成本是非常高的，因此我们就会选择这一套开源的解决方案。</p><h3 id="1-3-ELK-具备哪些特点？"><a href="#1-3-ELK-具备哪些特点？" class="headerlink" title="1.3 ELK 具备哪些特点？"></a>1.3 ELK 具备哪些特点？</h3><ul><li>收集－能够采集多种来源的日志数据；</li><li>传输－能够稳定的把日志数据传输到中央系统；</li><li>存储－如何存储日志数据；</li><li>分析－可以支持 UI 分析；</li><li>警告－能够提供错误报告，监控机制。</li></ul><h3 id="1-4-ELK-组件介绍"><a href="#1-4-ELK-组件介绍" class="headerlink" title="1.4 ELK 组件介绍"></a>1.4 ELK 组件介绍</h3><h4 id="1-4-1-Elasticsearch"><a href="#1-4-1-Elasticsearch" class="headerlink" title="1.4.1 Elasticsearch"></a>1.4.1 Elasticsearch</h4><p><code>Elasticsearch</code>是一个实时的分布式搜索、分析引擎，使用 Java 语言开发，可进行全文检索、结构化检索及分析。</p><p><strong>主要特点：</strong></p><ul><li>面向文档的数据存储；</li><li>高可用、易扩展；</li><li>支持 Json 等各种文档格式；</li><li>支持集群、分片和复制。</li></ul><h4 id="1-4-2-Logstash"><a href="#1-4-2-Logstash" class="headerlink" title="1.4.2 Logstash"></a>1.4.2 Logstash</h4><p><code>Logstash</code>是一个实时的数据收集引擎，使用 JRuby 语言开发。</p><p><strong>主要特点：</strong></p><ul><li>几乎可以访问任何数据；</li><li>可以和多种外部应用结合;</li><li>支持弹性扩展。</li></ul><p><strong>主要组成：</strong></p><ul><li>Shipper－发送日志数据</li><li>Broker－收集数据，缺省内置 Redis</li><li>Indexer－数据写入</li></ul><h4 id="1-4-3-Kibana"><a href="#1-4-3-Kibana" class="headerlink" title="1.4.3 Kibana"></a>1.4.3 Kibana</h4><p><code>Kibana</code>是一款基于 <code>Apache</code>开源协议，使用 <code>JavaScript</code>语言编写，为 <code>Elasticsearch</code> 提供分析和可视化的 Web 平台。</p><p><strong>主要特点：</strong></p><ul><li>快速索引检索；</li><li>数据交互；</li><li>可生成各种维度数据图表。</li></ul><h2 id="二、架构及应用场景"><a href="#二、架构及应用场景" class="headerlink" title="二、架构及应用场景"></a>二、架构及应用场景</h2><h3 id="2-1-基础架构"><a href="#2-1-基础架构" class="headerlink" title="2.1 基础架构"></a>2.1 基础架构</h3><p>在这种架构中，只有一个 Logstash、Elasticsearch 和 Kibana 实例。</p><p><strong>基础架构1：</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220623183334183.png" alt="image-20220623183334183"></p><p><strong>基础架构2：</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220623183357191.png" alt="image-20220623183357191"></p><p><strong>流程：</strong></p><p>Logstash 收集日志并过滤加工数据 ——&gt; Elasticsearch 做数据持久化 ——&gt; Kibana 展示</p><p><strong>场景：</strong></p><ul><li>这种结构因为需要在各个服务器上部署 Logstash，而它比较消耗 CPU 和内存资源；</li><li>所以比较适合计算资源充足的服务器，否则容易造成服务器性能下降，甚至可能导致无法正常工作。</li></ul><h3 id="2-2-高可用架构"><a href="#2-2-高可用架构" class="headerlink" title="2.2 高可用架构"></a>2.2 高可用架构</h3><p>在这种架构中，将轻量级的 FileBeat 代替了 Logstash 来做日志收集，并引入了消息队列机制，且各部分都做了集群。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220627141707143.png" alt="image-20220627141707143"></p><p><strong>流程：</strong></p><p>FileBeat 收集日志 ——&gt; 输出到消息队列 ——&gt; Logstash 获取消息队列数据 ——&gt; Elasticsearch 做数据持久化 ——&gt;  Kibana 展示</p><p><strong>场景：</strong></p><ul><li>这种架构适合于日志规模比较庞大的情况；</li><li>但由于 <code>Logstash</code> 日志解析节点和 <code>Elasticsearch</code> 的负荷比较重，可将他们配置为集群模式，以分担负荷；</li><li>引入消息队列是为了：均衡网络传输、降低网络闭塞。避免数据丢失。</li></ul><h2 id="三、VM-部署-ELK-集群"><a href="#三、VM-部署-ELK-集群" class="headerlink" title="三、VM 部署 ELK 集群"></a>三、VM 部署 ELK 集群</h2><blockquote><p>ELK 中文社区资源下载：<a href="https://elasticsearch.cn/download/#seg-3">https://elasticsearch.cn/download/#seg-3</a></p><p>ELK 官方资源下载：<a href="https://www.elastic.co/cn/downloads/">https://www.elastic.co/cn/downloads/</a></p></blockquote><h3 id="3-1-主机规划"><a href="#3-1-主机规划" class="headerlink" title="3.1 主机规划"></a>3.1 主机规划</h3><table><thead><tr><th>Service</th><th>Version</th><th>角色</th></tr></thead><tbody><tr><td>192.168.56.133 - 2C&#x2F;2G 30G - es-1</td><td>6.8.23</td><td>ES 分布式存储</td></tr><tr><td>192.168.56.134 - 2C&#x2F;2G 30G - es-2</td><td>-</td><td>-</td></tr><tr><td>192.168.56.135 - 2C&#x2F;2G 30G - es-3</td><td>-</td><td>-</td></tr><tr><td>192.168.56.137 - 2C&#x2F;2G 30G - kafka-1 zookeeper-1</td><td>ZK：3.7.1<br />Kafka：3.1.1</td><td>Kafka 消息队列</td></tr><tr><td>192.168.56.138 - 2C&#x2F;2G 30G - kafka-2 zookeeper-2</td><td>-</td><td>-</td></tr><tr><td>192.168.56.139 - 2C&#x2F;2G 30G - kafka-3 zookeeper-3</td><td>-</td><td>-</td></tr><tr><td>192.168.56.140 - 1C&#x2F;2G 30G - logstash-1</td><td>6.8.23</td><td>Logstash 分流</td></tr><tr><td>192.168.56.141 - 1C&#x2F;2G 30G - logstash-2</td><td>-</td><td>-</td></tr><tr><td>192.168.56.136 - 2C&#x2F;2G 30G - kabana - nginx</td><td>6.8.23</td><td>web 前端数据展示</td></tr><tr><td>192.168.56.136 - 2C&#x2F;2G 30G - kabana</td><td>-</td><td>-</td></tr></tbody></table><blockquote><p>采集插件（Filebeat）版本：6.8.23 </p><p>ELK 各插件版本最好保持一致，否则可能会导致一些采集异常。</p></blockquote><h3 id="3-2-应用部署"><a href="#3-2-应用部署" class="headerlink" title="3.2 应用部署"></a>3.2 应用部署</h3><blockquote><p>集群场景下的服务器，需对时间进行同步，服务器时间同步方法：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装ntp服务</span></span><br><span class="line">yum -y install ntp ntpdate</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同步网络时间服务器</span></span><br><span class="line">ntpdate 0.asia.pool.ntp.org</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将系统时间写入硬件时间（防止重启后时间被重置）</span></span><br><span class="line">hwclock --systohc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其他网络时间服务器</span></span><br><span class="line">time.nist.gov</span><br><span class="line">time.nuri.net</span><br><span class="line">0.asia.pool.ntp.org</span><br><span class="line">1.asia.pool.ntp.org</span><br><span class="line">2.asia.pool.ntp.org</span><br><span class="line">3.asia.pool.ntp.org</span><br></pre></td></tr></table></figure><h3 id="3-3-ES-集群"><a href="#3-3-ES-集群" class="headerlink" title="3.3 ES 集群"></a>3.3 ES 集群</h3><blockquote><p>三台 ES 服务器同时操作</p></blockquote><p><strong>1、修改服务器主机名</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl set-hostname es-1</span><br><span class="line">hostnamectl set-hostname es-2</span><br><span class="line">hostnamectl set-hostname es-3</span><br></pre></td></tr></table></figure><p><strong>2、互作本地解析</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.56.133 es-1</span><br><span class="line">192.168.56.134 es-2</span><br><span class="line">192.168.56.135 es-3</span><br></pre></td></tr></table></figure><p><strong>3、创建数据目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data</span><br></pre></td></tr></table></figure><p><strong>4、上传并解压ES二进制文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar xzf elasticsearch-6.0.1.tar.gz -C /data/</span><br><span class="line">mv /data/elasticsearch-6.0.1 /data/elasticsearch</span><br></pre></td></tr></table></figure><p><strong>5、修改文件句柄数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/security/limits.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注：设置为 65535 不行，至少 65536</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果配置文件开启bootstrap.memory_lock，内存锁，则需要添加下列最后两行</span></span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br><span class="line">* soft nproc  65536</span><br><span class="line">* hard nproc  65536</span><br><span class="line">* hard memlock unlimited</span><br><span class="line">* soft memlock unlimited</span><br></pre></td></tr></table></figure><p><strong>6、修改虚拟内存最大限制</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;vm.max_map_count = 655360&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>系统级别：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/systemd/system.conf</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">DefaultLimitNOFILE=65536</span><br><span class="line">DefaultLimitNPROC=32000</span><br><span class="line">DefaultLimitMEMLOCK=infinity</span><br></pre></td></tr></table></figure><p><strong>7、创建 ES 普通用户</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd es</span><br><span class="line">echo &quot;zhurs@123&quot; | passwd --stdin es</span><br></pre></td></tr></table></figure><p><strong>8、修改目录权限</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R es.es /data/elasticsearch</span><br></pre></td></tr></table></figure><p><strong>9、修改配置文件</strong></p><p><strong>es-1</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">cd /data/elasticsearch/config</span><br><span class="line">cp elasticsearch.yml elasticsearch.yml.default</span><br><span class="line">vim elasticsearch.yml</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cluster.name 三者需相同</span></span><br><span class="line">cluster.name: es-cluster</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">node.name 节点名，设置与主机名一致即可</span></span><br><span class="line">node.name: es-1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">node.master 符合成为主节点的条件</span></span><br><span class="line">node.master: true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">node.data 符合成为数据节点的条件</span></span><br><span class="line">node.data: true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">path.data 数据存储路径（下面会进行创建）</span></span><br><span class="line">path.data: /data/elasticsearch/data</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">path.logs 日志存储路径（下面会进行创建）</span></span><br><span class="line">path.logs: /data/elasticsearch/logs</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bootstrap.memory_lock 锁住内存，即只使用内存，不使用交换分区</span></span><br><span class="line">bootstrap.memory_lock: true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">network.host 允许所有IP访问</span></span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http.port web访问端口</span></span><br><span class="line">http.port: 9200</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">discovery.zen.ping.unicast.hosts 关闭单播</span></span><br><span class="line">discovery.zen.ping.unicast.hosts: [&quot;192.168.56.133&quot;, &quot;192.168.56.134&quot;, &quot;192.168.56.135&quot;]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">discovery.zen.ping_timeout 节点在发现过程中的等待超时时间</span></span><br><span class="line">discovery.zen.ping_timeout: 120s</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">discovery.zen.fd.ping_retries 节点发现重试次数</span></span><br><span class="line">discovery.zen.fd.ping_retries: 10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">client.transport.ping_timeout  ping命令的响应超时时间</span></span><br><span class="line">client.transport.ping_timeout: 60s</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决跨域问题</span></span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>es-2</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">cd /data/elasticsearch/config</span><br><span class="line">cp elasticsearch.yml elasticsearch.yml.default</span><br><span class="line">vim elasticsearch.yml</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cluster.name 三者需相同</span></span><br><span class="line">cluster.name: es-cluster</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">node.name 节点名，设置与主机名一致即可</span></span><br><span class="line">node.name: es-2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">node.master 符合成为主节点的条件</span></span><br><span class="line">node.master: true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">node.data 符合成为数据节点的条件</span></span><br><span class="line">node.data: true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">path.data 数据存储路径（下面会进行创建）</span></span><br><span class="line">path.data: /data/elasticsearch/data</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">path.logs 日志存储路径（下面会进行创建）</span></span><br><span class="line">path.logs: /data/elasticsearch/logs</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bootstrap.memory_lock 锁住内存，即只使用内存，不使用交换分区</span></span><br><span class="line">bootstrap.memory_lock: true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">network.host 允许所有IP访问</span></span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http.port web访问端口</span></span><br><span class="line">http.port: 9200</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">discovery.zen.ping.unicast.hosts 关闭单播</span></span><br><span class="line">discovery.zen.ping.unicast.hosts: [&quot;192.168.56.133&quot;, &quot;192.168.56.134&quot;, &quot;192.168.56.135&quot;]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">discovery.zen.ping_timeout 节点在发现过程中的等待超时时间</span></span><br><span class="line">discovery.zen.ping_timeout: 120s</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">discovery.zen.fd.ping_retries 节点发现重试次数</span></span><br><span class="line">discovery.zen.fd.ping_retries: 10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">client.transport.ping_timeout  ping命令的响应超时时间</span></span><br><span class="line">client.transport.ping_timeout: 60s</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决跨域问题</span></span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>es-3</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">cd /data/elasticsearch/config</span><br><span class="line">cp elasticsearch.yml elasticsearch.yml.default</span><br><span class="line">vim elasticsearch.yml</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cluster.name 三者需相同</span></span><br><span class="line">cluster.name: es-cluster</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">node.name 节点名，设置与主机名一致即可</span></span><br><span class="line">node.name: es-3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">node.master 符合成为主节点的条件</span></span><br><span class="line">node.master: true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">node.data 符合成为数据节点的条件</span></span><br><span class="line">node.data: true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">path.data 数据存储路径（下面会进行创建）</span></span><br><span class="line">path.data: /data/elasticsearch/data</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">path.logs 日志存储路径（下面会进行创建）</span></span><br><span class="line">path.logs: /data/elasticsearch/logs</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bootstrap.memory_lock 锁住内存，即只使用内存，不使用交换分区</span></span><br><span class="line">bootstrap.memory_lock: true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">network.host 允许所有IP访问</span></span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http.port web访问端口</span></span><br><span class="line">http.port: 9200</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">discovery.zen.ping.unicast.hosts 关闭单播</span></span><br><span class="line">discovery.zen.ping.unicast.hosts: [&quot;192.168.56.133&quot;, &quot;192.168.56.134&quot;, &quot;192.168.56.135&quot;]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">discovery.zen.ping_timeout 节点在发现过程中的等待超时时间</span></span><br><span class="line">discovery.zen.ping_timeout: 120s</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">discovery.zen.fd.ping_retries 节点发现重试次数</span></span><br><span class="line">discovery.zen.fd.ping_retries: 10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">client.transport.ping_timeout  ping命令的响应超时时间</span></span><br><span class="line">client.transport.ping_timeout: 60s</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决跨域问题</span></span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>10、创建数据、日志目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/elasticsearch/data</span><br><span class="line">mkdir -p /data/elasticsearch/logs</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">授权</span></span><br><span class="line">chown es.es /data/elasticsearch/data</span><br><span class="line">chown es.es /data/elasticsearch/logs</span><br></pre></td></tr></table></figure><p><strong>11、安装 JDK</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上传并解压安装包</span></span><br><span class="line">tar xzf jdk-8u202-linux-x64.tar.gz -C /data/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mv</span> 重命名</span></span><br><span class="line">mv /data/jdk1.8.0_202/ /data/jdk</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加环境变量</span></span><br><span class="line">cat /etc/profile.d/jdk.sh </span><br><span class="line">export PATH=/data/jdk/bin:$PATH</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证</span></span><br><span class="line">[root@es-1 data]# java -version</span><br><span class="line">java version &quot;1.8.0_202&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_202-b08)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.202-b08, mixed mode)</span><br></pre></td></tr></table></figure><p><strong>12、修改 JVM 参数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认1g</span></span><br><span class="line">cat /data/elasticsearch/config/jvm.options</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">-Xms512m</span><br><span class="line">-Xmx512m</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>13、启动 ES 集群</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - es -c &quot;nohup /data/elasticsearch/bin/elasticsearch &amp;&quot;</span><br></pre></td></tr></table></figure><p><strong>14、配置 systemd 管理</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=elasticsearch</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">User=es</span><br><span class="line">ExecStart=/data/elasticsearch/bin/elasticsearch -d</span><br><span class="line">PrivateTmp=true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定此进程可以打开的最大文件数</span></span><br><span class="line">LimitNOFILE=65536</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定此进程可以打开的最大进程数</span></span><br><span class="line">LimitNPROC=65536</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最大虚拟内存</span></span><br><span class="line">LimitAS=infinity</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最大文件大小</span></span><br><span class="line">LimitFSIZE=infinity</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">超时设置0-永不超时</span></span><br><span class="line">TimeoutStopSec=0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SIGTERM是停止java进程的信号</span></span><br><span class="line">KillSignal=SIGTERM</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">信号只发给JVM</span></span><br><span class="line">KillMode=process</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">java进程不会被杀掉</span></span><br><span class="line">SendSIGKILL=no</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">正常退出状态</span></span><br><span class="line">SuccessExitStatus=143</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>启动服务并做开机自启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start es.service</span><br><span class="line">systemctl enable es.service</span><br></pre></td></tr></table></figure><p>浏览器输入 URL 查看集群状态：<a href="http://192.168.56.134:9200/_cat/nodes?pretty">http://192.168.56.134:9200/_cat/nodes?pretty</a></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220623161419031.png" alt="image-20220623161419031"></p><p>&#x3D;&#x3D;至此，ES 集群搭建完毕，可通过简单的 head 插件查看集群状态，head 插件可部署在 kibana 服务器上，具体看 6.2.4 部分。&#x3D;&#x3D;</p><p><strong>15、集群可用性测试</strong></p><p>具体测试看 6.2.2 小结</p><h3 id="3-4-Logstash-分流"><a href="#3-4-Logstash-分流" class="headerlink" title="3.4 Logstash 分流"></a>3.4 Logstash 分流</h3><blockquote><p><a href="https://www.elastic.co/guide/en/logstash/current/index.html">《官方文档》</a></p></blockquote><p><strong>1、安装 JAVA 环境</strong></p><blockquote><p>Logstash 依赖 JDK</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tar xzf jdk-8u202-linux-x64.tar.gz -C /data/</span><br><span class="line">mv /data/jdk1.8.0_202/ /data/jdk</span><br><span class="line">ln -s /data/jdk/bin/* /usr/bin/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可用性测试</span></span><br><span class="line">java -version</span><br><span class="line">java version &quot;1.8.0_202&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_202-b08)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.202-b08, mixed mode)</span><br></pre></td></tr></table></figure><p><strong>2、安装 Logstash</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar xzf logstash-6.0.1.tar.gz -C /data/</span><br><span class="line">mv /data/logstash-6.0.1/ /data/logstash</span><br></pre></td></tr></table></figure><p><strong>3、命令行测试 ES 集群可用性</strong></p><blockquote><p>logstash 可用性测试</p><p>stdin{}：标准输入</p><p>stdout{}：标准输出</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/data/logstash/bin/logstash -e &#x27;input &#123; stdin &#123;&#125; &#125; output &#123; stdout &#123;&#125; &#125;&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出结果：时间戳  主机名  内容</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220622121128625.png" alt="image-20220622121128625"></p><blockquote><p>将标准输入内容以指定语言格式输出至当前终端</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/logstash/bin/logstash -e &#x27;input &#123; stdin&#123;&#125; &#125; output &#123; stdout &#123; codec =&gt; rubydebug &#125; &#125;&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220622121532407.png" alt="image-20220622121532407"></p><blockquote><p>将标准输入内容输出至 ES 集群</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/logstash/bin/logstash -e &#x27;input &#123; stdin &#123;&#125; &#125; output &#123; elasticsearch &#123; hosts =&gt; [&quot;192.168.56.133:9200&quot;] &#125; &#125;&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220622122512629.png" alt="image-20220622122512629"></p><p>此时访问 head 插件看看 ES 集群情况，看是否收到刚刚我们输入的内容<code>hello xgxy</code></p><blockquote><p>es-head 安装看 6.2.3 部分</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220622122928152.png" alt="image-20220622122928152"></p><p>数据会产生5个分片数和2个副本数，分片和副本数分别存储在不同节点上。</p><p><strong>4、ES 集群状态</strong></p><p>ES 集群有三个状态：green、yellow、red</p><ul><li><p>green：表示所有主分片和复制分片都可用（整个集群可用）</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220622143341046.png" alt="image-20220622143341046"></p></li><li><p>yellow：表示所有主分片可用，部分复制分片不可以。比如我故意停掉 es-1，再次查看集群状态</p><blockquote><p>在停掉 es-1 的时候，集群状态处于部分副本数据不可用的情况</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220622144602406.png" alt="image-20220622144602406"></p><blockquote><p>但是，过了一段时间后，es-1 的主分片和复制分片被转移到 es-2、es-3 节点，实现故障转移，保证数据完整性。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220622144231764.png" alt="image-20220622144231764"></p><blockquote><p>此时，我再次启动 es-1 ，再次并入集群，这时 es-1 会被重新分片分配及副本，集群状态呈 green</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220622144352162.png" alt="image-20220622144352162"></p></li><li><p>red：表示部分主分片不可用</p></li></ul><p>在 yellow 状态，我故意停掉了 es-1 节点，所以其呈现 yellow 状态，但你会发现，我停掉的是 data-node 节点（数据节点），那我把 master 节点 down 掉，会发生什么？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@es-3 0]# systemctl stop es.service</span><br></pre></td></tr></table></figure><p>此时会呈现 yellow 状态：<br><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220622145723959.png" alt="image-20220622145723959"></p><p>此时，在指定时间内，进群会进行 master 选举，并为整个集群分配分片，实现故障转移：完成后呈 green 集群可用状态。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220622145958425.png" alt="image-20220622145958425"></p><p>我有重新启动 es-3，看看集群情况：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220622150434411.png" alt="image-20220622150434411"></p><p>此时，它会以数据节点并入集群，并分配分片。</p><p><strong>5、Logstash 收集日志测试</strong></p><p>由于我的 Kibana 安装了 nginx ，也是需要进行日志收集的，所以我把 Logstash 安装在 kibana 服务器上进行日志采集。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar xzf logstash-6.0.1.tar.gz -C /data/</span><br><span class="line">mv /data/logstash-6.0.1/ /data/logstash</span><br></pre></td></tr></table></figure><p>将 nginx 日志格式定义为 json 格式，并引用 json 格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">log_format  json &#x27;&#123;&quot;@timestamp&quot;:&quot;$time_iso8601&quot;,&#x27;</span><br><span class="line">                           &#x27;&quot;@version&quot;:&quot;1&quot;,&#x27;</span><br><span class="line">                           &#x27;&quot;client&quot;:&quot;$remote_addr&quot;,&#x27;</span><br><span class="line">                           &#x27;&quot;url&quot;:&quot;$uri&quot;,&#x27;</span><br><span class="line">                           &#x27;&quot;status&quot;:&quot;$status&quot;,&#x27;</span><br><span class="line">                           &#x27;&quot;domain&quot;:&quot;$host&quot;,&#x27;</span><br><span class="line">                           &#x27;&quot;host&quot;:&quot;$server_addr&quot;,&#x27;</span><br><span class="line">                           &#x27;&quot;size&quot;:$body_bytes_sent,&#x27;</span><br><span class="line">                           &#x27;&quot;responsetime&quot;:$request_time,&#x27;</span><br><span class="line">                           &#x27;&quot;referer&quot;: &quot;$http_referer&quot;,&#x27;</span><br><span class="line">                           &#x27;&quot;ua&quot;: &quot;$http_user_agent&quot;&#x27;</span><br><span class="line">               &#x27;&#125;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  json;</span><br></pre></td></tr></table></figure><p>创建 logstash 配置文件目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/logstash/config/conf.d</span><br></pre></td></tr></table></figure><blockquote><p>在 conf.d 目录下添加<code>shopweb.conf</code>文件</p><p>该目录可定义多个 .conf 文件</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">cat shopweb.conf</span><br><span class="line"></span><br><span class="line">input&#123;</span><br><span class="line">    file&#123;</span><br><span class="line">        path =&gt; [&quot;/data/nginx/logs/access.log&quot;]</span><br><span class="line">        type =&gt; &quot;shopweb&quot;</span><br><span class="line">        start_position =&gt; &quot;beginning&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output&#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts =&gt; [&quot;192.168.56.133:9200&quot;,&quot;192.168.56.134:9200&quot;,&quot;192.168.56.135:9200&quot;]  </span><br><span class="line">        index =&gt; [&quot;%&#123;type&#125;-%&#123;+YYYY.MM.dd&#125;&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">字段说明：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">input：输入插件，让logstash可以读取特定的事件源</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file：从文件中读取</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">path：要输入的文件路径</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">type</span>：定义一个类型，通用选项（因此，每个项目需定义一个access.log）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个<span class="built_in">type</span>说明了你这个是什么样属性的日志，数据库日志我就定义：mysql,订单日志我就定义：order</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">start_position：开始采集日志的位置，beginning表示从头开始（即开始到当前的日志全部收集）</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-------------</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">output：输出插件，将事件发送到特定目标</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">elasticsearch：输出到es</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hosts：指定es服务的 ip + 端口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">index：引用input中的<span class="built_in">type</span>名称，定义输出的格式，并作为索引，然后在kibana上面可以添加该索引</span></span><br></pre></td></tr></table></figure><p>启动 logstash</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">前台启动</span></span><br><span class="line">/data/logstash/bin/logstash -f /data/logstash/config/conf.d/ --config.reload.automatic</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后台启动</span></span><br><span class="line">nohup /data/logstash/bin/logstash -f /data/logstash/config/conf.d/ --config.reload.automatic &amp;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--config.reload.automatic：可以加载conf.d 目录下的所有.conf文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">想要单独加载的话，则去掉--config.reload.automatic参数，并指定具体的 .conf 文件</span></span><br></pre></td></tr></table></figure><p>浏览器刷一下 nginx 页面，然后取 head 插件看看是否成功存储，如下图，shopweb-2022.06.22 正好是我们 shopweb.conf 文件中 output 中 index 定义的格式：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220622161423194.png" alt="image-20220622161423194"></p><p>数据浏览：这正是我 kibana 服务上的你 nginx 的日志数据：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220622162146328.png" alt="image-20220622162146328"></p><p>&#x3D;&#x3D;注意：input 可以写多个，如下&#x3D;&#x3D;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">vim all.conf</span><br><span class="line"></span><br><span class="line">input&#123;</span><br><span class="line">    file&#123;</span><br><span class="line">        path =&gt; [&quot;/data/nginx/logs/access.log&quot;]</span><br><span class="line">        type =&gt; &quot;nginx_access&quot;</span><br><span class="line">        start_position =&gt; &quot;beginning&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">input&#123;</span><br><span class="line">    file&#123;</span><br><span class="line">        path =&gt; [&quot;/var/log/messages&quot;]</span><br><span class="line">        type =&gt; &quot;system_error&quot;</span><br><span class="line">        start_position =&gt; &quot;beginning&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output&#123;</span><br><span class="line">    if [type] ==  &quot;nginx_access&quot; &#123;</span><br><span class="line">        elasticsearch &#123;</span><br><span class="line">            hosts =&gt; [&quot;192.168.56.133:9200&quot;,&quot;192.168.56.134:9200&quot;,&quot;192.168.56.135:9200&quot;] </span><br><span class="line">            index =&gt; [&quot;%&#123;type&#125;-%&#123;+YYYY.MM.dd&#125;&quot;]</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    if [type] ==  &quot;system_error&quot; &#123;</span><br><span class="line">        elasticsearch &#123;</span><br><span class="line">            hosts =&gt; [&quot;192.168.56.133:9200&quot;,&quot;192.168.56.134:9200&quot;,&quot;192.168.56.135:9200&quot;] </span><br><span class="line">            index =&gt; [&quot;%&#123;type&#125;-%&#123;+YYYY.MM.dd&#125;&quot;]</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要 input 对应的文件产生新的日志，logstash 实时就会往 ES 集群发送。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220622170153169.png" alt="image-20220622170153169"></p><h3 id="3-5-Kibana-前端展示"><a href="#3-5-Kibana-前端展示" class="headerlink" title="3.5 Kibana 前端展示"></a>3.5 Kibana 前端展示</h3><p><strong>1、安装 head 插件</strong></p><blockquote><p>由于安装需要各种编译，所以选择 docker 安装</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name=es-head \</span><br><span class="line">  --privileged=true \</span><br><span class="line">  --restart=always \</span><br><span class="line">  -v /etc/localtime:/etc/localtime \</span><br><span class="line">  -p 9100:9100 \</span><br><span class="line">  docker.io/mobz/elasticsearch-head:5-alpine</span><br></pre></td></tr></table></figure><blockquote><p>验证集群状态，此时无任何数据存储。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220622103923524.png" alt="image-20220622103923524"></p><p><strong>2、安装 kibana</strong></p><p>尽管在 6.2.2 节看到已经 ES 集群已经成功接收到数据，但是 es-head 插件对数据的浏览是不友好的，因此我们需要安装部署 kibana 来做 ES 数据的 web 端展示（分析、检索等）</p><h3 id="3-6-Nginx-反向代理"><a href="#3-6-Nginx-反向代理" class="headerlink" title="3.6 Nginx 反向代理"></a>3.6 Nginx 反向代理</h3><blockquote><ul><li>代理 head</li><li>代理 kibana </li><li>从而实现统一访问</li><li>采用 host 网络模式</li></ul></blockquote><p><strong>1、采用 docker 安装</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-------------------------------自定义变量--------------------------------------</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义nginx主目录</span></span><br><span class="line">dir_conf=&quot;/data/nginx/conf&quot;</span><br><span class="line">dir_html=&quot;/data/nginx/html&quot;</span><br><span class="line">dir_logs=&quot;/data/nginx/logs&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置镜像版本</span></span><br><span class="line">img=&quot;nginx:1.20.2&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">容器名</span></span><br><span class="line">name=&quot;nginx&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">端口映射(针对bridge模式设置，host模式忽略)</span></span><br><span class="line">http_port=&quot;80&quot;</span><br><span class="line">https_port=&quot;443&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">网络模式</span></span><br><span class="line">net=&quot;bridge&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host模式：使用 --net=host 指定。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">none模式：使用 --net=none 指定。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bridge模式：使用 --net=bridge 指定，默认设置。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">container模式：使用 --net=container:NAME_or_ID 指定</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------------------------------------------------------------</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建目录</span></span><br><span class="line">mkdir -p $&#123;dir_conf&#125; &amp;&amp; echo -e &quot;已创建 $&#123;dir_conf&#125; 目录，继续执行... \033[32m[ok]\033[0m&quot; || echo -e &quot;$&#123;dir_conf&#125; 目录已存在，继续执行... \033[33m[Already exists]\033[0m&quot;</span><br><span class="line">mkdir -p $&#123;dir_html&#125; &amp;&amp; echo -e &quot;已创建 $&#123;dir_html&#125; 目录，继续执行... \033[32m[ok]\033[0m&quot; || echo -e &quot;$&#123;dir_html&#125; 目录已存在，继续执行... \033[33m[Already exists]\033[0m&quot;</span><br><span class="line">mkdir -p $&#123;dir_logs&#125; &amp;&amp; echo -e &quot;已创建 $&#123;dir_logs&#125; 目录，继续执行... \033[32m[ok]\033[0m&quot; || echo -e &quot;$&#123;dir_logs&#125; 目录已存在，继续执行... \033[33m[Already exists]\033[0m&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span></span><br><span class="line">echo &quot;正在拉取$&#123;img&#125;镜像，请耐心等待...&quot;</span><br><span class="line">docker pull $img &amp;&gt; /dev/null</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动临时容器（<span class="built_in">cp</span>配置文件）</span></span><br><span class="line">echo &quot;正在启动$&#123;name&#125;临时容器...&quot;</span><br><span class="line">docker run -d --name=$&#123;name&#125; $img &amp;&gt; /dev/null</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">    echo -e &quot;$&#123;name&#125;临时容器启动成功 \033[32m[ok]\033[0m&quot;</span><br><span class="line">else</span><br><span class="line">    echo -e &quot;\033[31m[error]$&#123;name&#125;临时容器启动失败\033[0m&quot; &amp;&amp; exit 1</span><br><span class="line">fi</span><br><span class="line">echo &quot;正在拷贝配置文件至宿主机...&quot;</span><br><span class="line">docker cp $&#123;name&#125;:/etc/nginx/nginx.conf $&#123;dir_conf&#125;</span><br><span class="line">docker cp $&#123;name&#125;:/etc/nginx/conf.d $&#123;dir_conf&#125;</span><br><span class="line">echo -e &quot;配置文件拷贝成功 \033[32m[ok]\033[0m&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除临时容器</span></span><br><span class="line">echo &quot;正在删除$&#123;name&#125;容器...&quot;</span><br><span class="line">docker stop $name &amp;&gt; /dev/null</span><br><span class="line">docker rm $name &amp;&gt; /dev/null</span><br><span class="line">echo -e &quot;$&#123;name&#125;容器删除成功 \033[32m[ok]\033[0m&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行正式容器</span></span><br><span class="line">echo &quot;正在启动$&#123;name&#125;正式容器...&quot;</span><br><span class="line">a=&quot;host&quot;</span><br><span class="line">b=&quot;bridge&quot;</span><br><span class="line">c=&quot;none&quot;</span><br><span class="line">d=&quot;container&quot;</span><br><span class="line">if [ $net = $a ]; then</span><br><span class="line">    docker run -itd \</span><br><span class="line">    --name=$&#123;name&#125; \</span><br><span class="line">    --privileged=true \</span><br><span class="line">    --restart=always \</span><br><span class="line">    --net=$&#123;a&#125; \</span><br><span class="line">    -v /etc/localtime:/etc/localtime \</span><br><span class="line">    -v $&#123;dir_conf&#125;/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">    -v $&#123;dir_conf&#125;/conf.d:/etc/nginx/conf.d \</span><br><span class="line">    -v $&#123;dir_html&#125;:/usr/share/nginx/html \</span><br><span class="line">    -v $&#123;dir_logs&#125;:/var/log/nginx $&#123;img&#125; &amp;&gt; /dev/null</span><br><span class="line">    elif [ $net = $b ]; then</span><br><span class="line">        docker run -itd \</span><br><span class="line">        --name=$&#123;name&#125; \</span><br><span class="line">        --privileged=true \</span><br><span class="line">        --restart=always \</span><br><span class="line">        -p $&#123;http_port&#125;:80 \</span><br><span class="line">        -p $&#123;https_port&#125;:443 \</span><br><span class="line">        -v /etc/localtime:/etc/localtime \</span><br><span class="line">        -v $&#123;dir_conf&#125;/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">        -v $&#123;dir_conf&#125;/conf.d:/etc/nginx/conf.d \</span><br><span class="line">        -v $&#123;dir_html&#125;:/usr/share/nginx/html \</span><br><span class="line">        -v $&#123;dir_logs&#125;:/var/log/nginx $&#123;img&#125; &amp;&gt; /dev/null</span><br><span class="line">else</span><br><span class="line">    echo -e &quot;\033[31m[error]容器启动失败，请指定正确的网络模式\033[0m&quot; &amp;&amp; exit 1</span><br><span class="line">    echo &quot;&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">    echo -e &quot;$&#123;name&#125;容器启动成功 \033[32m[ok]\033[0m&quot;</span><br><span class="line">    echo &quot;&quot;</span><br><span class="line">    echo -e &quot;\033[32m发布路径：$&#123;dir_html&#125;\033[0m&quot;</span><br><span class="line">    echo -e &quot;\033[32m配置路径：$&#123;dir_conf&#125;\033[0m&quot;</span><br><span class="line">    echo -e &quot;\033[32m日志路径：$&#123;dir_logs&#125;\033[0m&quot;</span><br><span class="line">    echo &quot;&quot;</span><br><span class="line">else</span><br><span class="line">    echo -e &quot;\033[31m[error]$&#123;name&#125;容器启动失败，请手动检查错误原因\033[0m&quot; &amp;&amp; exit 1</span><br><span class="line">    echo &quot;&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印容器网络模式</span></span><br><span class="line">echo -e &quot;$&#123;name&#125;容器网络模式为：\033[35m$&#123;net&#125;\033[0m&quot;</span><br><span class="line">echo &quot;&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印端口</span></span><br><span class="line">if [ $net = &quot;bridge&quot; ]; then</span><br><span class="line">    echo -e &quot;\033[32mhttp端口：$&#123;http_port&#125;:80\033[0m&quot;</span><br><span class="line">    echo -e &quot;\033[32mhttps端口：$&#123;https_port&#125;:443\033[0m&quot;</span><br><span class="line">    echo &quot;&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;具体的 Nginx 反向代理配置请看 4.4 部分。&#x3D;&#x3D;</p><h3 id="3-7-Zookeeper-集群"><a href="#3-7-Zookeeper-集群" class="headerlink" title="3.7 Zookeeper 集群"></a>3.7 Zookeeper 集群</h3><blockquote><p>具体部署过程可看我博客<a href="https://blog.csdn.net/IT_ZRS/article/details/125615805?spm=1001.2014.3001.5501">《ZooKeeper 集群部署》</a>，这里不再重复部署。</p></blockquote><h3 id="3-8-Kafka-集群"><a href="#3-8-Kafka-集群" class="headerlink" title="3.8 Kafka 集群"></a>3.8 Kafka 集群</h3><blockquote><p>下载地址：<a href="https://github.com/apache/kafka/releases/tag/3.1.1">https://github.com/apache/kafka/releases/tag/3.1.1</a></p></blockquote><p><code>Kafka 集群</code>依赖于 <code>Zookeeper 集群</code>，因此在部署 Kafka 集群前，需保证 Zookeeper 集群是正常工作的，一般将 Zookeeper 集群与 Kafka 集群部署在一起即可（当然如果你的服务器充裕的话，也可分开部署）。</p><p>1、下载并解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/apache/kafka/archive/refs/tags/3.1.1.tar.gz</span><br><span class="line">tar xzf 3.1.1.tar.gz -C /data/</span><br></pre></td></tr></table></figure><blockquote><p>官方提供的 Kafka 安装包中已经包含 Zookeeper 安装程序，对于非 Docker 安装的方式，直接下载 Kafka 安装包即可安装 Zookeeper 集群了，Kafka 相关配置文件如下图。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220806134544705.png" alt="image-20220806134544705"></p><p>2、修改配置文件</p><blockquote><p>配置文件：<code>/data/kafka-3.1.1/config/server.properties</code></p></blockquote><ul><li><p>kafka-1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">broker.id=1</span><br><span class="line">listeners=PLAINTEXT://192.168.56.137:9092</span><br><span class="line">num.network.threads=3</span><br><span class="line">num.io.threads=8</span><br><span class="line">socket.send.buffer.bytes=102400</span><br><span class="line">socket.receive.buffer.bytes=102400</span><br><span class="line">socket.request.max.bytes=104857600</span><br><span class="line">log.dirs=/data/kafka-3.1.1/logs</span><br><span class="line">num.partitions=6</span><br><span class="line">num.recovery.threads.per.data.dir=1</span><br><span class="line">offsets.topic.replication.factor=2</span><br><span class="line">transaction.state.log.replication.factor=1</span><br><span class="line">transaction.state.log.min.isr=1</span><br><span class="line">log.retention.hours=168</span><br><span class="line">log.segment.bytes=536870912</span><br><span class="line">log.retention.check.interval.ms=300000</span><br><span class="line">zookeeper.connect=192.168.56.137:2181,192.168.56.138:2181,192.168.56.139:2181</span><br><span class="line">zookeeper.connection.timeout.ms=6000</span><br><span class="line">group.initial.rebalance.delay.ms=0</span><br></pre></td></tr></table></figure><blockquote><p>创建配置文件中指定的日志路径</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/kafka-3.1.1/logs</span><br></pre></td></tr></table></figure></li><li><p>kafka-2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">broker.id=2</span><br><span class="line">listeners=PLAINTEXT://192.168.56.138:9092</span><br><span class="line">num.network.threads=3</span><br><span class="line">num.io.threads=8</span><br><span class="line">socket.send.buffer.bytes=102400</span><br><span class="line">socket.receive.buffer.bytes=102400</span><br><span class="line">socket.request.max.bytes=104857600</span><br><span class="line">log.dirs=/opt/data/kafka/logs</span><br><span class="line">num.partitions=6</span><br><span class="line">num.recovery.threads.per.data.dir=1</span><br><span class="line">offsets.topic.replication.factor=2</span><br><span class="line">transaction.state.log.replication.factor=1</span><br><span class="line">transaction.state.log.min.isr=1</span><br><span class="line">log.retention.hours=168</span><br><span class="line">log.segment.bytes=536870912</span><br><span class="line">log.retention.check.interval.ms=300000</span><br><span class="line">zookeeper.connect=192.168.56.137:2181,192.168.56.138:2181,192.168.56.139:2181</span><br><span class="line">zookeeper.connection.timeout.ms=6000</span><br><span class="line">group.initial.rebalance.delay.ms=0</span><br></pre></td></tr></table></figure><blockquote><p>创建配置文件中指定的日志路径</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/kafka-3.1.1/logs</span><br></pre></td></tr></table></figure></li><li><p>kafka-2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">broker.id=3</span><br><span class="line">listeners=PLAINTEXT://192.168.56.139:9092</span><br><span class="line">num.network.threads=3</span><br><span class="line">num.io.threads=8</span><br><span class="line">socket.send.buffer.bytes=102400</span><br><span class="line">socket.receive.buffer.bytes=102400</span><br><span class="line">socket.request.max.bytes=104857600</span><br><span class="line">log.dirs=/opt/data/kafka/logs</span><br><span class="line">num.partitions=6</span><br><span class="line">num.recovery.threads.per.data.dir=1</span><br><span class="line">offsets.topic.replication.factor=2</span><br><span class="line">transaction.state.log.replication.factor=1</span><br><span class="line">transaction.state.log.min.isr=1</span><br><span class="line">log.retention.hours=168</span><br><span class="line">log.segment.bytes=536870912</span><br><span class="line">log.retention.check.interval.ms=300000</span><br><span class="line">zookeeper.connect=192.168.56.137:2181,192.168.56.138:2181,192.168.56.139:2181</span><br><span class="line">zookeeper.connection.timeout.ms=6000</span><br><span class="line">group.initial.rebalance.delay.ms=0</span><br></pre></td></tr></table></figure><blockquote><p>创建配置文件中指定的日志路径</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/kafka-3.1.1/logs</span><br></pre></td></tr></table></figure></li></ul><p>3、启动 Kafka 集群</p><ul><li><p>kafka-1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /data/kafka-3.1.1</span><br><span class="line">nohup bin/kafka-server-start.sh config/server.properties &amp;</span><br></pre></td></tr></table></figure></li><li><p>kafka-2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /data/kafka-3.1.1</span><br><span class="line">nohup bin/kafka-server-start.sh config/server.properties &amp;</span><br></pre></td></tr></table></figure></li><li><p>kafka-3</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /data/kafka-3.1.1</span><br><span class="line">nohup bin/kafka-server-start.sh config/server.properties &amp;</span><br></pre></td></tr></table></figure></li></ul><p>&#x3D;&#x3D;至此，Kafka 集群部署完毕！&#x3D;&#x3D;</p><h3 id="3-9-FAQ"><a href="#3-9-FAQ" class="headerlink" title="3.9 FAQ"></a>3.9 FAQ</h3><h4 id="3-9-1-ES-Systemd-启动报错"><a href="#3-9-1-ES-Systemd-启动报错" class="headerlink" title="3.9.1 ES Systemd 启动报错"></a>3.9.1 ES Systemd 启动报错</h4><p>如果你配置 ES systemd 管理，对 jdk 的就就会有要求，否则无法启动，具体报错如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@es-1 bin]# journalctl -u es.service </span><br><span class="line">-- Logs begin at Wed 2022-06-22 09:38:05 CST, end at Wed 2022-06-22 09:45:27 CST. --</span><br><span class="line">Jun 22 09:45:27 es-1 systemd[1]: Starting elasticsearch...</span><br><span class="line">Jun 22 09:45:27 es-1 elasticsearch[1571]: which: no java in (/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin)</span><br><span class="line">Jun 22 09:45:27 es-1 elasticsearch[1571]: could not find java; set JAVA_HOME or ensure java is in PATH</span><br><span class="line">Jun 22 09:45:27 es-1 systemd[1]: es.service: control process exited, code=exited status=1</span><br><span class="line">Jun 22 09:45:27 es-1 systemd[1]: Failed to start elasticsearch.</span><br><span class="line">Jun 22 09:45:27 es-1 systemd[1]: Unit es.service entered failed state.</span><br><span class="line">Jun 22 09:45:27 es-1 systemd[1]: es.service failed.</span><br></pre></td></tr></table></figure><p>因为我的 jdk 路径是配置在 profile.d 下的，所在加载的时候没有识别出来，而且报错也给出了提示，修改一下路径即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /data/jdk/bin/* /usr/bin/</span><br></pre></td></tr></table></figure><p>以 systemd 启动的服务，同时还需要修改一下配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/systemd/system.conf</span><br><span class="line"></span><br><span class="line">DefaultLimitNOFILE=65536</span><br><span class="line">DefaultLimitNPROC=32000</span><br><span class="line">DefaultLimitMEMLOCK=infinity</span><br></pre></td></tr></table></figure><h4 id="3-9-2-Logstash-启动报错"><a href="#3-9-2-Logstash-启动报错" class="headerlink" title="3.9.2 Logstash 启动报错"></a>3.9.2 Logstash 启动报错</h4><p>当我运行测试命令启动 logstash 时，包如下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@logstash-1 logstash]# /data/logstash/bin/logstash -e &#x27;input &#123; stdin &#123;&#125; &#125; output &#123; elasticsearch &#123; hosts =&gt; [&quot;192.168.56.133:9200&quot;] &#125; &#125;&#x27;</span><br><span class="line">Sending Logstash&#x27;s logs to /data/logstash/logs which is now configured via log4j2.properties</span><br><span class="line">[2022-06-22T13:13:22,138][INFO ][logstash.modules.scaffold] Initializing module &#123;:module_name=&gt;&quot;fb_apache&quot;, :directory=&gt;&quot;/data/logstash/modules/fb_apache/configuration&quot;&#125;</span><br><span class="line">[2022-06-22T13:13:22,140][INFO ][logstash.modules.scaffold] Initializing module &#123;:module_name=&gt;&quot;netflow&quot;, :directory=&gt;&quot;/data/logstash/modules/netflow/configuration&quot;&#125;</span><br><span class="line">[2022-06-22T13:13:22,245][WARN ][logstash.config.source.multilocal] Ignoring the &#x27;pipelines.yml&#x27; file because modules or command line options are specified</span><br><span class="line">[2022-06-22T13:13:22,256][FATAL][logstash.runner          ] Logstash could not be started because there is already another instance using the configured data directory.  If you wish to run multiple instances, you must change the &quot;path.data&quot; setting.</span><br></pre></td></tr></table></figure><p>解决方案：因为在 logstash 数据目录下存在缓冲文件（.lock），删除即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@logstash-1 data]# cd /data/logstash/data/</span><br><span class="line">[root@logstash-1 data]# ll -a</span><br><span class="line">total 4</span><br><span class="line">drwxr-xr-x  4 root root  69 Jun 22 13:42 .</span><br><span class="line">drwxr-xr-x 12 root root 259 Jun 22 12:06 ..</span><br><span class="line">drwxr-xr-x  2 root root   6 Jun 22 12:06 dead_letter_queue</span><br><span class="line">-rw-r--r--  1 root root   0 Jun 22 13:42 .lock</span><br><span class="line">drwxr-xr-x  2 root root   6 Jun 22 12:06 queue</span><br><span class="line">-rw-r--r--  1 root root  36 Jun 22 12:06 uuid</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220622143509359.png" alt="image-20220622143509359"></p><h4 id="3-9-3-head-插件-406-错误"><a href="#3-9-3-head-插件-406-错误" class="headerlink" title="3.9.3 head 插件 406 错误"></a>3.9.3 head 插件 406 错误</h4><p>当我们在浏览数据时，发现右边框并无数据，F12 看一下报 406，原因是 es 6.x 的版本增加了严格的请求头校验，返回结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">“error” : “Content-Type [header](https://so.csdn.net/so/search?q=header&amp;spm=1001.2101.3001.7020) [application/x-www-form-urlencoded] is not supported”,</span><br><span class="line">“status” : 406</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220622151358131.png" alt="image-20220622151358131">解决方案：修改<code>vendor.js</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将文件复制到本地</span></span><br><span class="line">docker cp es-head:/usr/src/app/_site/vendor.js ./</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进行修改（定位至6886行）</span></span><br><span class="line">        ajaxSettings: &#123;</span><br><span class="line">                url: ajaxLocation,</span><br><span class="line">                isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),</span><br><span class="line">                global: true,</span><br><span class="line">                type: &quot;GET&quot;,</span><br><span class="line">                contentType: &quot;application/json;charset=UTF-8&quot;,</span><br><span class="line">                processData: true,</span><br><span class="line">                async: true,</span><br><span class="line">                ...</span><br><span class="line">                ...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再复制到容器中</span></span><br><span class="line">docker cp vendor.js es-head:/usr/src/app/_site/</span><br></pre></td></tr></table></figure><p>修改前：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220622152458877.png" alt="image-20220622152458877"></p><p>修改后：<br><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220622152619484.png" alt="image-20220622152619484"></p><p>无需重启 es-head，刷新一下 head 页面即可：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220622153010483.png" alt="image-20220622153010483"></p><hr><p>附件：…</p><h2 id="四、Docker-部署-ELK-集群"><a href="#四、Docker-部署-ELK-集群" class="headerlink" title="四、Docker 部署 ELK 集群"></a>四、Docker 部署 ELK 集群</h2><blockquote><p><a href="https://www.docker.elastic.co/">官方 Docker 镜像</a></p></blockquote><h3 id="4-1-ES-集群"><a href="#4-1-ES-集群" class="headerlink" title="4.1 ES 集群"></a>4.1 ES 集群</h3><h4 id="4-1-1-ES-集群部署"><a href="#4-1-1-ES-集群部署" class="headerlink" title="4.1.1 ES 集群部署"></a>4.1.1 ES 集群部署</h4><p><strong>1、安装docker</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行安装脚本</span><br></pre></td></tr></table></figure><p><strong>2、创建 ES 相关目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/elasticsearch/data</span><br><span class="line">mkdir -p /data/elasticsearch/logs</span><br><span class="line">mkdir -p /data/elasticsearch/plugins</span><br><span class="line">mkdir -p /data/elasticsearch/config/</span><br></pre></td></tr></table></figure><p><strong>3、任意一个 ES 节点运行一个es临时容器，拷贝配置文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd \</span><br><span class="line">--name=tmp \</span><br><span class="line">-e ES_JAVA_OPTS=&quot;-Xms512m -Xmx512m&quot; \</span><br><span class="line">-e &quot;discovery.type=single-node&quot; \</span><br><span class="line">elasticsearch:6.8.23</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker cp tmp:/usr/share/elasticsearch/config /data/elasticsearch/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或（运行容器时直接映射elasticsearch目录即可）</span></span><br><span class="line">docker cp tmp:/usr/share/elasticsearch /data/</span><br></pre></td></tr></table></figure><p><strong>4、修改 ES 配置文件</strong></p><ul><li><p>es-1</p><blockquote><p>elasticsearch.yml</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cluster.name 三者需相同</span></span><br><span class="line">cluster.name: es-cluster</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">node.name 节点名，设置与主机名一致即可</span></span><br><span class="line">node.name: es-1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">node.master 符合成为主节点的条件</span></span><br><span class="line">node.master: true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">node.data 符合成为数据节点的条件</span></span><br><span class="line">node.data: true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">path.data 数据存储路径（下面会进行创建）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">path.data: /data/elasticsearch/data</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">path.logs 日志存储路径（下面会进行创建）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">path.logs: /data/elasticsearch/logs</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bootstrap.memory_lock 锁住内存，即只使用内存，不使用交换分区</span></span><br><span class="line">bootstrap.memory_lock: true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">network.host 允许所有IP访问</span></span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">network.publish_host 集群节点交互IP（docker方式的部署填写公网IP）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker 方式部署的需指定 network.publish_host，否则无法访问集群</span></span><br><span class="line">network.publish_host: 192.168.56.133</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http.port web访问端口</span></span><br><span class="line">http.port: 9200</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">discovery.zen.ping.unicast.hosts 关闭单播</span></span><br><span class="line">discovery.zen.ping.unicast.hosts: [&quot;192.168.56.133&quot;, &quot;192.168.56.134&quot;, &quot;192.168.56.135&quot;]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">discovery.zen.minimum_master_nodes 指定master备选数（N/2+1）取整，N为集群节点数</span></span><br><span class="line">discovery.zen.minimum_master_nodes: 2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">discovery.zen.ping_timeout 节点在发现过程中的等待超时时间</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">discovery.zen.ping_timeout: 120s</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">discovery.zen.fd.ping_retries 节点发现重试次数</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">discovery.zen.fd.ping_retries: 10</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">client.transport.ping_timeout  ping命令的响应超时时间</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">client.transport.ping_timeout: 60s</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决跨域问题</span></span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure><blockquote><p>jvm.options</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># JVM configuration</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###############################################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># IMPORTANT: JVM heap size</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###############################################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># You should always set the min and max JVM heap</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># size to the same value. For example, to set</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># the heap to 4 GB, set:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># -Xms4g</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># -Xmx4g</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># See https://www.elastic.co/guide/en/elasticsearch/reference/current/heap-size.html</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># for more information</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###############################################################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Xms represents the initial size of total heap space</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Xmx represents the maximum size of total heap space</span></span><br><span class="line"></span><br><span class="line">-Xms512m</span><br><span class="line">-Xmx512m</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###############################################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Expert settings</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###############################################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># All settings below this section are considered</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># expert settings. Don&#x27;t tamper with them unless</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># you understand what you are doing</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###############################################################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># GC configuration</span></span></span><br><span class="line">8-13:-XX:+UseConcMarkSweepGC</span><br><span class="line">8-13:-XX:CMSInitiatingOccupancyFraction=75</span><br><span class="line">8-13:-XX:+UseCMSInitiatingOccupancyOnly</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># G1GC Configuration</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">NOTE: G1 GC is only supported on JDK version 10 or later</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">to use G1GC, uncomment the next two lines and update the version on the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">following three lines to your version of the JDK</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">10-13:-XX:-UseConcMarkSweepGC</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">10-13:-XX:-UseCMSInitiatingOccupancyOnly</span></span><br><span class="line">14-:-XX:+UseG1GC</span><br><span class="line">14-:-XX:G1ReservePercent=25</span><br><span class="line">14-:-XX:InitiatingHeapOccupancyPercent=30</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># DNS cache policy</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cache ttl <span class="keyword">in</span> seconds <span class="keyword">for</span> positive DNS lookups noting that this overrides the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">JDK security property networkaddress.cache.ttl; <span class="built_in">set</span> to -1 to cache forever</span></span><br><span class="line">-Des.networkaddress.cache.ttl=60</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cache ttl <span class="keyword">in</span> seconds <span class="keyword">for</span> negative DNS lookups noting that this overrides the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">JDK security property networkaddress.cache.negative ttl; <span class="built_in">set</span> to -1 to cache</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">forever</span></span><br><span class="line">-Des.networkaddress.cache.negative.ttl=10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># optimizations</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pre-touch memory pages used by the JVM during initialization</span></span><br><span class="line">-XX:+AlwaysPreTouch</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># basic</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">explicitly <span class="built_in">set</span> the stack size</span></span><br><span class="line">-Xss1m</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">set</span> to headless, just <span class="keyword">in</span> <span class="keyword">case</span></span></span><br><span class="line">-Djava.awt.headless=true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ensure UTF-8 encoding by default (e.g. filenames)</span></span><br><span class="line">-Dfile.encoding=UTF-8</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">use our provided JNA always versus the system one</span></span><br><span class="line">-Djna.nosys=true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">turn off a JDK optimization that throws away stack traces <span class="keyword">for</span> common</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">exceptions because stack traces are important <span class="keyword">for</span> debugging</span></span><br><span class="line">-XX:-OmitStackTraceInFastThrow</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">enable</span> helpful NullPointerExceptions (https://openjdk.java.net/jeps/358), <span class="keyword">if</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">they are supported</span></span><br><span class="line">14-:-XX:+ShowCodeDetailsInExceptionMessages</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">flags to configure Netty</span></span><br><span class="line">-Dio.netty.noUnsafe=true</span><br><span class="line">-Dio.netty.noKeySetOptimization=true</span><br><span class="line">-Dio.netty.recycler.maxCapacityPerThread=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">log4j 2</span></span><br><span class="line">-Dlog4j.shutdownHookEnabled=false</span><br><span class="line">-Dlog4j2.disable.jmx=true</span><br><span class="line">-Dlog4j2.formatMsgNoLookups=true</span><br><span class="line"></span><br><span class="line">-Djava.io.tmpdir=$&#123;ES_TMPDIR&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># heap dumps</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">generate a heap dump when an allocation from the Java heap fails</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">heap dumps are created <span class="keyword">in</span> the working directory of the JVM</span></span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">specify an alternative path <span class="keyword">for</span> heap dumps; ensure the directory exists and</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">has sufficient space</span></span><br><span class="line">-XX:HeapDumpPath=data</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">specify an alternative path <span class="keyword">for</span> JVM fatal error logs</span></span><br><span class="line">-XX:ErrorFile=logs/hs_err_pid%p.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># JDK 8 GC logging</span></span></span><br><span class="line"></span><br><span class="line">8:-XX:+PrintGCDetails</span><br><span class="line">8:-XX:+PrintGCDateStamps</span><br><span class="line">8:-XX:+PrintTenuringDistribution</span><br><span class="line">8:-XX:+PrintGCApplicationStoppedTime</span><br><span class="line">8:-Xloggc:logs/gc.log</span><br><span class="line">8:-XX:+UseGCLogFileRotation</span><br><span class="line">8:-XX:NumberOfGCLogFiles=32</span><br><span class="line">8:-XX:GCLogFileSize=64m</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">JDK 9+ GC logging</span></span><br><span class="line">9-:-Xlog:gc*,gc+age=trace,safepoint:file=logs/gc.log:utctime,pid,tags:filecount=32,filesize=64m</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">due to internationalization enhancements <span class="keyword">in</span> JDK 9 Elasticsearch need to <span class="built_in">set</span> the provider to COMPAT otherwise</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">time/date parsing will <span class="built_in">break</span> <span class="keyword">in</span> an incompatible way <span class="keyword">for</span> some <span class="built_in">date</span> patterns and locals</span></span><br><span class="line">9-:-Djava.locale.providers=COMPAT</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">temporary workaround <span class="keyword">for</span> C2 bug with JDK 10 on hardware with AVX-512</span></span><br><span class="line">10-:-XX:UseAVX=2</span><br></pre></td></tr></table></figure></li><li><p>es-2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同es-1，唯一不同的是 node.name 和 network.publish_host</span><br><span class="line">node.name: es-2</span><br><span class="line">network.publish_host: 192.168.56.134</span><br></pre></td></tr></table></figure></li><li><p>es-3</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同es-1，唯一不同的是 node.name 和 network.publish_host</span><br><span class="line">node.name: es-3</span><br><span class="line">network.publish_host: 192.168.56.135</span><br></pre></td></tr></table></figure></li></ul><p><strong>5、运行容器</strong></p><ul><li><p>es-1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">docker run -it \</span><br><span class="line">--name=es-1 \</span><br><span class="line">--privileged=true \</span><br><span class="line">--restart=always \</span><br><span class="line">-p 9200:9200 \</span><br><span class="line">-p 9300:9300 \</span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">-v /data/elasticsearch/data:/usr/share/elasticsearch/data \</span><br><span class="line">-v /data/elasticsearch/logs:/usr/share/elasticsearch/logs \</span><br><span class="line">-v /data/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">-v /data/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</span><br><span class="line">-v /data/elasticsearch/config/jvm.options:/usr/share/elasticsearch/config/jvm.options \</span><br><span class="line">-d elasticsearch:6.8.23</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或（运行容器时直接映射elasticsearch目录即可）</span></span><br><span class="line">docker run -it \</span><br><span class="line">--name=es-1 \</span><br><span class="line">--privileged=true \</span><br><span class="line">--restart=always \</span><br><span class="line">--net=host \</span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">-v /data/elasticsearch:/usr/share/elasticsearch \</span><br><span class="line">-d elasticsearch:6.8.23</span><br></pre></td></tr></table></figure></li><li><p>es-2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">docker run -it \</span><br><span class="line">--name=es-2 \</span><br><span class="line">--privileged=true \</span><br><span class="line">--restart=always \</span><br><span class="line">-p 9200:9200 \</span><br><span class="line">-p 9300:9300 \</span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">-v /data/elasticsearch/data:/usr/share/elasticsearch/data \</span><br><span class="line">-v /data/elasticsearch/logs:/usr/share/elasticsearch/logs \</span><br><span class="line">-v /data/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">-v /data/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</span><br><span class="line">-v /data/elasticsearch/config/jvm.options:/usr/share/elasticsearch/config/jvm.options \</span><br><span class="line">-d elasticsearch:6.8.23</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或（运行容器时直接映射elasticsearch目录即可）</span></span><br><span class="line">docker run -it \</span><br><span class="line">--name=es-2 \</span><br><span class="line">--privileged=true \</span><br><span class="line">--restart=always \</span><br><span class="line">--net=host \</span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">-v /data/elasticsearch:/usr/share/elasticsearch \</span><br><span class="line">-d elasticsearch:6.8.23</span><br></pre></td></tr></table></figure></li><li><p>es-3</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">docker run -it \</span><br><span class="line">--name=es-3 \</span><br><span class="line">--privileged=true \</span><br><span class="line">--restart=always \</span><br><span class="line">-p 9200:9200 \</span><br><span class="line">-p 9300:9300 \</span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">-v /data/elasticsearch/data:/usr/share/elasticsearch/data \</span><br><span class="line">-v /data/elasticsearch/logs:/usr/share/elasticsearch/logs \</span><br><span class="line">-v /data/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">-v /data/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</span><br><span class="line">-v /data/elasticsearch/config/jvm.options:/usr/share/elasticsearch/config/jvm.options \</span><br><span class="line">-d elasticsearch:6.8.23</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或（运行容器时直接映射elasticsearch目录即可）</span></span><br><span class="line">docker run -it \</span><br><span class="line">--name=es-3 \</span><br><span class="line">--privileged=true \</span><br><span class="line">--restart=always \</span><br><span class="line">--net=host \</span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">-v /data/elasticsearch:/usr/share/elasticsearch \</span><br><span class="line">-d elasticsearch:6.8.23</span><br></pre></td></tr></table></figure></li></ul><p>&#x3D;&#x3D;es-head 插件安装看 3.5 小节&#x3D;&#x3D;</p><p>集群状态查看：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220622233940503.png" alt="image-20220622233940503"></p><p><strong>6、配置 ES 集群证书</strong></p><blockquote><ol><li><p>先保证在没有使用证书的情况下，ES 集群是正常运行的，然后再配置 ES 集群证书；</p></li><li><p>在任意 ES 集群节点上生成集群证书（本次我在 es-1 节点）；</p></li><li><p>证书生成完毕之后，再将对应证书 copy 到其他节点的 config 目录下；</p></li><li><p>重启 ES 集群，此时保证集群正常运行，如果此时集群正常，说明集群间已经通过密钥方式通信；</p></li><li><p>然后创建 ES 集群的用户名&#x2F;密码（在任意 ES 集群节点上执行即可，因为集群会同步状态）；</p></li><li><p>启用 ES 集群证书的目：数据安全、防止其他 ES 节点恶意并入集群。</p></li></ol></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it es-1 bash</span><br><span class="line">./bin/elasticsearch-certutil ca</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会在当前目录生产elastic-stack-ca.p12证书文件</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624141418370.png" alt="image-20220624141418370"></p><p>为集群中的每个节点生成证书和私钥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch-certutil cert --ca elastic-stack-ca.p12</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624142040376.png" alt="image-20220624142040376"></p><p>复制证书文件到其他节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp elastic-* es-2:/data/elasticsearch/config/</span><br><span class="line">scp elastic-* es-3:/data/elasticsearch/config/</span><br></pre></td></tr></table></figure><p>接着修改 ES 集群配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cluster.name 三者需相同</span></span><br><span class="line">cluster.name: es-cluster</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">node.name 节点名，设置与主机名一致即可</span></span><br><span class="line">node.name: es-1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">node.master 符合成为主节点的条件</span></span><br><span class="line">node.master: true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">node.data 符合成为数据节点的条件</span></span><br><span class="line">node.data: true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">path.data 数据存储路径（下面会进行创建）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">path.data: /data/elasticsearch/data</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">path.logs 日志存储路径（下面会进行创建）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">path.logs: /data/elasticsearch/logs</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bootstrap.memory_lock 锁住内存，即只使用内存，不使用交换分区（有时会报错，报错时注释掉就行）</span></span><br><span class="line">bootstrap.memory_lock: true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">network.host 允许所有IP访问</span></span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">network.publish_host 集群节点交互IP（docker方式的部署填写公网IP）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker 方式部署的需指定 network.publish_host，否则无法访问集群</span></span><br><span class="line">network.publish_host: 192.168.56.133</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http.port web访问端口</span></span><br><span class="line">http.port: 9200</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">discovery.zen.ping.unicast.hosts 关闭单播</span></span><br><span class="line">discovery.zen.ping.unicast.hosts: [&quot;192.168.56.133&quot;, &quot;192.168.56.134&quot;, &quot;192.168.56.135&quot;]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">discovery.zen.minimum_master_nodes 指定master备选数（N/2+1）取整，N为集群节点数</span></span><br><span class="line">discovery.zen.minimum_master_nodes: 2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">discovery.zen.ping_timeout 节点在发现过程中的等待超时时间</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">discovery.zen.ping_timeout: 120s</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">discovery.zen.fd.ping_retries 节点发现重试次数</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">discovery.zen.fd.ping_retries: 10</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">client.transport.ping_timeout  ping命令的响应超时时间</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">client.transport.ping_timeout: 60s</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决跨域问题</span></span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Auth（如果你不配置证书，只是单纯的给ES设置密码，打开下面两项即可）</span></span><br><span class="line">xpack.security.enabled: true</span><br><span class="line">xpack.security.transport.ssl.enabled: true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果你需要使用证书请保持下列参数是打开状态</span></span><br><span class="line">xpack.security.transport.ssl.verification_mode: certificate</span><br><span class="line">xpack.security.transport.ssl.keystore.path: elastic-certificates.p12</span><br><span class="line">xpack.security.transport.ssl.truststore.path: elastic-certificates.p12</span><br></pre></td></tr></table></figure><p>重启 ES 集群：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker restart es-1</span><br><span class="line">docker restart es-2</span><br><span class="line">docker restart es-3</span><br></pre></td></tr></table></figure><p>新增用户名、密码：</p><blockquote><p>任意一台 ES 集群节点上执行即可，执行结果会同步到整个 ES 集群</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch-setup-passwords interactive</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我的密码为123456</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">西谷：Xgxy@2021!</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624155056881.png" alt="image-20220624155056881"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Changed password for user [apm_system]</span><br><span class="line">Changed password for user [kibana]</span><br><span class="line">Changed password for user [logstash_system]</span><br><span class="line">Changed password for user [beats_system]</span><br><span class="line">Changed password for user [remote_monitoring_user]</span><br><span class="line">Changed password for user [elastic]</span><br></pre></td></tr></table></figure><p>上面的用户名密码在任意一台 ES 集群服务器上执行就行，密码会被更新到集群中，就算你在其他节点设置密码也是会报错的，而且会提示你，强一致性密码已经更新至集群，如下所示：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624155456231.png" alt="image-20220624155456231"></p><p><strong>7、keepalived 高可用</strong></p><p>因为集群环境下所有的 ES 节点都是平等的，所以用 keepalived 来做集群统一入口。</p><p>安装keepalived</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y keepalived</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置文件路径：/etc/keepalived/keepalived.conf</span></span><br></pre></td></tr></table></figure><ul><li><p>es-1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id es</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script check_es &#123;</span><br><span class="line">    script &quot;/etc/keepalived/check_es_status.sh&quot;</span><br><span class="line">    interval 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 90</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.56.10/24</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        check_es</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>es-2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id es</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script check_es &#123;</span><br><span class="line">    script &quot;/etc/keepalived/check_es_status.sh&quot;</span><br><span class="line">    interval 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_2 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 90</span><br><span class="line">    priority 50</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.56.10/24</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        check_es</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>es-3</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id es</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script check_es &#123;</span><br><span class="line">    script &quot;/etc/keepalived/check_es_status.sh&quot;</span><br><span class="line">    interval 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_3 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 90</span><br><span class="line">    priority 50</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.56.10/24</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        check_es</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>健康检测脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/keepalived/check_es_status.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">docker ps |grep es-1</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">    echo &quot;status ok&quot;</span><br><span class="line">else</span><br><span class="line">    systemctl stop keepalived.service</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>启动 keepalived</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl start keepalived.service</span><br><span class="line">systemctl enable keepalived.service</span><br><span class="line">systemctl stop keepalived.service</span><br><span class="line">systemctl restart keepalived.service</span><br></pre></td></tr></table></figure><h4 id="4-1-2-ES-修改-x2F-忘记密码"><a href="#4-1-2-ES-修改-x2F-忘记密码" class="headerlink" title="4.1.2 ES 修改&#x2F;忘记密码"></a>4.1.2 ES 修改&#x2F;忘记密码</h4><blockquote><p>Kibana 可视化操作</p></blockquote><p><strong>1、点击用户页面对应的用户名</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624163946479.png" alt="image-20220624163946479"></p><p><strong>2、进入用户密码修改页面</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624164115642.png" alt="image-20220624164115642"></p><blockquote><p>如果忘记密码，可根据以下忘记密码步骤重置密码</p></blockquote><h4 id="4-3-2-ES-实例操作"><a href="#4-3-2-ES-实例操作" class="headerlink" title="4.3.2 ES 实例操作"></a>4.3.2 ES 实例操作</h4><p><strong>1、修改密码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H &quot;Content-Type:application/json&quot; -XPOST -u elastic &#x27;http://172.17.16.95:9200/_xpack/security/user/elastic/_password&#x27; -d &#x27;&#123; &quot;password&quot; : &quot;123456&quot; &#125;&#x27;</span><br></pre></td></tr></table></figure><blockquote><p>这种方式修改密码需要注意的是：</p><ol><li>之前设置过 elastic 的用户密码；</li><li>还记的用户 elastic 用户的密码。</li></ol></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220816141358233.png" alt="image-20220816141358233"></p><p><strong>2、忘记密码</strong></p><p>&#x3D;&#x3D;注意&#x3D;&#x3D;：如果忘记之前 elastic 用户的密码，这个时候又要用到 ES 的加密功能，那需要重置ES的密码认证。详细步骤如下：</p><p>&#x3D;&#x3D;方法1：&#x3D;&#x3D;</p><ul><li><p>关闭密码使用策略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /data/elasticsearch/config/elasticsearch.yml</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220816141705539.png" alt="image-20220816141705539"></p></li><li><p>重启 ES</p><blockquote><p>重启 ES 后，查看索引，发现多了一个<code>.security-6</code></p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220816142328223.png" alt="image-20220816142328223"></p></li><li><p>删除<code>.security-6</code>索引</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XDELETE http://10.150.16.95:9200/.security-6 &#123;&quot;acknowledged&quot;:true&#125;[root@qcloud elasticsearch]</span><br></pre></td></tr></table></figure></li><li><p>ES 启用密码使用策略</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /data/elasticsearch/config/elasticsearch.yml</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220816161352121.png" alt="image-20220816161352121"></p></li><li><p>重启 ES</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart es-1</span><br></pre></td></tr></table></figure></li><li><p>进入容器开始时初始化密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">看2.2部分</span></span><br></pre></td></tr></table></figure></li></ul><p>&#x3D;&#x3D;方法2（推荐）：&#x3D;&#x3D;</p><ul><li><p>进入容器，创建一个管理用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@qcloud elasticsearch]# docker exec -it es-1 bash</span><br><span class="line">[root@qcloud elasticsearch]# ./bin/elasticsearch-users useradd newadmin -p password -r superuser</span><br><span class="line">[root@qcloud elasticsearch]# ./bin/elasticsearch-users list</span><br><span class="line">newadmin       : superuser</span><br></pre></td></tr></table></figure></li><li><p>退出容器，并修改密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -s --user newadmin:password -XPUT &quot;http://10.150.16.95:9200/_xpack/security/user/elastic/_password?pretty&quot; -H &#x27;Content-Type: application/json&#x27; -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;password&quot; : &quot;zhurs@123&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure></li><li><p>Kibana 登录</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220816162722239.png" alt="image-20220816162722239"></p></li></ul><h3 id="4-2-Logstash-分流"><a href="#4-2-Logstash-分流" class="headerlink" title="4.2 Logstash 分流"></a>4.2 Logstash 分流</h3><blockquote><p><a href="https://www.elastic.co/guide/en/logstash/current/index.html">《官方文档》</a></p></blockquote><p><strong>1、下载镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull docker.elastic.co/logstash/logstash:6.8.23</span><br></pre></td></tr></table></figure><p><strong>2、运行临时容器，并拷贝配置文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name=tmp logstash:6.8.23</span><br><span class="line">docker cp tmp:/usr/share/logstash /data/</span><br></pre></td></tr></table></figure><p><strong>3、创建配置文件并授权</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/logstash/config/conf.d</span><br><span class="line">chmod 777 -R /data/logstash</span><br></pre></td></tr></table></figure><p><strong>4、修改配置文件</strong></p><ul><li><p>修改前</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /data/logstash/config/logstash.yml</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220627113158512.png" alt="image-20220627113158512"></p></li><li><p>修改后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat /data/logstash/config/logstash.yml</span><br><span class="line"></span><br><span class="line">http.host: &quot;0.0.0.0&quot;</span><br><span class="line">xpack.monitoring.enabled: true</span><br><span class="line">xpack.monitoring.elasticsearch.username: &quot;elastic&quot;</span><br><span class="line">xpack.monitoring.elasticsearch.password: &quot;123456&quot;</span><br><span class="line">xpack.monitoring.elasticsearch.hosts: [ &quot;http://192.168.56.133:9200&quot;,&quot;http://192.168.56.134:9200&quot;,&quot;http://192.168.56.135:9200&quot; ]</span><br><span class="line">path.config: /usr/share/logstash/config/conf.d/*.conf</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220627164557104.png" alt="image-20220627164557104"></p></li></ul><p><strong>5、启动容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">桥接</span></span><br><span class="line">docker run -d \</span><br><span class="line">  --name=logstash \</span><br><span class="line">  --privileged=true \</span><br><span class="line">  --restart=always \</span><br><span class="line">  -p 5044:5044 \</span><br><span class="line">  -v /etc/localtime:/etc/localtime \</span><br><span class="line">  -v /data/logstash:/usr/share/logstash \</span><br><span class="line">  logstash:6.8.23</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host（本次采用）</span></span><br><span class="line">docker run -d \</span><br><span class="line">  --name=logstash \</span><br><span class="line">  --privileged=true \</span><br><span class="line">  --restart=always \</span><br><span class="line">  --net=host \</span><br><span class="line">  -v /etc/localtime:/etc/localtime \</span><br><span class="line">  -v /data/logstash:/usr/share/logstash \</span><br><span class="line">  logstash:6.8.23</span><br></pre></td></tr></table></figure><blockquote><p>接下来看看二进制部署的 Logstash</p></blockquote><p><strong>1、JDK 环境</strong></p><p>上面有安装步骤</p><p><strong>2、解压</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar xzf logstash-6.8.23.tar.gz -C /data/</span><br><span class="line">mv /data/logstash-6.8.23/ /data/logstash</span><br></pre></td></tr></table></figure><p><strong>3、创建配置文件目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/logstash/config/conf.d</span><br></pre></td></tr></table></figure><p><strong>4、编写配置文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">vim /data/logstash/config/conf.d/all.conf</span><br><span class="line"></span><br><span class="line">input&#123;</span><br><span class="line">    file&#123;</span><br><span class="line">        path =&gt; [&quot;/data/nginx/logs/access.log&quot;]</span><br><span class="line">        type =&gt; &quot;nginx_access&quot;</span><br><span class="line">        start_position =&gt; &quot;beginning&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">input&#123;</span><br><span class="line">    file&#123;</span><br><span class="line">        path =&gt; [&quot;/var/log/messages&quot;]</span><br><span class="line">        type =&gt; &quot;system_error&quot;</span><br><span class="line">        start_position =&gt; &quot;beginning&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output&#123;</span><br><span class="line">    if [type] ==  &quot;nginx_access&quot; &#123;</span><br><span class="line">        elasticsearch &#123;</span><br><span class="line">            hosts =&gt; [&quot;192.168.56.133:9200&quot;,&quot;192.168.56.134:9200&quot;,&quot;192.168.56.135:9200&quot;] </span><br><span class="line">            index =&gt; [&quot;%&#123;type&#125;-%&#123;+YYYY.MM.dd&#125;&quot;]</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    if [type] ==  &quot;system_error&quot; &#123;</span><br><span class="line">        elasticsearch &#123;</span><br><span class="line">            hosts =&gt; [&quot;192.168.56.133:9200&quot;,&quot;192.168.56.134:9200&quot;,&quot;192.168.56.135:9200&quot;] </span><br><span class="line">            index =&gt; [&quot;%&#123;type&#125;-%&#123;+YYYY.MM.dd&#125;&quot;]</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">前台启动</span></span><br><span class="line">/data/logstash/bin/logstash -f /data/logstash/config/conf.d/ --config.reload.automatic</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后台启动</span></span><br><span class="line">nohup /data/logstash/bin/logstash -f /data/logstash/config/conf.d/ --config.reload.automatic &amp;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--config.reload.automatic：可以加载conf.d 目录下的所有.conf文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">想要单独加载的话，则去掉--config.reload.automatic参数，并指定具体的 .conf 文件</span></span><br></pre></td></tr></table></figure><p><strong>5、集群验证</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220623102312200.png" alt="image-20220623102312200"></p><h3 id="4-3-Kibana-前端展示"><a href="#4-3-Kibana-前端展示" class="headerlink" title="4.3 Kibana 前端展示"></a>4.3 Kibana 前端展示</h3><blockquote><p>官方文档：<a href="https://www.elastic.co/guide/cn/kibana/current/index.html">https://www.elastic.co/guide/cn/kibana/current/index.html</a></p></blockquote><p><strong>1、安装 es-head 插件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name=es-head \</span><br><span class="line">  --privileged=true \</span><br><span class="line">  --restart=always \</span><br><span class="line">  -v /etc/localtime:/etc/localtime \</span><br><span class="line">  -p 9100:9100 \</span><br><span class="line">  docker.io/mobz/elasticsearch-head:5-alpine</span><br></pre></td></tr></table></figure><p><strong>2、安装 Kibana</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行临时容器</span></span><br><span class="line">docker run -itd --name=tmp kibana:6.8.23</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拷贝相关目录</span></span><br><span class="line">docker cp tmp:/usr/share/kibana /data/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">授权</span></span><br><span class="line">chmod 777 -R /data/kibana/*</span><br></pre></td></tr></table></figure><p><strong>3、修改配置文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /data/kibana/config/kibana.yml</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Default Kibana configuration <span class="keyword">for</span> docker target</span></span><br><span class="line">server.name: kibana</span><br><span class="line">server.host: &quot;0&quot;</span><br><span class="line">elasticsearch.hosts: [ &quot;http://192.168.56.133:9200&quot;,&quot;http://192.168.56.134:9200&quot;,&quot;http://192.168.56.135:9200&quot; ]</span><br><span class="line">xpack.monitoring.ui.container.elasticsearch.enabled: true</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">kibana.index: <span class="string">&quot;.kibana&quot;</span></span></span><br><span class="line">i18n.locale: &quot;zh-CN&quot;</span><br><span class="line">elasticsearch.username: &quot;kibana&quot;</span><br><span class="line">elasticsearch.password: &quot;123456&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">xpack.reporting.encryptionKey: <span class="string">&quot;a_random_string&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">xpack.security.encryptionKey: <span class="string">&quot;something_at_least_32_characters&quot;</span></span></span><br></pre></td></tr></table></figure><p><strong>4、启动新容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --restart=always \</span><br><span class="line">    --privileged=true \</span><br><span class="line">    --name=kibana \</span><br><span class="line">-p 5601:5601 \</span><br><span class="line">-v &quot;/data/kibana:/usr/share/kibana&quot; \</span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">kibana:6.8.23</span><br></pre></td></tr></table></figure><p><strong>5、访问验证</strong></p><blockquote><p><a href="http://192.168.56.136:5601/">http://192.168.56.136:5601/</a></p></blockquote><p>输入账号密码：&lt;账号密码就是你配置ES时的密码&gt;</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624155844791.png" alt="image-20220624155844791"></p><blockquote><p>然后就会进入登录页面。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220623123020509.png" alt="image-20220623123020509"></p><blockquote><p>上图是我之前截的图，当时没有设置 ES 集群密码强一致性验证，设置之后你会发现管理菜单下会多出一个安全性&#x3D;&#x3D;&gt;<code>用户/角色</code></p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624160113968.png" alt="image-20220624160113968"></p><h3 id="4-4-Nginx-反向代理"><a href="#4-4-Nginx-反向代理" class="headerlink" title="4.4 Nginx 反向代理"></a>4.4 Nginx 反向代理</h3><p><strong>1、安装 Nginx</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">看6.2.4</span></span><br><span class="line">docker run -itd \</span><br><span class="line">    --name=nginx \</span><br><span class="line">    --privileged=true \</span><br><span class="line">    --restart=always \</span><br><span class="line">    --net=host \</span><br><span class="line">    -v /etc/localtime:/etc/localtime \</span><br><span class="line">    -v /data/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">    -v /data/nginx/conf/conf.d:/etc/nginx/conf.d \</span><br><span class="line">    -v /data/nginx/html:/usr/share/nginx/html \</span><br><span class="line">    -v /data/nginx/logs:/var/log/nginx nginx:1.20.2</span><br></pre></td></tr></table></figure><p><strong>2、反向代理</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  192.168.56.136;</span><br><span class="line"></span><br><span class="line">    # kibana前端展示</span><br><span class="line">    location / &#123;</span><br><span class="line">        root  html;</span><br><span class="line">        proxy_pass http://192.168.56.136:5601/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # es-head插件</span><br><span class="line">    location /head/ &#123;</span><br><span class="line">        proxy_pass http://192.168.56.136:9100/;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    # Kafka-Manager可视化管理</span><br><span class="line">    location /manager/ &#123;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_pass http://192.168.56.136:9000/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-Zookeeper-集群"><a href="#4-5-Zookeeper-集群" class="headerlink" title="4.5 Zookeeper 集群"></a>4.5 Zookeeper 集群</h3><p><strong>1、pull 镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull zookeeper:3.7.1</span><br></pre></td></tr></table></figure><p><strong>2、创建对应目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/zookeeper/conf</span><br><span class="line">mkdir -p /data/zookeeper/data</span><br><span class="line">mkdir -p /data/zookeeper/datalog</span><br><span class="line">mkdir -p /data/zookeeper/logs</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置文件路径：/data/zookeeper/conf</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数据存储路径：/data/zookeeper/data</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数据日志存储路径：/data/zookeeper/datalog</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">日志存储路径：/data/zookeeper/logs</span></span><br></pre></td></tr></table></figure><p><strong>3、创建配置文件</strong></p><blockquote><p>三个节点均添加</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/data</span><br><span class="line">dataLogDir=/datalog</span><br><span class="line">quorumListenOnAllIPs=true</span><br><span class="line">clientPort=2181 </span><br><span class="line">tickTime=2000 </span><br><span class="line">initLimit=20 </span><br><span class="line">syncLimit=10 </span><br><span class="line">server.1=192.168.56.137:2888:3888;2181</span><br><span class="line">server.2=192.168.56.138:2888:3888;2181</span><br><span class="line">server.3=192.168.56.139:2888:3888;2181</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">基础参数说明：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tickTime：心跳检测时间</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">initLimit：follower连接到leader的初始化时间 --&gt; 10*2000=20s</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">quorumListenOnAllIPs：是否在所有可用的IP上监听来自其对等节点的连接请求，默认值为<span class="literal">false</span>，这意味着只在zoo.cfg中配置的服务器ip地址上监听连接请求</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">autopurge.snapRetainCount：保留的快照文件数目，默认是保留3个 --&gt; 自动清理Zookeeper的历史数据</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">autopurge.purgeInterval：清理频率（单位是小时），默认是0，表示不开启自动清理功能 --&gt; 自动清理Zookeeper的历史数据</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">端口说明：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2181：对Client端提供服务的端口（可自定义）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2888：集群内部通信端口（可自定义）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3888：选举Leader的端口（可自定义）</span></span><br></pre></td></tr></table></figure><p><strong>4、启动 ZK 集群</strong></p><blockquote><p>zk-1 部署于 kafka-1 服务器上</p><p>zk-2 部署于 kafka-2 服务器上</p><p>zk-3 部署于 kafka-3 服务器上</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">zk-1</span></span><br><span class="line">docker run -d \</span><br><span class="line">   --restart=always \</span><br><span class="line">   --name=zk-1 \</span><br><span class="line">   --privileged=true \</span><br><span class="line">   --net=host \</span><br><span class="line">   -e ZOO_MY_ID=1 \</span><br><span class="line">   -v /data/zookeeper/conf/zoo.cfg:/conf/zoo.cfg \</span><br><span class="line">   -v /data/zookeeper/data:/data \</span><br><span class="line">   -v /data/zookeeper/datalog:/datalog \</span><br><span class="line">   -v /data/zookeeper/logs:/logs \</span><br><span class="line">   -v /etc/localtime:/etc/localtime \</span><br><span class="line">   zookeeper:3.7.1</span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">zk-2</span></span><br><span class="line">docker run -d \</span><br><span class="line">   --restart=always \</span><br><span class="line">   --name zk-2 \</span><br><span class="line">   --privileged=true \</span><br><span class="line">   --net=host \</span><br><span class="line">   -e ZOO_MY_ID=2 \</span><br><span class="line">   -v /data/zookeeper/conf/zoo.cfg:/conf/zoo.cfg \</span><br><span class="line">   -v /data/zookeeper/data:/data \</span><br><span class="line">   -v /data/zookeeper/datalog:/datalog \</span><br><span class="line">   -v /data/zookeeper/logs:/logs \</span><br><span class="line">   -v /etc/localtime:/etc/localtime \</span><br><span class="line">   zookeeper:3.7.1</span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">zk-3</span></span><br><span class="line">docker run -d \</span><br><span class="line">   --restart=always \</span><br><span class="line">   --name zk-3 \</span><br><span class="line">   --privileged=true \</span><br><span class="line">   --net=host \</span><br><span class="line">   -e ZOO_MY_ID=3 \</span><br><span class="line">   -v /data/zookeeper/conf/zoo.cfg:/conf/zoo.cfg \</span><br><span class="line">   -v /data/zookeeper/data:/data \</span><br><span class="line">   -v /data/zookeeper/datalog:/datalog \</span><br><span class="line">   -v /data/zookeeper/logs:/logs \</span><br><span class="line">   -v /etc/localtime:/etc/localtime \</span><br><span class="line">   zookeeper:3.7.1</span><br></pre></td></tr></table></figure><p><strong>5、查看集群选举情况</strong></p><blockquote><p>看到 leader 为 zk-2，只要其中某一台服务器挂了，剩余两者会进行 leader 选举。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@kafka-1 ~]# docker exec -it zk-1 bash</span><br><span class="line">root@kafka-1:/apache-zookeeper-3.7.1-bin# bin/zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /conf/zoo.cfg</span><br><span class="line">Client port found: 2181. Client address: localhost. Client SSL: false.</span><br><span class="line">Mode: follower</span><br><span class="line"></span><br><span class="line">[root@kafka-2 ~]# docker exec -it zk-2 bash</span><br><span class="line">root@kafka-2:/apache-zookeeper-3.7.1-bin# bin/zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /conf/zoo.cfg</span><br><span class="line">Client port found: 2181. Client address: localhost. Client SSL: false.</span><br><span class="line">Mode: leader</span><br><span class="line"></span><br><span class="line">[root@kafka-3 ~]# docker exec -it zk-3 bash</span><br><span class="line">root@kafka-3:/apache-zookeeper-3.7.1-bin# bin/zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /conf/zoo.cfg</span><br><span class="line">Client port found: 2181. Client address: localhost. Client SSL: false.</span><br><span class="line">Mode: follower</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;至此，ZK 集群部署完毕！&#x3D;&#x3D;</p><h3 id="4-6-Kafka-集群"><a href="#4-6-Kafka-集群" class="headerlink" title="4.6 Kafka 集群"></a>4.6 Kafka 集群</h3><p><strong>1、pull 镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull bitnami/kafka:3.1.1</span><br></pre></td></tr></table></figure><p><strong>2、运行容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kafka-1</span></span><br><span class="line">docker run -d \</span><br><span class="line">    --name=kafka-1 \</span><br><span class="line">    --restart=always \</span><br><span class="line">    --privileged=true \</span><br><span class="line">    --net=host \</span><br><span class="line">    -e KAFKA_BROKER_ID=1 \</span><br><span class="line">    -e KAFKA_ZOOKEEPER_CONNECT=&quot;192.168.56.137:2181,192.168.56.138:2181,192.168.56.139:2181&quot; \</span><br><span class="line">    -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://192.168.56.137:9092 \</span><br><span class="line">    -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 \</span><br><span class="line">    -e ALLOW_PLAINTEXT_LISTENER=yes \</span><br><span class="line">    -v /etc/localtime:/etc/localtime \</span><br><span class="line">    -t bitnami/kafka:3.1.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kafka-2</span></span><br><span class="line">docker run -d \</span><br><span class="line">    --name=kafka-2 \</span><br><span class="line">    --restart=always \</span><br><span class="line">    --privileged=true \</span><br><span class="line">    --net=host \</span><br><span class="line">    -e KAFKA_BROKER_ID=2 \</span><br><span class="line">    -e KAFKA_ZOOKEEPER_CONNECT=&quot;192.168.56.137:2181,192.168.56.138:2181,192.168.56.139:2181&quot; \</span><br><span class="line">    -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://192.168.56.138:9092 \</span><br><span class="line">    -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 \</span><br><span class="line">    -e ALLOW_PLAINTEXT_LISTENER=yes \</span><br><span class="line">    -v /etc/localtime:/etc/localtime \</span><br><span class="line">    -t bitnami/kafka:3.1.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kafka-3</span></span><br><span class="line">docker run -d \</span><br><span class="line">    --name=kafka-3 \</span><br><span class="line">    --restart=always \</span><br><span class="line">    --privileged=true \</span><br><span class="line">    --net=host \</span><br><span class="line">    -e KAFKA_BROKER_ID=3 \</span><br><span class="line">    -e KAFKA_ZOOKEEPER_CONNECT=&quot;192.168.56.137:2181,192.168.56.138:2181,192.168.56.139:2181&quot; \</span><br><span class="line">    -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://192.168.56.139:9092 \</span><br><span class="line">    -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 \</span><br><span class="line">    -e ALLOW_PLAINTEXT_LISTENER=yes \</span><br><span class="line">    -v /etc/localtime:/etc/localtime \</span><br><span class="line">    -t bitnami/kafka:3.1.1</span><br></pre></td></tr></table></figure><p><strong>3、安装 kafka-manager 管理工具</strong></p><blockquote><p>我们在 kibana 上部署</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull sheepkiller/kafka-manager:stable</span><br></pre></td></tr></table></figure><blockquote><p>运行容器</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --name=kafka-manager \</span><br><span class="line">    --restart=always \</span><br><span class="line">    --privileged=true \</span><br><span class="line">    -p 9000:9000 \</span><br><span class="line">    -e ZK_HOSTS=&quot;192.168.56.137:2181,192.168.56.138:2181,192.168.56.139:2181&quot; \</span><br><span class="line">    sheepkiller/kafka-manager:stable</span><br></pre></td></tr></table></figure><blockquote><p>浏览器访问：<a href="http://192.168.56.136:9000/">http://192.168.56.136:9000/</a></p></blockquote><p>创建 Kafka 集群节点，来查看当前集群状态：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220623215647425.png" alt="image-20220623215647425"></p><p>依次建立即可：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220623215853651.png" alt="image-20220623215853651"></p><p>看看集群状态：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220623220003302.png" alt="image-20220623220003302"></p><p>进入 Brokers 查看，每一个 Brokers 代表一个 Kafka 实例，这里显示为 3 ，所以我们的集群实例为三个：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220623220148318.png" alt="image-20220623220148318"></p><p>&#x3D;&#x3D;至此，Kafka集群部署完毕！&#x3D;&#x3D;</p><h3 id="4-7-Filebeat-原理及应用"><a href="#4-7-Filebeat-原理及应用" class="headerlink" title="4.7 Filebeat 原理及应用"></a>4.7 Filebeat 原理及应用</h3><blockquote><p>官方文档：<a href="https://www.elastic.co/guide/en/beats/filebeat/6.8/index.html">Doc</a></p></blockquote><h4 id="4-7-1-架构图"><a href="#4-7-1-架构图" class="headerlink" title="4.7.1 架构图"></a>4.7.1 架构图</h4><p>Filebeat 隶属于Beats，一款轻量级的数据收集引擎，那它如何工作于 ELK 集群中呢？</p><p>Filebeat 安装在要收集日志的应用服务器中，Filebeat收集到日志之后传输到kafka中，logstash通过kafka拿到日志，在由logstash传给后面的es，es将日志传给后面的kibana，最后通过kibana展示出来。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/filebeat.png" alt="filebeat"></p><h4 id="4-7-2-工作原理"><a href="#4-7-2-工作原理" class="headerlink" title="4.7.2 工作原理"></a>4.7.2 工作原理</h4><p><strong>1、输入</strong></p><p>比如定义了一个输入类型（type）为 log 的源，在启动 filebeat 时，输入查找驱动器会匹配全局（glob）路径（path）的所有文件，并为每个文件启动一个收集器（harvester），且每个输入都在自己的 go 进程中运行。只有当收集文件有新内容时才会启动（harvester）。</p><p><strong>2、如何保持文件状态</strong></p><p>在实际中会有个问题，如果输出（Kafka、ES、Kibana）无法连接（访问）时，filebeat 如何保持文件状态？该文件内容是否成功发送给输出？</p><p>答案是可以的，<code>Filebeat 会保存每个文件的状态</code>，它会把<code>注册表文件中的状态</code>刷新到磁盘，该状态记录了<code>harvester</code>读取文件的最后一个偏移量，如果此时无法访问 Elasticsearch 或 Logstash 等输出，Filebeat 会跟踪发送的最后几行，并在输出再次可用时继续读取文件，从而确保发送所有日志行。</p><p>在 Filebeat 运行时，每个输入的状态信息也会保存在内存中。当 Filebeat 重新启动时，来自注册表文件的数据用于重建状态，并且 Filebeat 在最后一个已知位置继续每个 <code>harvester</code>（即继续采集当前最新数据并输出到输出目标）。</p><p>也就是说只有 <code>Filebeat</code> 将 <code>harvester</code> 到的日志内容成功发送到输出目标（Kafka、ES、Kibana），且直到输出确认它已收到事件时，才会开启下一轮的 <code>harvester</code> 。如果在发送事件的过程中关闭 <code>Filebeat</code>，它不会在关闭前等待输出确认所有事件是否收到，&#x3D;&#x3D;任何发送到输出但在 Filebeat 关闭之前未确认的事件，在 Filebeat 重新启动时会再次发送&#x3D;&#x3D;。这可确保每个事件至少发送一次，但最终可能会将重复的事件发送到输出。我们可以通过设置 <a href="https://www.elastic.co/guide/en/beats/filebeat/6.8/configuration-general-options.html#shutdown-timeout"><code>shutdown_timeout</code></a> 选项将 Filebeat 配置为在关闭之前等待特定的时间。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220803115450602.png" alt="image-20220803115450602"></p><p><strong>3、确保至少一次交付</strong></p><p>由于 filebeat 可保持文件状态。</p><p>&#x3D;&#x3D;Filebeat 默认 30s 检测一次文件是否有变化。&#x3D;&#x3D;</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220803181401142.png" alt="image-20220803181401142"></p><p><strong>4、实战看看偏移量</strong></p><p>初始化完成后，会有一个文件来存储采集文件状态 <code>/data/filebeat/data/registry</code></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220803182713495.png" alt="image-20220803182713495"></p><p>此时，我新建一个 yml 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  paths:</span><br><span class="line">    - /tmp/test.log</span><br><span class="line"></span><br><span class="line">output.console:</span><br><span class="line">  pretty: true</span><br></pre></td></tr></table></figure><p>新建 <code>/tmp/test.log</code> 文件并写入数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch /tmp/test.log</span><br><span class="line">echo &quot;sdcnnwinhwwwwwwwwwwwwwwwwwwwwwwwwwwww&quot; &gt;&gt; /tmp/test.log</span><br></pre></td></tr></table></figure><p>启动 filebeat</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./filebeat -e -c conf.d/01.yml</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220803183210042.png" alt="image-20220803183210042"></p><p>查看 Filebeat 存储文件状态的文件内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /data/filebeat/data/registry</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个registry文件根据你部署的方式不同，位置也会有所不同啊，一般就在你Filebeat的数据目录下</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">看到下图，该文件存储了采集数据的源文件及偏移量（下图红框）</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220803183244080.png" alt="image-20220803183244080"></p><p>再来看看源文件自身文件大小</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件大小为53，刚好与偏移量相同，因此我们现在就很明白了，当filebeat出现故障时，它会记录下源文件的偏移量，且在恢复时从该偏移量开始读取数据并发送数据到输出（Kafka、ES），实现数据的完整性。</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220803183312130.png" alt="image-20220803183312130"></p><h4 id="4-7-3-部署及应用"><a href="#4-7-3-部署及应用" class="headerlink" title="4.7.3 部署及应用"></a>4.7.3 部署及应用</h4><p><strong>1、安装</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在要收集的日志的服务器上部署该插件</span></span><br><span class="line">tar xzf filebeat-6.8.23-linux-x86_64.tar.gz -C /data/</span><br><span class="line">mv /data/filebeat-6.8.23-linux-x86_64/ /data/filebeat</span><br></pre></td></tr></table></figure><p><strong>2、配置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /data/filebeat/</span><br><span class="line">cp filebeat.yml filebeat.yml.bak</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cat filebeat.yml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">=========================== Filebeat inputs =============================</span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  enabled: true</span><br><span class="line">  json.keys_under_root: true</span><br><span class="line">  json.add_error_key: true</span><br><span class="line">  json.message_key: log</span><br><span class="line">  paths:</span><br><span class="line">    - /data/nginx/logs/access.log</span><br><span class="line">    - /data/nginx/logs/error.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">============================= Kafka outputs =============================</span></span><br><span class="line">output.kafka:</span><br><span class="line">  enabled: true</span><br><span class="line">  hosts: [&quot;192.168.56.137:9092&quot;,&quot;192.168.56.138:9092&quot;,&quot;192.168.56.139:9092&quot;]</span><br><span class="line">  topic: filebeat_test</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">说明：paths 可以指定多个路径</span></span><br></pre></td></tr></table></figure><blockquote><p>运行 filebeat</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">前台启动</span></span><br><span class="line">/data/filebeat/filebeat -e -c filebeat.yml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后台启动</span></span><br><span class="line">nohup /data/filebeat/filebeat -e -c filebeat.yml &amp;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;Docker 方式如何部署 Filebeat ？&#x3D;&#x3D;</p><ul><li><p>创建相关目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/docker_container/</span><br></pre></td></tr></table></figure></li><li><p>运行临时容器（复制相关目录到宿主机）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp tmp:/usr/share/filebeat /data/docker_container/</span><br></pre></td></tr></table></figure></li><li><p>赋予权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 -R /data/docker_container/filebeat/</span><br></pre></td></tr></table></figure></li><li><p>删除临时容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f tmp</span><br></pre></td></tr></table></figure></li><li><p>启动新容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">普通docker中创建</span></span><br><span class="line">docker run -itd \</span><br><span class="line">  --privileged=true \</span><br><span class="line">  --restart=always \</span><br><span class="line">  --name=filebeat \</span><br><span class="line">  --hostname=filebeat \</span><br><span class="line">  -v /data/docker_container/filebeat:/usr/share/filebeat \</span><br><span class="line">  -v /data/nginx/logs:/data/nginx/logs \</span><br><span class="line">  -v /etc/localtime:/etc/localtime \</span><br><span class="line">  docker.elastic.co/beats/filebeat:6.8.23</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker swarm 集群中创建</span></span><br><span class="line">docker service create \</span><br><span class="line">  --replicas 1 \</span><br><span class="line">  --name filebeat \</span><br><span class="line">  --network my-network \</span><br><span class="line">  --hostname=&quot;filebeat&quot; \</span><br><span class="line">  --constraint &#x27;node.labels.label == filebeat1&#x27; \</span><br><span class="line">  --mount type=bind,src=/data/docker_container/filebeat,dst=/usr/share/filebeat \</span><br><span class="line">  --mount type=bind,src=/data/nginx/logs,dst=/data/nginx/logs \</span><br><span class="line">  --mount type=bind,src=/etc/localtime,dst=/etc/localtime \</span><br><span class="line">  docker.elastic.co/beats/filebeat:6.8.23</span><br><span class="line"></span><br><span class="line">docker service create \</span><br><span class="line">  --replicas 1 \</span><br><span class="line">  --name filebeat \</span><br><span class="line">  --network my-network \</span><br><span class="line">  --hostname=&quot;filebeat&quot; \</span><br><span class="line">  --constraint &#x27;node.labels.label == filebeat1&#x27; \</span><br><span class="line">  --mount type=bind,src=/data/docker_container/filebeat,dst=/usr/share/filebeat \</span><br><span class="line">  --mount type=bind,src=/data/nginx/logs,dst=/data/nginx/logs \</span><br><span class="line">  --mount type=bind,src=/etc/localtime,dst=/etc/localtime \</span><br><span class="line">  docker.elastic.co/beats/filebeat:6.8.23 \</span><br><span class="line">  filebeat -e -c /usr/share/filebeat/conf.d/nginx_logs.yml</span><br><span class="line"></span><br><span class="line">=================以下为测试，忽略即可===================</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加命令</span></span><br><span class="line">docker service create \</span><br><span class="line">  --replicas 1 \</span><br><span class="line">  --name filebeat \</span><br><span class="line">  --network my-network \</span><br><span class="line">  --hostname=&quot;filebeat&quot; \</span><br><span class="line">  --constraint &#x27;node.labels.label == filebeat1&#x27; \</span><br><span class="line">  --mount type=bind,src=/data/docker_container/filebeat,dst=/usr/share/filebeat \</span><br><span class="line">  --mount type=bind,src=/data/nginx/logs,dst=/data/nginx/logs \</span><br><span class="line">  --mount type=bind,src=/etc/localtime,dst=/etc/localtime \</span><br><span class="line">  docker.elastic.co/beats/filebeat:6.8.23 \</span><br><span class="line">  -e -c /usr/share/filebeat/conf.d/nginx_logs.yml</span><br><span class="line">  </span><br><span class="line">docker service create \</span><br><span class="line">  --replicas 1 \</span><br><span class="line">  --name filebeat2 \</span><br><span class="line">  --network my-network \</span><br><span class="line">  --hostname=&quot;filebeat&quot; \</span><br><span class="line">  --constraint &#x27;node.labels.label == filebeat2&#x27; \</span><br><span class="line">  --mount type=bind,src=/data/docker_container/filebeat,dst=/usr/share/filebeat \</span><br><span class="line">  --mount type=bind,src=/data/nginx/logs,dst=/data/nginx/logs \</span><br><span class="line">  --mount type=bind,src=/etc/localtime,dst=/etc/localtime \</span><br><span class="line">  docker.elastic.co/beats/filebeat:6.8.23 \</span><br><span class="line">  -e -c /usr/share/filebeat/conf.d/nginx_logs.yml</span><br><span class="line">  </span><br><span class="line">docker service create \</span><br><span class="line">  --replicas 1 \</span><br><span class="line">  --name filebeat \</span><br><span class="line">  --network my-network \</span><br><span class="line">  --hostname=&quot;filebeat&quot; \</span><br><span class="line">  --constraint &#x27;node.labels.label == filebeat-m&#x27; \</span><br><span class="line">  --mount type=bind,src=/data/docker_container/filebeat,dst=/usr/share/filebeat \</span><br><span class="line">  --mount type=bind,src=/data/nginx/logs,dst=/data/nginx/logs \</span><br><span class="line">  --mount type=bind,src=/etc/localtime,dst=/etc/localtime \</span><br><span class="line">  docker.elastic.co/beats/filebeat:6.8.23 \</span><br><span class="line">  -e -c /usr/share/filebeat/conf.d/nginx_logs.yml</span><br></pre></td></tr></table></figure><blockquote><p>docker swarm 集群启动服务后，报错了，错误日志显示为文件权限问题，按照提示修改即可</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service logs filebeat</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220808162208549.png" alt="image-20220808162208549"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod go-w /data/docker_container/filebeat/filebeat.yml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意：/usr/share/filebeat/filebeat.yml已经被持久化了</span></span><br></pre></td></tr></table></figure></li></ul><p>&#x3D;&#x3D;扩展：启动后 Filebeat 容器后，它执行了哪些命令？&#x3D;&#x3D;</p><ul><li><p>先看看镜像层是如何实现的？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初略的看看镜像构建过程</span></span><br><span class="line">docker history &lt;image-name:tags&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">详细看镜像构建过程</span></span><br><span class="line">docker image inspect &lt;image-name:tags&gt;</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220808181035427.png" alt="image-20220808181035427"></p></li><li><p>启动容器后，会默认执行 <code>filebeat -e</code></p><p>之所以会执行filebeat -e，是因为其镜像层中的 <code>ENTRYPOINT</code> 和 <code>CMD</code>，熟悉 Docker 的都知道，ENTRYPOINT 语句肯定会执行，如果有 CMD 参数，那 CMD 参数将会作为 ENTRYPOINT 的选项参数而执行。</p></li></ul><p><strong>3、查看 kafka 集群状态</strong></p><p>可以看到新增了一个 Topics，说明 filebeat 采集的数据成功输出到了 Kafka 集群中了。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624103042003.png" alt="image-20220624103042003"></p><p>点击进去看看是否是我们上面定义的 <code>Topic: filebeat_test</code></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624103408352.png" alt="image-20220624103408352"></p><p><strong>4、这个时候就需要消费者来消费我这条数据了</strong></p><p>从 ELK 集群架构上看，消费者是我们的 ES 集群，那 ES 集群如何消费 Kafka 集群的消息呢？答案是通过 Logstash，为什么这里还要使用 logstash？原因是其具备 <code>input ---&gt; filter ---&gt; output</code> 的流功能，当然，filebeat 可以将数据直接发送到 ES 集群。</p><ul><li><p>配置 logstash</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    kafka &#123;</span><br><span class="line">        type =&gt; &quot;filebeat_test_log&quot;</span><br><span class="line">        codec =&gt; &quot;json&quot;</span><br><span class="line">        topics =&gt; &quot;filebeat_test&quot;</span><br><span class="line">        decorate_events =&gt; true</span><br><span class="line">        bootstrap_servers =&gt; &quot;192.168.56.137:9092, 192.168.56.138:9092, 192.168.56.139:9092&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output&#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts =&gt; [&quot;192.168.56.133:9200&quot;,&quot;192.168.56.134:9200&quot;,&quot;192.168.56.135:9200&quot;]</span><br><span class="line">        user =&gt; &quot;elastic&quot;</span><br><span class="line">        password =&gt; &quot;123456&quot;</span><br><span class="line">        index =&gt; [&quot;%&#123;type&#125;-%&#123;+YYYY.MM.dd&#125;&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行 logstash</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/logstash/bin/logstash -f /data/logstash/config/conf.d/filebeat_test.conf</span><br></pre></td></tr></table></figure></li><li><p>ES 集群查看是否收到了该消息</p><blockquote><p>可看到，ES 集群已经成功消费了 Kafka 集群的消息了。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624105553521.png" alt="image-20220624105553521"></p></li><li><p>我们再去 Kibana 看看，进行相关检索</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624111301216.png" alt="image-20220624111301216"></p></li></ul><h4 id="4-7-4-调用模块"><a href="#4-7-4-调用模块" class="headerlink" title="4.7.4 调用模块"></a>4.7.4 调用模块</h4><p>内置模块路径（<code>/data/filebeat/modules.d/*.yml.disabled</code>），默认下是没开启模块的，需我们手动开启，实现方式有两种：配置文件、命令行。</p><h5 id="4-7-4-1-配置文件方式"><a href="#4-7-4-1-配置文件方式" class="headerlink" title="4.7.4.1 配置文件方式"></a>4.7.4.1 配置文件方式</h5><p>1、修改 filebeat.yml 配置文件</p><blockquote><p>新增如下内容</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filebeat.config.modules:</span><br><span class="line">  path: $&#123;path.config&#125;/modules.d/*.yml</span><br><span class="line">  reload.enabled: true</span><br><span class="line">  reload.period: 10s</span><br></pre></td></tr></table></figure><p>2、启用模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用 mysql 模块</span></span><br><span class="line">[root@kibana filebeat]# ./filebeat modules enable mysql</span><br><span class="line">Enabled mysql</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用多个模块</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[root@kibana filebeat]<span class="comment"># ./filebeat modules enable apache2 mysql</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停用模块</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./filebeat modules <span class="built_in">disable</span> apache2</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看哪些模块被启用了</span></span><br><span class="line">./filebeat modules list</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220803122353089.png" alt="image-20220803122353089"></p><blockquote><p>当启用了对应的模块时， <code>/data/filebeat/modules.d/*.yml.disabled</code> 对应的<code>*.yml.disabled</code> 也会被自动重命名为 <code>/data/filebeat/modules.d/*.yml</code></p></blockquote><p>3、修改模块文件下的配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vim /data/filebeat/modules.d/mysql.yml</span><br><span class="line">=============================================</span><br><span class="line">- module: mysql</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Error logs</span></span><br><span class="line">  error:</span><br><span class="line">    enabled: true</span><br><span class="line"></span><br><span class="line">    # Set custom paths for the log files. If left empty,</span><br><span class="line">    # Filebeat will choose the paths depending on your OS.</span><br><span class="line">    var.paths: [&quot;/var/log/mariadb/mariadb.log&quot;]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Slow logs</span></span><br><span class="line">  slowlog:</span><br><span class="line">    enabled: true</span><br><span class="line"></span><br><span class="line">    # Set custom paths for the log files. If left empty,</span><br><span class="line">    # Filebeat will choose the paths depending on your OS.</span><br><span class="line">    var.paths: [&quot;/var/log/mariadb/slow.log&quot;]</span><br></pre></td></tr></table></figure><p>4、修改 <code>filebeat.yml</code> 配置文件</p><blockquote><p>完整示例</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">案例1-【发送事件至Kafka集群】</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">=========================== Filebeat inputs =============================</span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  enabled: true</span><br><span class="line">  json.keys_under_root: true</span><br><span class="line">  json.add_error_key: true</span><br><span class="line">  json.message_key: log</span><br><span class="line">  paths:</span><br><span class="line">    - /data/nginx/logs/*.log </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">============================= Kafka outputs =============================</span></span><br><span class="line">output.kafka:</span><br><span class="line">  enabled: true</span><br><span class="line">  hosts: [&quot;192.168.56.137:9092&quot;,&quot;192.168.56.138:9092&quot;,&quot;192.168.56.139:9092&quot;]</span><br><span class="line">  topic: module-test</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">================================ modules ================================</span> </span><br><span class="line">filebeat.config.modules:</span><br><span class="line">  path: $&#123;path.config&#125;/modules.d/*.yml</span><br><span class="line">  reload.enabled: true</span><br><span class="line">  reload.period: 10s</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">案例2-【发送事件至ES集群】</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">=========================== Filebeat inputs =============================</span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  enabled: true</span><br><span class="line">  json.keys_under_root: true</span><br><span class="line">  json.add_error_key: true</span><br><span class="line">  json.message_key: log</span><br><span class="line">  paths:</span><br><span class="line">    - /data/nginx/logs/*.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">========================= elasticsearch outputs =========================</span></span><br><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [&quot;192.168.56.133:9200&quot;,&quot;192.168.56.134:9200&quot;,&quot;192.168.56.135:9200&quot;]</span><br><span class="line">  username: &quot;elastic&quot;</span><br><span class="line">  password: &quot;123456&quot;</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">================================ modules ================================</span> </span><br><span class="line">filebeat.config.modules:</span><br><span class="line">  path: $&#123;path.config&#125;/modules.d/*.yml</span><br><span class="line">  reload.enabled: true</span><br><span class="line">  reload.period: 10s</span><br></pre></td></tr></table></figure><p>5、初始化环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./filebeat setup -e</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">setup 加载模板</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-e 将标准输出输出至屏幕，而非系统日志中</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220803154710606.png" alt="image-20220803154710606"></p><p>6、运行（启动）Filebeat</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./filebeat -e</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220803154742551.png" alt="image-20220803154742551"></p><p>看看 ES 集群是否收到该数据</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220803155133839.png" alt="image-20220803155133839"></p><h5 id="4-7-4-2-命令行方式"><a href="#4-7-4-2-命令行方式" class="headerlink" title="4.7.4.2 命令行方式"></a>4.7.4.2 命令行方式</h5><p>该方式在启动 Filebeat 时直接指定</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./filebeat -e -M &quot;nginx.access.var.paths=[/data/nginx/logs/access.log]&quot; -M &quot;nginx.error.var.paths=[/data/nginx/logs/error.log]&quot;</span><br></pre></td></tr></table></figure><h4 id="4-7-5-基础用法"><a href="#4-7-5-基础用法" class="headerlink" title="4.7.5 基础用法"></a>4.7.5 基础用法</h4><blockquote><p><a href="https://www.elastic.co/guide/en/beats/filebeat/6.8/filebeat-input-log.html">官方文档实例</a></p></blockquote><h5 id="4-7-5-1-input"><a href="#4-7-5-1-input" class="headerlink" title="4.7.5.1 input"></a>4.7.5.1 input</h5><p>1、Log</p><ul><li><p>通用配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">案例1</span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  paths:</span><br><span class="line">    - /var/log/messages</span><br><span class="line">    - /var/log/*.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">案例2</span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- type: log </span><br><span class="line">  paths:</span><br><span class="line">    - /var/log/system.log</span><br><span class="line">    - /var/log/wifi.log</span><br><span class="line">- type: log </span><br><span class="line">  paths:</span><br><span class="line">    - &quot;/var/log/apache2/*&quot;</span><br><span class="line">  fields:</span><br><span class="line">    apache: true</span><br><span class="line">  fields_under_root: true</span><br></pre></td></tr></table></figure></li><li><p>配置选项</p><ul><li><p>encoding</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  encoding: plain</span><br><span class="line">  ...</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">encoding选项用于读取包含国际字符的数据的文件编码。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常见编码：plain, latin1, utf-8, utf-16be-bom, utf-16be, utf-16le, big5, gb18030, gbk, hz-gb-2312, euc-kr, euc-jp, iso-2022-jp, shift-jis ...</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">plain编码比较特殊，因为它不验证或转换任何输入。</span></span><br></pre></td></tr></table></figure></li><li><p>paths</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  paths:</span><br><span class="line">    - /var/log/*/*.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取/var/log/目录下的所有子目录下的所有以.<span class="built_in">log</span>结尾的文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">但并不会获取/var/log/目录下的日志文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果向获取/var/log/目录下的日志文件，及子目录下的文件，可使用recursive_glob参数</span></span><br></pre></td></tr></table></figure></li><li><p>exclude_lines</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  ...</span><br><span class="line">  exclude_lines: [&#x27;^DBG&#x27;]</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">表示不收集以DBG开头的行的日志信息</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认是收集所有行（空行跳过）</span></span><br></pre></td></tr></table></figure></li><li><p>include_line</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  ...</span><br><span class="line">  include_lines: [&#x27;^ERR&#x27;, &#x27;^WARN&#x27;]</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">表示只收集以ERR、WARN开头的行的日志信息</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认是收集所有行（空行跳过）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">exclude_lines与include_line结合使用</span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  ...</span><br><span class="line">  include_lines: [&#x27;sometext&#x27;]</span><br><span class="line">  exclude_lines: [&#x27;^DBG&#x27;]</span><br></pre></td></tr></table></figure></li><li><p>harvester_buffer_size</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  ...</span><br><span class="line">  harvester_buffer_size: 16384</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每个收集器在获取文件时使用的缓冲区大小（以字节为单位）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认值为 16384（16K）</span></span><br></pre></td></tr></table></figure></li><li><p>max_bytes</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  ...</span><br><span class="line">  harvester_buffer_size: 10485760</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">单个日志消息可以拥有的最大字节数。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">之后的所有字节 max_bytes都被丢弃而不发送。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此设置对于可能变得很大的多行日志消息特别有用。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认值为 10MB (10485760)。</span></span><br></pre></td></tr></table></figure></li><li><p>json</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  ...</span><br><span class="line">  json.keys_under_root: true</span><br><span class="line">  json.add_error_key: true</span><br><span class="line">  json.message_key: log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用于解码结构化为JSON的日志信息。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因此JSON解码仅在每行有一个JSON对象时该选项参数才有效。</span></span><br></pre></td></tr></table></figure></li><li><p>enabled</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  enabled: true</span><br><span class="line">  ...</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">enabled：是否启用filebeat的input功能（默认是<span class="literal">true</span>）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果设置为<span class="literal">false</span>，将采集不到日志（因为input已经被关闭）</span></span><br></pre></td></tr></table></figure></li><li><p>tags</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  . . .</span><br><span class="line">  tags: [&quot;json&quot;,&quot;...&quot;]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可在每个事件类型中定义标签（可定义多个）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">便于后期做过滤相关操作</span></span><br></pre></td></tr></table></figure></li><li><p>fields</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  . . .</span><br><span class="line">  fields:</span><br><span class="line">    app_id: query_engine_12</span><br><span class="line">    new_name: rab</span><br><span class="line">  fields_under_root: true</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用于向输出添加附加信息的可选字段（自定义），可定义多个</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">字段可以是标量值、数组、字典或这些的任何嵌套组合，默认为字典</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果fields_under_root选项设置为 <span class="literal">true</span>，则自定义 字段将作为顶级字段存储在输出文档中</span></span><br></pre></td></tr></table></figure><blockquote><p>如下图，上面定义的标签（tags）和字段（fields），会在 Kibana 展现</p><p>打问号的字段就是我们自定义的，其他字段为默认字段。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220804161155427.png" alt="image-20220804161155427"></p></li></ul></li></ul><p>2、Stdin</p><blockquote><p>与 log 一样，就是类型不一样而已。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: stdin</span><br><span class="line">  paths:</span><br><span class="line">    - /var/log/*/*.log</span><br></pre></td></tr></table></figure><p>3、Redis</p><ul><li><p>通用配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: redis</span><br><span class="line">  hosts: [&quot;localhost:6379&quot;]</span><br><span class="line">  password: &quot;$&#123;redis_pwd&#125;&quot;</span><br></pre></td></tr></table></figure></li><li><p>配置选项</p><ul><li><p>scan_frequency</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: redis</span><br><span class="line">  hosts: [&quot;localhost:6379&quot;]</span><br><span class="line">  password: &quot;$&#123;redis_pwd&#125;&quot;</span><br><span class="line">  scan_frequency: 5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Filebeat 从 Redis 慢日志中读取条目的频率。指定1s尽可能频繁地扫描 Redis，而不会导致 Filebeat 扫描过于频繁。不要将此值设置为小于1s</span></span><br></pre></td></tr></table></figure></li><li><p>maxconn</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: redis</span><br><span class="line">  hosts: [&quot;localhost:6379&quot;]</span><br><span class="line">  password: &quot;$&#123;redis_pwd&#125;&quot;</span><br><span class="line">  maxconn: 10</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最大并发连接，默认为10</span></span><br></pre></td></tr></table></figure></li><li><p>其他选项与上面类似</p></li></ul></li></ul><p>4、Docker</p><ul><li><p>通用配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: docker</span><br><span class="line">  containers.ids: </span><br><span class="line">    - &#x27;8b6fe7dc9e067b58476dc57d6986dd96d7100430c5de3b109a99cd56ac655347&#x27;</span><br></pre></td></tr></table></figure></li><li><p>配置选项</p><ul><li><p>containers.ids</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: docker</span><br><span class="line">  containers.ids: </span><br><span class="line">    - &#x27;*&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">容器ID</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&#x27;*&#x27;</span> 表示所有容器</span></span><br></pre></td></tr></table></figure></li><li><p>containers.path</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: docker</span><br><span class="line">  containers.ids: </span><br><span class="line">    - &#x27;*&#x27;</span><br><span class="line">  containers.path:</span><br><span class="line">    - /var/lib/docker/containers</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">容器所在路径</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>5、具体实例</p><p><font color=Crimson><strong>情况一：Java 堆栈日志类型，如何搜集？</strong></font></p><blockquote><p>Java 堆栈跟踪由多行组成，初始行之后的每一行都以空格开头。</p></blockquote><ul><li><p>日志类型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalStateException: A book has a null property</span><br><span class="line">       at com.example.myproject.Author.getBookIds(Author.java:38)</span><br><span class="line">       at com.example.myproject.Bootstrap.main(Bootstrap.java:14)</span><br><span class="line">Caused by: java.lang.NullPointerException</span><br><span class="line">       at com.example.myproject.Book.getId(Book.java:22)</span><br><span class="line">       at com.example.myproject.Author.getBookIds(Author.java:35)</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">....</span><br></pre></td></tr></table></figure></li><li><p>Filebeat 配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">情形1---默认输出</span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  multiline.pattern: &#x27;^[[:space:]]&#x27;</span><br><span class="line">  multiline.negate: false</span><br><span class="line">  multiline.match: after</span><br><span class="line">  paths:</span><br><span class="line">    - /tmp/test.log</span><br><span class="line">  tags: [&quot;multiline-01&quot;]</span><br><span class="line">  fields:</span><br><span class="line">    app_id: muil_12</span><br><span class="line">    new_name: rab</span><br><span class="line">  fields_under_root: true</span><br><span class="line">  </span><br><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [&quot;192.168.56.133:9200&quot;,&quot;192.168.56.134:9200&quot;,&quot;192.168.56.135:9200&quot;]</span><br><span class="line">  username: &quot;elastic&quot;</span><br><span class="line">  password: &quot;123456&quot;</span><br><span class="line">  index: &quot;multiline-%&#123;+yyyy.MM.dd&#125;&quot;</span><br><span class="line">setup.template.name: &quot;filebeattest&quot;</span><br><span class="line">setup.template.pattern: &quot;filebeattest-*&quot;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">情形2---自定义某部分内容为一个filebeat事件来输出</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">条件限制：要同时满足</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.匹配以空格开头的行，且在空格后紧跟at关键字或者...关键字符串</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.匹配以Caused by开头的行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这1、2条件合为一个整体进行输出，也就是每次日志内容新增都是以特定的格式输出</span></span><br><span class="line"></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  multiline.pattern: &#x27;^[[:space:]]+(at|\.&#123;3&#125;)\b|^Caused by:&#x27;</span><br><span class="line">  multiline.negate: false</span><br><span class="line">  multiline.match: after</span><br><span class="line">  paths:</span><br><span class="line">    - /tmp/test.log</span><br><span class="line">  tags: [&quot;multiline-01&quot;]</span><br><span class="line">  fields:</span><br><span class="line">    app_id: muil_12</span><br><span class="line">    new_name: rab</span><br><span class="line">  fields_under_root: true</span><br><span class="line"></span><br><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [&quot;192.168.56.133:9200&quot;,&quot;192.168.56.134:9200&quot;,&quot;192.168.56.135:9200&quot;]</span><br><span class="line">  username: &quot;elastic&quot;</span><br><span class="line">  password: &quot;123456&quot;</span><br><span class="line">  index: &quot;multiline-%&#123;+yyyy.MM.dd&#125;&quot;</span><br><span class="line">setup.template.name: &quot;filebeattest&quot;</span><br><span class="line">setup.template.pattern: &quot;filebeattest-*&quot;</span><br></pre></td></tr></table></figure><p><strong>multiline的作用就是将某些格式化数据以一个完整filebeat事件进行输出至输出目标</strong></p><ul><li>情形1：如果没有过多的条件限制，只要日志文件按照特定的格式有新内容，它就会采集一条数据并作为一个filebeat事件输出</li><li>情形2：如果做了条件限制，如图2，我限制了它们为一个整体来输出，只要新来了一条数据，就会按指定的规则来输出</li></ul></li><li><p>Kibana 数据展示</p><ul><li><p>情形1 截图</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220804165030462.png" alt="image-20220804165030462"></p></li><li><p>情形2 截图</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220804162913904.png" alt="image-20220804162913904"></p></li><li><p>其他情况</p><p>而如果 Java 日志格式不统一，那 filebeat 规则就不生效了，如下又新增了一条内容（&#x3D;&#x3D;但一般不会出现这种情况&#x3D;&#x3D;）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalStateException: A book has a null property</span><br><span class="line">       at com.example.myproject.Author.getBookIds(Author.java:38)</span><br><span class="line">       at com.example.myproject.Bootstrap.main(Bootstrap.java:14)</span><br><span class="line">Caused by: java.lang.NullPointerException</span><br><span class="line">       at com.example.myproject.Book.getId(Book.java:22)</span><br><span class="line">       at com.example.myproject.Author.getBookIds(Author.java:35)</span><br><span class="line">Caused test: java.lang.NullPointerException</span><br><span class="line">       aa com.example.myproject.Book.getId(Book.java:22)</span><br><span class="line">       aa com.example.myproject.Author.getBookIds(Author.java:35)</span><br></pre></td></tr></table></figure><blockquote><p>Kibana 数据展示：再看看 Kibana 数据展示，按filebeat定义的规则来看，收集到的数据并不完整。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220804163755203.png" alt="image-20220804163755203"></p></li></ul></li></ul><p><font color=Crimson><strong>情况二：带时间戳的 Java 应用日志格式，如何收集？</strong></font></p><blockquote><p>以测试环境 checkcheck 项目举例，下面就是一种典型的时间戳的日志格式。</p></blockquote><ul><li><p>日志类型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">2022-08-04 08:14:46.660 [schedule-1-t-10] ERROR com.kys.redis.gatehash.GateHashManager - 订阅HashCode最后活跃时间656已经大于限制600秒,取消订阅，重新订阅</span><br><span class="line">2022-08-04 08:24:46.661 [schedule-1-t-7] ERROR com.kys.redis.gatehash.GateHashManager - 订阅HashCode最后活跃时间1256已经大于限制600秒,取消订阅，重新订阅</span><br><span class="line">2022-08-04 08:54:46.661 [schedule-1-t-3] ERROR com.kys.redis.gatehash.GateHashManager - 订阅HashCode最后活跃时间937已经大于限制600秒,取消订阅，重新订阅</span><br><span class="line">2022-08-04 09:14:46.662 [schedule-1-t-10] ERROR com.kys.redis.gatehash.GateHashManager - 订阅HashCode最后活跃时间865已经大于限制600秒,取消订阅，重新订阅</span><br><span class="line">2022-08-04 09:24:46.662 [schedule-1-t-8] ERROR com.kys.redis.gatehash.GateHashManager - 订阅HashCode最后活跃时间1465已经大于限制600秒,取消订阅，重新订阅</span><br><span class="line">2022-08-04 09:34:46.663 [schedule-1-t-1] ERROR com.kys.redis.gatehash.GateHashManager - 订阅HashCode最后活跃时间2065已经大于限制600秒,取消订阅，重新订阅</span><br><span class="line">2022-08-04 09:44:46.663 [schedule-1-t-5] ERROR com.kys.redis.gatehash.GateHashManager - 订阅HashCode最后活跃时间2665已经大于限制600秒,取消订阅，重新订阅</span><br><span class="line">2022-08-04 09:54:46.663 [schedule-1-t-6] ERROR com.kys.redis.gatehash.GateHashManager - 订阅HashCode最后活跃时间3265已经大于限制600秒,取消订阅，重新订阅</span><br><span class="line">2022-08-04 10:04:46.664 [schedule-1-t-7] ERROR com.kys.redis.gatehash.GateHashManager - 订阅HashCode最后活跃时间3865已经大于限制600秒,取消订阅，重新订阅</span><br><span class="line">2022-08-04 10:14:46.664 [schedule-1-t-8] ERROR com.kys.redis.gatehash.GateHashManager - 订阅HashCode最后活跃时间4465已经大于限制600秒,取消订阅，重新订阅</span><br><span class="line">2022-08-04 10:24:46.665 [schedule-1-t-1] ERROR com.kys.redis.gatehash.GateHashManager - 订阅HashCode最后活跃时间5065已经大于限制600秒,取消订阅，重新订阅</span><br><span class="line">2022-08-04 10:34:46.665 [schedule-1-t-2] ERROR com.kys.redis.gatehash.GateHashManager - 订阅HashCode最后活跃时间5665已经大于限制600秒,取消订阅，重新订阅</span><br><span class="line">2022-08-04 10:44:46.665 [schedule-1-t-6] ERROR com.kys.redis.gatehash.GateHashManager - 订阅HashCode最后活跃时间6265已经大于限制600秒,取消订阅，重新订阅</span><br><span class="line">2022-08-04 10:54:46.666 [schedule-1-t-9] ERROR com.kys.redis.gatehash.GateHashManager - 订阅HashCode最后活跃时间6865已经大于限制600秒,取消订阅，重新订阅</span><br><span class="line">2022-08-04 11:04:46.666 [schedule-1-t-4] ERROR com.kys.redis.gatehash.GateHashManager - 订阅HashCode最后活跃时间7465已经大于限制600秒,取消订阅，重新订阅</span><br><span class="line">2022-08-04 11:14:46.666 [schedule-1-t-5] ERROR com.kys.redis.gatehash.GateHashManager - 订阅HashCode最后活跃时间8065已经大于限制600秒,取消订阅，重新订阅</span><br><span class="line">2022-08-04 11:24:46.667 [schedule-1-t-2] ERROR com.kys.redis.gatehash.GateHashManager - 订阅HashCode最后活跃时间8665已经大于限制600秒,取消订阅，重新订阅</span><br><span class="line">2022-08-04 11:34:46.667 [schedule-1-t-3] ERROR com.kys.redis.gatehash.GateHashManager - 订阅HashCode最后活跃时间9265已经大于限制600秒,取消订阅，重新订阅</span><br><span class="line">2022-08-04 11:44:46.667 [schedule-1-t-1] ERROR com.kys.redis.gatehash.GateHashManager - 订阅HashCode最后活跃时间9865已经大于限制600秒,取消订阅，重新订阅</span><br><span class="line">2022-08-04 11:54:46.668 [schedule-1-t-3] ERROR com.kys.redis.gatehash.GateHashManager - 订阅HashCode最后活跃时间10465已经大于限制600秒,取消订阅，重新订阅</span><br><span class="line">2022-08-04 12:04:46.668 [schedule-1-t-4] ERROR com.kys.redis.gatehash.GateHashManager - 订阅HashCode最后活跃时间11065已经大于限制600秒,取消订阅，重新订阅</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>Filebeat 配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  multiline.pattern: &#x27;^\[[0-9]&#123;4&#125;-[0-9]&#123;2&#125;-[0-9]&#123;2&#125;&#x27;</span><br><span class="line">  multiline.negate: true</span><br><span class="line">  multiline.match: after</span><br><span class="line">  paths:</span><br><span class="line">    - /tmp/test.log</span><br><span class="line">  tags: [&quot;multiline-01&quot;]</span><br><span class="line">  fields:</span><br><span class="line">    app_id: muil_12</span><br><span class="line">    new_name: rab</span><br><span class="line">  fields_under_root: true</span><br><span class="line"></span><br><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [&quot;192.168.56.133:9200&quot;,&quot;192.168.56.134:9200&quot;,&quot;192.168.56.135:9200&quot;]</span><br><span class="line">  username: &quot;elastic&quot;</span><br><span class="line">  password: &quot;123456&quot;</span><br><span class="line">  index: &quot;multiline-%&#123;+yyyy.MM.dd&#125;&quot;</span><br><span class="line">setup.template.name: &quot;filebeattest&quot;</span><br><span class="line">setup.template.pattern: &quot;filebeattest-*&quot;</span><br></pre></td></tr></table></figure></li><li><p>Kibana 数据展示</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220804172634632.png" alt="image-20220804172634632"></p></li></ul><p><font color=Crimson><strong>扩展</strong></font>：如果匹配不到 filebeat 规则的数据，将如何处理？</p><blockquote><p>在<code>情况一</code>中有出现数据不完整的去情况，那间如何处理？解决方案就是设置参数：</p><ul><li><code>multiline.negate: true</code> </li><li><code>multiline.match: after</code></li></ul></blockquote><ul><li><p>filebeat 配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  multiline.pattern: &#x27;^[[:space:]]+(at|\.&#123;3&#125;)\b|^Caused by:&#x27;</span><br><span class="line">  multiline.negate: true</span><br><span class="line">  multiline.match: after</span><br><span class="line">  paths:</span><br><span class="line">    - /tmp/test.log</span><br><span class="line">  tags: [&quot;multiline-01&quot;]</span><br><span class="line">  fields:</span><br><span class="line">    app_id: muil_12</span><br><span class="line">    new_name: rab</span><br><span class="line">  fields_under_root: true</span><br><span class="line"></span><br><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [&quot;192.168.56.133:9200&quot;,&quot;192.168.56.134:9200&quot;,&quot;192.168.56.135:9200&quot;]</span><br><span class="line">  username: &quot;elastic&quot;</span><br><span class="line">  password: &quot;123456&quot;</span><br><span class="line">  index: &quot;multiline-%&#123;+yyyy.MM.dd&#125;&quot;</span><br><span class="line">setup.template.name: &quot;filebeattest&quot;</span><br><span class="line">setup.template.pattern: &quot;filebeattest-*&quot;</span><br></pre></td></tr></table></figure></li><li><p>日志示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalStateException: A book has a null property</span><br><span class="line">       at com.example.myproject.Author.getBookIds(Author.java:38)</span><br><span class="line">       at com.example.myproject.Bootstrap.main(Bootstrap.java:14)</span><br><span class="line">wtttwww sss dcsdccdc.csdcs.dscs.dc</span><br><span class="line">       cc sdc.cocsdc.csss(Book.java:36)</span><br><span class="line">       dd sdcs.grtr.ytu.pklm(Author.java:12)</span><br><span class="line">Caused by: java.lang.NullPointerException</span><br><span class="line">       at com.example.myproject.Book.getId(Book.java:22)</span><br><span class="line">       at com.example.myproject.Author.getBookIds(Author.java:35)</span><br></pre></td></tr></table></figure></li><li><p>Kibana 数据展示</p><p>数据展示失败—-与预期不符（后面再研究）</p></li></ul><p>&#x3D;&#x3D;小结：通过以上案例你就可以发现，multiline 的作用无非就是一次输出与 filebeat 规则匹配的日志格式，类似于并发输出了，为什么这样说呢？默认的输出方式是来一条数据就输出一条（在filebeat采集时间内），而 multiline 也满足来一条数据就输出一条（在filebeat采集时间内），但如果在 filebeat 采集时间内匹配到了规则指定的数据，那就会作为单个事件一次性输出。&#x3D;&#x3D;</p><p><font color=Crimson><strong>情况三：日志格式有自定义的字段，如何收集？</strong></font></p><blockquote><p>有这么一种情况，也是在测试&#x2F;生产环境中常见的，由于某些特殊情况，开发一般会在日志中做相关的标记，比如起始事件的标识符。那我们如何每次截取开发指定的这段日志数据呢？</p></blockquote><ul><li><p>filebeat 配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  multiline.pattern: &#x27;Start new event&#x27;</span><br><span class="line">  multiline.negate: true</span><br><span class="line">  multiline.match: after</span><br><span class="line">  multiline.flush_pattern: &#x27;End event&#x27;</span><br><span class="line">  paths:</span><br><span class="line">    - /tmp/test.log</span><br><span class="line">  tags: [&quot;multiline-01&quot;]</span><br><span class="line">  fields:</span><br><span class="line">    app_id: muil_12</span><br><span class="line">    new_name: rab</span><br><span class="line">  fields_under_root: true</span><br><span class="line"></span><br><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [&quot;192.168.56.133:9200&quot;,&quot;192.168.56.134:9200&quot;,&quot;192.168.56.135:9200&quot;]</span><br><span class="line">  username: &quot;elastic&quot;</span><br><span class="line">  password: &quot;123456&quot;</span><br><span class="line">  index: &quot;multiline-%&#123;+yyyy.MM.dd&#125;&quot;</span><br><span class="line">setup.template.name: &quot;filebeattest&quot;</span><br><span class="line">setup.template.pattern: &quot;filebeattest-*&quot;</span><br></pre></td></tr></table></figure></li><li><p>日志示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[2015-08-24 11:49:14,389] Start new event</span><br><span class="line">[2015-08-24 11:49:14,395] Content of processing something</span><br><span class="line">[2015-08-24 11:49:14,399] End event</span><br></pre></td></tr></table></figure></li><li><p>Kibana 数据展示</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220804180429618.png" alt="image-20220804180429618"></p></li></ul><h5 id="4-7-5-2-output"><a href="#4-7-5-2-output" class="headerlink" title="4.7.5.2 output"></a>4.7.5.2 output</h5><blockquote><p>更多 output 请看<a href="https://www.elastic.co/guide/en/beats/filebeat/6.8/configuring-output.html">《官方文档》</a>，以下仅列出了常用的几种。</p></blockquote><p>1、Elasticsearch</p><ul><li><p>基本格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [&quot;ES_IP:9200&quot;, &quot;ES_IP:9200&quot;, &quot;ES_IP:9200&quot;, ...]</span><br><span class="line">  protocol: &quot;http&quot;</span><br><span class="line">  username: &quot;&#123;beatname_lc&#125;_internal&quot;</span><br><span class="line">  password: &quot;&#123;pwd&#125;&quot;</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hosts：ES集群主机IP，可以定义为URL或IP:PORT</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">protocol：ES协议，默认http协议，如果你的ES加密，则使用https</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">username：ES用户名</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">password：ES密码</span></span><br></pre></td></tr></table></figure></li><li><p>定义输出到 ES 集群的索引</p><ul><li><p>基本索引定义格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [&quot;http://localhost:9200&quot;]</span><br><span class="line">  index: &quot;%&#123;[fields.log_type]&#125;-%&#123;[beat.version]&#125;-%&#123;+yyyy.MM.dd&#125;&quot; </span><br></pre></td></tr></table></figure></li><li><p>带有条件的索引格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [&quot;http://localhost:9200&quot;]</span><br><span class="line">  indices:</span><br><span class="line">    - index: &quot;warning-%&#123;[beat.version]&#125;-%&#123;+yyyy.MM.dd&#125;&quot;</span><br><span class="line">      when.contains:</span><br><span class="line">        message: &quot;WARN&quot;</span><br><span class="line">    - index: &quot;error-%&#123;[beat.version]&#125;-%&#123;+yyyy.MM.dd&#125;&quot;</span><br><span class="line">      when.contains:</span><br><span class="line">        message: &quot;ERR&quot;</span><br><span class="line">        </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">indices：定义一组索引选择器规则</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如何选择？当filebeat传入的日志数据内容中包含WARN关键字，则选择warning-%&#123;[beat.version]&#125;-%&#123;+yyyy.MM.<span class="built_in">dd</span>&#125;作为ES索引；当filebeat传入的日志数据内容中包含ERR关键字，则选择error-%&#123;[beat.version]&#125;-%&#123;+yyyy.MM.<span class="built_in">dd</span>&#125;作为ES索引</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>2、Logstash</p><p><code>Filebeat</code> 将事件发送到 <code>Logstash</code> 是基于 TCP 协议来实现，相比于 <code>Filebeat</code> 直接将数据输出到 ES 集群而言，<code>Logstash</code> 允许对生成的事件进行<code>额外处理和路由</code></p><p>3、Kafka</p><h4 id="4-7-6-Filebeat-ES"><a href="#4-7-6-Filebeat-ES" class="headerlink" title="4.7.6 Filebeat + ES"></a>4.7.6 Filebeat + ES</h4><blockquote><p>本次以 Docker Swarm 集群服务日志为搜集目标。</p></blockquote><h5 id="4-7-6-1-Nginx"><a href="#4-7-6-1-Nginx" class="headerlink" title="4.7.6.1 Nginx"></a>4.7.6.1 Nginx</h5><blockquote><p>先看看日志格式：可以是JSON格式，也可以是任意格式。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220805173132226.png" alt="image-20220805173132226"></p><p>1、Docker Swarm 集群启用 Nginx 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">  --replicas 2 \</span><br><span class="line">  --name my-web \</span><br><span class="line">  --network my-network \</span><br><span class="line">  --publish published=8080,target=80 \</span><br><span class="line">  --hostname=&quot;my-nginx&quot; \</span><br><span class="line">  --mount type=bind,src=/data/nginx/conf/nginx.conf,dst=/etc/nginx/nginx.conf \</span><br><span class="line">  --mount type=bind,src=/data/nginx/conf/conf.d,dst=/etc/nginx/conf.d \</span><br><span class="line">  --mount type=bind,src=/data/nginx/html,dst=/usr/share/nginx/html \</span><br><span class="line">  --mount type=bind,src=/data/nginx/logs,dst=/var/log/nginx \</span><br><span class="line">  nginx:1.20.2</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220805152246800.png" alt="image-20220805152246800"></p><blockquote><p>因为 Docker Swarm 集群自身调度算法，每次的滚动升级（扩容&#x2F;缩容）都可能导致服务被调度到不同的 work 节点上，所以每个节点我们也同样配置相同的 Filebeat，这样不管你的服务被调度到哪个工作节点那都没关系，只要确保输出到 ES 的索引保持一致即可，因为在 Kibana 展示的时候就是就是通过 ES 存储的索引来展示数据的。</p></blockquote><p>2、Filebeat 配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@kibana filebeat]# cat conf.d/nginx_logs.yml </span><br><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  paths:</span><br><span class="line">    - /data/nginx/logs/access.log</span><br><span class="line">    - /data/nginx/logs/error.log</span><br><span class="line">  tags: [&quot;nginx-01&quot;]</span><br><span class="line">  fields:</span><br><span class="line">    log_type: nginx_all_logs</span><br><span class="line">  fields_under_root: true</span><br><span class="line"></span><br><span class="line">setup.template.name: &quot;filebeattest&quot;</span><br><span class="line">setup.template.pattern: &quot;filebeattest-*&quot;</span><br><span class="line"></span><br><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [&quot;192.168.56.133:9200&quot;,&quot;192.168.56.134:9200&quot;,&quot;192.168.56.135:9200&quot;]</span><br><span class="line">  username: &quot;elastic&quot;</span><br><span class="line">  password: &quot;123456&quot;</span><br><span class="line">  index: &quot;nginx_all_logs-%&#123;+yyyy.MM.dd&#125;&quot;</span><br></pre></td></tr></table></figure><p>3、启动 filebeat</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./filebeat -e -c conf.d/nginx_logs.yml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">说明</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-e：信息输出至屏幕终端</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-c：指定配置文件（如果你修改默认的配置文件名及路径，可以不指定）</span></span><br></pre></td></tr></table></figure><p>4、ES 简单查看验证</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220805155313793.png" alt="image-20220805155313793"></p><p>5、Kibana 创建索引并查看具体信息</p><blockquote><p>Nginx 每访问一次，Kibana 就会输出一次内容。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220805155434344.png" alt="image-20220805155434344"></p><p>&#x3D;&#x3D;更多过滤方法，请看第5节《Kibana 基础操作》&#x3D;&#x3D;</p><p>如果此时我故意将 <code>docker_swarm_work2</code> 节点上运行的 nginx 服务的配置文件做改动（写一个错误的语法），那 <code>nginx</code> 服务将是无法启动的，但是根据 Docker Swarm 的调度算法原理，会根据你 master 节点启动服务时指定的的服务副本数，从而再次启动相应的容器服务。</p><ul><li><p>Nginx 配置</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220805171644827.png" alt="image-20220805171644827"></p></li><li><p>查看 Docker Swarm</p><blockquote><p>可看到，原本 work2 上的节点服务，由于启动失败，但要保持集群指定的服务数，Docker Swarm 集群会再次启动一个服务，可看到该服务已经运行在了 work1 节点上了。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220805170249243.png" alt="image-20220805170249243"></p></li><li><p>此时再来看看 Kibana的数据</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220805172249044.png" alt="image-20220805172249044"></p></li></ul><p>&#x3D;&#x3D;6、扩展&#x3D;&#x3D;</p><p>在 <code>filebeat</code> 输出到 ES 前，我们可以做相关的过滤操作，现将上面的例子进一步优化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  paths:</span><br><span class="line">    - /data/nginx/logs/access.log</span><br><span class="line">    - /data/nginx/logs/error.log</span><br><span class="line">  tags: [&quot;nginx-01&quot;]</span><br><span class="line">  fields:</span><br><span class="line">    log_type: nginx_all_logs</span><br><span class="line">  fields_under_root: true</span><br><span class="line"></span><br><span class="line">setup.template.name: &quot;filebeattest&quot;</span><br><span class="line">setup.template.pattern: &quot;filebeattest-*&quot;</span><br><span class="line"></span><br><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [&quot;192.168.56.133:9200&quot;,&quot;192.168.56.134:9200&quot;,&quot;192.168.56.135:9200&quot;]</span><br><span class="line">  username: &quot;elastic&quot;</span><br><span class="line">  password: &quot;123456&quot;</span><br><span class="line">  indices:</span><br><span class="line">    - index: &quot;rab-access-%&#123;+yyyy.MM.dd&#125;&quot;</span><br><span class="line">      when.contains:</span><br><span class="line">        message: &quot;Mozilla&quot;</span><br><span class="line">    - index: &quot;rab-error-%&#123;+yyyy.MM.dd&#125;&quot;</span><br><span class="line">      when.contains:</span><br><span class="line">        message: &quot;error&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">说明</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">indices：索引过滤条件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">when.contains：当包日志内容含error信息时，数据索引为rab-error-%&#123;+yyyy.MM.<span class="built_in">dd</span>&#125;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不定义过滤的when条件，则默认采集所有数据（访问和错误都会采集），比如indices:下可有多个index，但如果我的index不加when条件，那就默认收集所有日志数据</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当indices:下都有过滤条件，但是根据你提供的path日志内容你无法匹配到你定义的关键字，那将会以more索引filebeat-&#123;&#123;version&#125;&#125;-&#123;YYYYmmdd&#125;来输出</span></span><br></pre></td></tr></table></figure><ul><li><p>正常访问的情况，看看 ES 索引</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220805180402674.png" alt="image-20220805180402674"></p></li><li><p>异常访问时，看看 ES 索引</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220805182845157.png" alt="image-20220805182845157"></p></li><li><p>看看 Kibana 日志</p><blockquote><p>我在 Nginx 访问页面刷新了两次</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220805183102712.png" alt="image-20220805183102712"></p></li><li><p>还可以继续优化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  paths:</span><br><span class="line">    - /data/nginx/logs/access.log</span><br><span class="line">    - /data/nginx/logs/error.log</span><br><span class="line">  tags: [&quot;nginx-01&quot;]</span><br><span class="line">  fields:</span><br><span class="line">    log_type: nginx_all_logs</span><br><span class="line">  fields_under_root: true</span><br><span class="line">  </span><br><span class="line">- type: log</span><br><span class="line">  paths:</span><br><span class="line">    - /data/nginx/logs/access.log</span><br><span class="line">    - /data/nginx/logs/error.log</span><br><span class="line">  tags: [&quot;nginx-01&quot;]</span><br><span class="line">  fields:</span><br><span class="line">    log_type: nginx_all_logs</span><br><span class="line">  fields_under_root: true</span><br><span class="line"></span><br><span class="line">setup.template.name: &quot;filebeattest&quot;</span><br><span class="line">setup.template.pattern: &quot;filebeattest-*&quot;</span><br><span class="line"></span><br><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [&quot;192.168.56.133:9200&quot;,&quot;192.168.56.134:9200&quot;,&quot;192.168.56.135:9200&quot;]</span><br><span class="line">  username: &quot;elastic&quot;</span><br><span class="line">  password: &quot;123456&quot;</span><br><span class="line">  indices:</span><br><span class="line">    - index: &quot;rab-access-%&#123;+yyyy.MM.dd&#125;&quot;</span><br><span class="line">      when.contains:</span><br><span class="line">        message: &quot;Mozilla&quot;</span><br><span class="line">    - index: &quot;rab-error-%&#123;+yyyy.MM.dd&#125;&quot;</span><br><span class="line">      when.contains:</span><br><span class="line">        message: &quot;error&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">说明</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">indices：索引过滤条件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">when.contains：当包日志内容含error信息时，数据索引为rab-error-%&#123;+yyyy.MM.<span class="built_in">dd</span>&#125;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不定义过滤的when条件，则默认采集所有数据（访问和错误都会采集），比如indices:下可有多个index，但如果我的index不加when条件，那就默认收集所有日志数据</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当indices:下都有过滤条件，但是根据你提供的path日志内容你无法匹配到你定义的关键字，那将会以more索引filebeat-&#123;&#123;version&#125;&#125;-&#123;YYYYmmdd&#125;来输出</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">详情如下：</span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  enabled: true</span><br><span class="line">  paths:</span><br><span class="line">    - /data/nginx/logs/*.log</span><br><span class="line">  scan_frequency: 10s</span><br><span class="line">  tail_files: true</span><br><span class="line">  fields:</span><br><span class="line">    index_name: &quot;nginx_log&quot;</span><br><span class="line">- type: log</span><br><span class="line">  enabled: true</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">不以[开头的行都合并到上一行的末尾</span></span><br><span class="line">  multiline.type: pattern</span><br><span class="line">  multiline.pattern: &#x27;^[[:space:]]+(at|\.&#123;3&#125;)[[:space:]]+\b|^Caused by:&#x27;</span><br><span class="line">  multiline.negate: false</span><br><span class="line">  multiline.match: after</span><br><span class="line">  paths:</span><br><span class="line">    - /var/log/log4j/*.log</span><br><span class="line">  fields:</span><br><span class="line">    index_name: &quot;log4j_log&quot;</span><br><span class="line">- type: log</span><br><span class="line">  enabled: true</span><br><span class="line">  multiline.type: pattern</span><br><span class="line">  multiline.pattern: &#x27;^[[:space:]]+(at|\.&#123;3&#125;)[[:space:]]+\b|^Caused by:&#x27;</span><br><span class="line">  multiline.negate: false</span><br><span class="line">  multiline.match: after</span><br><span class="line">  fields:</span><br><span class="line">    index_name: &quot;biz_log&quot;</span><br><span class="line">  scan_frequency: 10s</span><br><span class="line">  pipeline: &quot;extract-traceid-pipeline&quot;</span><br><span class="line">  paths:</span><br><span class="line">    - /var/log/biz/*.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># # 7.x的版本中需要禁用此索引生命周期，否则在指定es索引名字的时候会有问题</span></span></span><br><span class="line">setup.ilm.enabled: false</span><br><span class="line">setup.template.name: &quot;my-log&quot;</span><br><span class="line">setup.template.pattern: &quot;my-*&quot;</span><br><span class="line">setup.template.enabled: true</span><br><span class="line">setup.template.overwrite: false</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出到es</span></span><br><span class="line">output.elasticsearch:</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">worker: 1</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">bulk_max_size: 1500</span></span><br><span class="line">  hosts: [&quot;elasticsearch1:9200&quot;]</span><br><span class="line">  index: &quot;pb-%&#123;[fields.index_name]&#125;-*&quot;</span><br><span class="line">  indices:</span><br><span class="line">    - index: &quot;pb-nginx-%&#123;+yyyy.MM.dd&#125;&quot;</span><br><span class="line">      when.equals:</span><br><span class="line">        fields.index_name: &quot;nginx_log&quot;</span><br><span class="line">    - index: &quot;pb-log4j-%&#123;+yyyy.MM.dd&#125;&quot;</span><br><span class="line">      when.equals:</span><br><span class="line">        fields.index_name: &quot;log4j_log&quot;</span><br><span class="line">    - index: &quot;pb-biz-%&#123;+yyyy.MM.dd&#125;&quot;</span><br><span class="line">      when.equals:</span><br><span class="line">        fields.index_name: &quot;biz_log&quot;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;以上就是一些基础优化，参考即可。&#x3D;&#x3D;</p></li></ul><h5 id="4-7-6-2-Java"><a href="#4-7-6-2-Java" class="headerlink" title="4.7.6.2 Java"></a>4.7.6.2 Java</h5><blockquote><p>具体案例可看 <code>4.7.5.1</code> 部分，分别对应了不同的日志格式分析。</p></blockquote><h3 id="4-8-Filebeat-Logstash-ES"><a href="#4-8-Filebeat-Logstash-ES" class="headerlink" title="4.8 Filebeat + Logstash + ES"></a>4.8 Filebeat + Logstash + ES</h3><p>关于 <code>Filebeat + ES</code> 的案例，请看 <code>4.7.6</code> 部分。</p><p>先看看 Logstash 的流过程：</p><ol><li>先确定数据源（可以是常规日志、Filebeat输出、Kafka集群）</li><li>Filters 数据过滤</li><li>输出到 ES 集群</li><li>Kibana 数据展示</li></ol><p><img src="https://www.elastic.co/guide/en/logstash/6.8/static/images/basic_logstash_pipeline.png" alt="basic logstash pipeline"></p><h4 id="4-8-1-Filebeat-数据采集"><a href="#4-8-1-Filebeat-数据采集" class="headerlink" title="4.8.1 Filebeat 数据采集"></a>4.8.1 Filebeat 数据采集</h4><blockquote><p>首先确定数据源我们使用 <code>filebeat</code> 来做数据采集。</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs<span class="punctuation">:</span></span><br><span class="line">- type<span class="punctuation">:</span> log</span><br><span class="line">  paths<span class="punctuation">:</span></span><br><span class="line">    - /data/nginx/logs/access.log</span><br><span class="line">    - /data/nginx/logs/error.log</span><br><span class="line">  tags<span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;nginx-02&quot;</span><span class="punctuation">]</span></span><br><span class="line">  fields<span class="punctuation">:</span></span><br><span class="line">    log_type<span class="punctuation">:</span> nginx_all_logs</span><br><span class="line">  fields_under_root<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"></span><br><span class="line">output.logstash<span class="punctuation">:</span></span><br><span class="line">  hosts<span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;192.168.56.140:5044&quot;</span><span class="punctuation">]</span></span><br><span class="line">  loadbalance<span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">  index<span class="punctuation">:</span> filebeat</span><br><span class="line">  </span><br><span class="line"># 参数说明</span><br><span class="line"># loadbalance：当你有多个logstash来做分流时（&gt;=<span class="number">2</span>），值设置为<span class="literal"><span class="keyword">true</span></span>，只有一个logstash分流，设置为<span class="literal"><span class="keyword">false</span></span>即可</span><br></pre></td></tr></table></figure><h4 id="4-8-2-Logstash-输出至-ES"><a href="#4-8-2-Logstash-输出至-ES" class="headerlink" title="4.8.2 Logstash 输出至 ES"></a>4.8.2 Logstash 输出至 ES</h4><blockquote><p>数据源确定后，接下来就是确定Logstash获取数据了</p></blockquote><p>1、Logstash 元数据</p><blockquote><p>更多元数据参考：<a href="https://www.elastic.co/guide/en/logstash/6.8/event-dependent-configuration.html#metadata">官方文档</a></p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">&quot;@metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">      <span class="attr">&quot;beat&quot;</span><span class="punctuation">:</span> <span class="string">&quot;filebeat&quot;</span><span class="punctuation">,</span> </span><br><span class="line">      <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6.8.23&quot;</span> </span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;doc&quot;</span> </span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>2、Logstash 配置输出</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">input <span class="punctuation">&#123;</span></span><br><span class="line">  beats <span class="punctuation">&#123;</span></span><br><span class="line">    port =&gt; <span class="number">5044</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">output <span class="punctuation">&#123;</span></span><br><span class="line">  elasticsearch <span class="punctuation">&#123;</span></span><br><span class="line">    hosts =&gt; <span class="punctuation">[</span><span class="string">&quot;http://192.168.56.133:9200&quot;</span><span class="punctuation">,</span> <span class="string">&quot;http://192.168.56.134:9200&quot;</span><span class="punctuation">,</span> <span class="string">&quot;http://192.168.56.135:9200&quot;</span><span class="punctuation">]</span></span><br><span class="line">    user =&gt; <span class="string">&quot;elastic&quot;</span></span><br><span class="line">    password =&gt; <span class="string">&quot;123456&quot;</span></span><br><span class="line">    index =&gt; <span class="string">&quot;my_nginx-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"># 官方案例：index =&gt; <span class="string">&quot;%&#123;[@metadata][beat]&#125;-%&#123;[@metadata][version]&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line"># 其实就是取元数据的默认值。</span><br></pre></td></tr></table></figure><p>3、分别启动 Logstash&#x2F;Filebeat</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker restart logstash</span><br><span class="line">./filebeat -e -c conf.d/nginx_output_logstash.yml</span><br></pre></td></tr></table></figure><p>4、ES 验证</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220808114201901.png" alt="image-20220808114201901"></p><h3 id="4-9-Filebeat-Kafka-Logstash-ES"><a href="#4-9-Filebeat-Kafka-Logstash-ES" class="headerlink" title="4.9 Filebeat + Kafka + Logstash + ES"></a>4.9 Filebeat + Kafka + Logstash + ES</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    kafka &#123;</span><br><span class="line">        type =&gt; &quot;xgxy-v&quot;</span><br><span class="line">        codec =&gt; &quot;json&quot;</span><br><span class="line">        topics =&gt; &quot;xgxy&quot;</span><br><span class="line">        decorate_events =&gt; true</span><br><span class="line">        bootstrap_servers =&gt; &quot;192.168.56.137:9092, 192.168.56.138:9092, 192.168.56.139:9092&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output&#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts =&gt; [&quot;192.168.56.133:9200&quot;,&quot;192.168.56.134:9200&quot;,&quot;192.168.56.135:9200&quot;]</span><br><span class="line">        user =&gt; &quot;elastic&quot;</span><br><span class="line">        password =&gt; &quot;123456&quot;</span><br><span class="line">        index =&gt; [&quot;%&#123;type&#125;-%&#123;+YYYY.MM.dd&#125;&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-9-FAQ"><a href="#4-9-FAQ" class="headerlink" title="4.9 FAQ"></a>4.9 FAQ</h3><h4 id="4-9-1-es-head-插件访问不了-ES-集群"><a href="#4-9-1-es-head-插件访问不了-ES-集群" class="headerlink" title="4.9.1 es-head 插件访问不了 ES 集群"></a>4.9.1 es-head 插件访问不了 ES 集群</h4><p><strong>1、详情如下图所示：</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624174527563.png" alt="image-20220624174527563"></p><p><strong>2、解决方案</strong></p><p>修改 ES 集群配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决跨域问题</span></span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新增以下内容</span></span><br><span class="line">http.cors.allow-headers: Authorization,X-Requested-With,Content-Length,Content-Type</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启 ES 集群</span></span><br><span class="line">docker restart es-1</span><br><span class="line">docker restart es-2</span><br><span class="line">docker restart es-3</span><br></pre></td></tr></table></figure><p><strong>3、es-head 插件访问</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.56.136:9100/?auth_user=elastic&amp;auth_password=123456</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">说明：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">auth_user：你在ES集群设置的用户名（其实是内置用户）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">auth_password：你当时设置的内置用户名密码</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624180113410.png" alt="image-20220624180113410"></p><p><strong>4、Nginx 如何配置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目前配置失败，正在查找原因...</span><br></pre></td></tr></table></figure><h2 id="五、Kibana-基础操作"><a href="#五、Kibana-基础操作" class="headerlink" title="五、Kibana 基础操作"></a>五、Kibana 基础操作</h2><h3 id="5-1-索引管理"><a href="#5-1-索引管理" class="headerlink" title="5.1 索引管理"></a>5.1 索引管理</h3><h4 id="5-1-1-查看-ES-的索引"><a href="#5-1-1-查看-ES-的索引" class="headerlink" title="5.1.1 查看 ES 的索引"></a>5.1.1 查看 ES 的索引</h4><p>【管理】–【索引管理】</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624112809355.png" alt="image-20220624112809355"></p><h4 id="5-1-2-创建和使用索引"><a href="#5-1-2-创建和使用索引" class="headerlink" title="5.1.2 创建和使用索引"></a>5.1.2 创建和使用索引</h4><blockquote><p>当我们的数据都存储到 ES 集群中时，接下来就是 Kibana 展示的环节了，首先我们要添加索引（可以进行泛检索），这个索引我们在 Logstash 的时候已经进行自定义了。</p></blockquote><p><strong>1、在菜单栏左侧的【管理】进行创建</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624112131666.png" alt="image-20220624112131666"></p><p><strong>2、以时间戳的方式进行筛选</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624112511428.png" alt="image-20220624112511428"></p><p><strong>3、如何查看刚刚创建的索引？</strong></p><blockquote><p>展示的时间的排序可以点击【时间】字段的下角标</p><p>图中，深灰色表示字 key，其后对应的是 value</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624121435875.png" alt="image-20220624121435875"></p><p><strong>4、如何指定字段显示？</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624122223751.png" alt="image-20220624122223751"></p><blockquote><p>字段顺序调整</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624122429007.png" alt="image-20220624122429007"></p><h3 id="5-2-用户管理"><a href="#5-2-用户管理" class="headerlink" title="5.2 用户管理"></a>5.2 用户管理</h3><h4 id="5-2-1-创建用户"><a href="#5-2-1-创建用户" class="headerlink" title="5.2.1 创建用户"></a>5.2.1 创建用户</h4><blockquote><p>注意：创建用户这一功能基于 ES 集群开启了用户认证。</p></blockquote><p><strong>1、基本介绍</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624162943655.png" alt="image-20220624162943655"></p><p><strong>2、创建用户</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624163028763.png" alt="image-20220624163028763"></p><p><strong>3、填写用户相关信息</strong></p><blockquote><p>这里的注意点是，对用户角色的设置。</p><p>用户名：用于 Kibana 登录</p><p>全名：自定义（一般定义为员工真实名）</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624163439178.png" alt="image-20220624163439178"></p><p><strong>4、看看用户管理页面：已成功创建</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624163526240.png" alt="image-20220624163526240"></p><h4 id="5-2-2-删除用户"><a href="#5-2-2-删除用户" class="headerlink" title="5.2.2 删除用户"></a>5.2.2 删除用户</h4><blockquote><p>点击用户管理页面（上图）对应的用户名，就会进入以下页面，点击删除用户即可。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624164206168.png" alt="image-20220624164206168"></p><h4 id="5-2-3-更改用户密码"><a href="#5-2-3-更改用户密码" class="headerlink" title="5.2.3 更改用户密码"></a>5.2.3 更改用户密码</h4><p><strong>1、点击用户页面对应的用户名</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624163946479.png" alt="image-20220624163946479"></p><p><strong>2、进入用户密码修改页面</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624164115642.png" alt="image-20220624164115642"></p><h4 id="5-2-4-用户角色（权限）"><a href="#5-2-4-用户角色（权限）" class="headerlink" title="5.2.4 用户角色（权限）"></a>5.2.4 用户角色（权限）</h4><p>点击角色，进行相关角色管理：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624170715932.png" alt="image-20220624170715932"></p><p>ES 提供了<code>保留角色</code>和<code>自定义</code>角色种，可根据我们的需求对不同用户进行不同权限的绑定。更多角色参数说明，请看<a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.8/security-privileges.html#privileges-list-indices">官方说明文档</a></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624170415424.png" alt="image-20220624170415424"></p><p>查看创建结果：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220624171013615.png" alt="image-20220624171013615"></p><h4 id="5-2-5-角色对应绑定工作区"><a href="#5-2-5-角色对应绑定工作区" class="headerlink" title="5.2.5 角色对应绑定工作区"></a>5.2.5 角色对应绑定工作区</h4><p><strong>1、例如我创建了 dev 角色</strong></p><blockquote><ul><li><p>创建 dev 角色</p></li><li><p>该角色中绑定了 dev 用户（Java开发）</p></li></ul></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626164107387.png" alt="image-20220626164107387"></p><p><strong>2、现对该角色绑定工作区</strong></p><blockquote><p>目的：使该角色仅对该工作区有相关权限，实现用户权限划分。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626163917429.png" alt="image-20220626163917429"></p><h4 id="5-2-6-开发人员权限"><a href="#5-2-6-开发人员权限" class="headerlink" title="5.2.6 开发人员权限"></a>5.2.6 开发人员权限</h4><p>1、基础权限</p><ul><li><p>创建索引</p></li><li><p>查看索引</p></li><li><p>删除索引</p><blockquote><p>该权限指的是删除 Kibana 创建的搜索索引，并不是真正删除 ES 本身的数据索引。</p></blockquote></li><li><p>查看 ES 健康状态</p><blockquote><p>暂时不开放，因为以下权限可能存在开发人员误操作将其他项目组管理空间删除的风险。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220817113507505.png" alt="image-20220817113507505"></p></li><li><p>查看索引生命周期</p><blockquote><p>暂时不开放，因为同样可能存在开发人员误操作将其他项目组管理空间删除的风险。</p></blockquote></li><li><p>仪表板、可视化、地图等其他基本权限</p></li></ul><p>2、常规权限</p><p>&#x3D;&#x3D;一般设置以下权限即可，不同项目组仅能查看自己对应的日志信息，其他项目组管理空间无权查看。&#x3D;&#x3D;</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220817120105446.png" alt="image-20220817120105446"></p><h3 id="5-3-ES-集群-x2F-实例状态"><a href="#5-3-ES-集群-x2F-实例状态" class="headerlink" title="5.3 ES 集群&#x2F;实例状态"></a>5.3 ES 集群&#x2F;实例状态</h3><p>在 Kibana 控制面板上，可查看 ES 集群及 Kibana 实例健康状态，如何查看？</p><p>点击 Kibana 菜单栏左下角的【monitoring】监控按钮即可查看：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626093604962.png" alt="image-20220626093604962"></p><h4 id="5-3-1-ES-集群"><a href="#5-3-1-ES-集群" class="headerlink" title="5.3.1 ES 集群"></a>5.3.1 ES 集群</h4><p><strong>1、主要指标</strong></p><ul><li>ES 集群版本；</li><li>ES 集群运行的时间；</li><li>ES 集群磁盘可用空间百分百比；</li><li>ES 集群的 JVM 堆大小；</li><li>ES 集群的索引数据详情；</li><li>ES 集群内存使用情况；</li><li>ES 状态为 Green 表示集群健康。</li></ul><p><strong>2、整体概览</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626094120204.png" alt="image-20220626094120204"></p><h4 id="5-3-2-Kibana-实例"><a href="#5-3-2-Kibana-实例" class="headerlink" title="5.3.2 Kibana 实例"></a>5.3.2 Kibana 实例</h4><p><strong>1、主要指标</strong></p><ul><li>Kibana 请求数</li><li>Kibana 连接数</li><li>Kibana 内存使用</li><li>Kibana 响应时间</li><li>Kibana 状态为 Green 表示实例健康</li></ul><p><strong>2、整体概览</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626094411882.png" alt="image-20220626094411882"></p><h3 id="5-4-常用可视化分析"><a href="#5-4-常用可视化分析" class="headerlink" title="5.4 常用可视化分析"></a>5.4 常用可视化分析</h3><blockquote><p>本次采用 Kibana 自带的一个样本数据（航班飞行日志）来做演示。</p></blockquote><h4 id="5-4-1-饼图"><a href="#5-4-1-饼图" class="headerlink" title="5.4.1 饼图"></a>5.4.1 饼图</h4><p>本次实现功能：展示航班数及航班占比情况。</p><p><strong>1、创建可视化界面</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626095737553.png" alt="image-20220626095737553"></p><p><strong>2、选择所需的可视化类型</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626095923091.png" alt="image-20220626095923091"></p><p><strong>3、选择基于什么样的索引来创建可视化界面</strong></p><blockquote><p>以航班飞行日志来展示</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626100429730.png" alt="image-20220626100429730"></p><p><strong>4、指标&#x2F;存储桶选择</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626101028748.png" alt="image-20220626101028748"></p><p>上图的字段会根据你你的索引日志内容自动检出：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626101811427.png" alt="image-20220626101811427"></p><p><code>Carrier 表示航班公司</code></p><p>可根据需求调整饼图颜色，在可视化图形的右上角配置：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626102653914.png" alt="image-20220626102653914"></p><p><strong>5、生成指标数据</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626101329900.png" alt="image-20220626101329900"></p><p>如果要继续对饼图进行界面属性优化，可点击【选项】进行设置：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626103148167.png" alt="image-20220626103148167"></p><p>最后点击【保存】即可</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626103248520.png" alt="image-20220626103248520"></p><p>【确认保存】–如果你是做同类型的可视化，标题尽量保持一定的格式，方便后期导入仪表板，比如：</p><ul><li>航班-航班数</li><li>航班-航班票价</li><li>航班-…</li></ul><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626103342733.png" alt="image-20220626103342733"></p><p><strong>结论：</strong></p><ol><li><p>该饼图表示不同航班公司承运的航班数及占比情况；</p></li><li><p>如果在游戏应用领域的话，可以展示不同国家对某款游戏使用的占比情况。</p></li></ol><h4 id="5-4-2-面积图"><a href="#5-4-2-面积图" class="headerlink" title="5.4.2 面积图"></a>5.4.2 面积图</h4><p>本次实现功能：</p><ol><li>根据<code>时间</code>在同一面积图中<code>展示航班数</code>及<code>航班平均票价</code>。</li><li>航班数使用面积图（area）展示，平均票价使用点状图展示。</li></ol><p><strong>1、新建面积图并做相关指标配置</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626110006111.png" alt="image-20220626110006111"></p><p><strong>2、生成指标数据</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626110125684.png" alt="image-20220626110125684"></p><p>此时的有两条 Y 轴（计数和平均值）合二为一，并不是很美观，可进点击【Metrics &amp; Axes】进一步优化：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626111313592.png" alt="image-20220626111313592"></p><p><strong>3、最后点击【保存】即可</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626111644033.png" alt="image-20220626111644033"></p><p><strong>结论：</strong></p><ul><li>面积图可进行相关数据统计、展示；</li><li>其图标类型有 area、line、bar的形式，对于多 Y 轴的情况下可选择性使用；</li><li>以点状形式显示的需提前创建【点大小指标】，方便点 大小调节。</li></ul><h4 id="5-4-3-垂直条形图"><a href="#5-4-3-垂直条形图" class="headerlink" title="5.4.3 垂直条形图"></a>5.4.3 垂直条形图</h4><p>本次实现功能：根据<code>时间</code>在同垂直条形图<code>展示航延误情况</code>及<code>延误类型</code>。</p><p><strong>1、新建垂直条形图并做相关指标配置</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626113846368.png" alt="image-20220626113846368"></p><p><strong>2、生成指标数据</strong></p><p>X 轴主要实现了在某个时间点飞机延误的类型，Y 轴负责统计延误类型出现的次数。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626114227826.png" alt="image-20220626114227826"></p><p><strong>3、最后点击【保存】即可</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626115032846.png" alt="image-20220626115032846"></p><p><strong>结论：</strong></p><ul><li>垂直条形图可统计同一时间不同类型指标的数据情况；</li><li>其展现形式很直观。</li></ul><h4 id="5-4-4-标签云图"><a href="#5-4-4-标签云图" class="headerlink" title="5.4.4 标签云图"></a>5.4.4 标签云图</h4><p>本次实现功能：显示目标机场的天气状况</p><p><strong>1、新建标签云图并做相关指标配置</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626115639325.png" alt="image-20220626115639325"></p><p><strong>2、可点击【选项】对标签做相关排序</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626120122191.png" alt="image-20220626120122191"></p><p><strong>3、最后点击【保存】即可</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626120215335.png" alt="image-20220626120215335"></p><p><strong>结论：</strong></p><ul><li>这个也是比较实用的一个图形展示，比如应用在我们的热搜关键词这方面；</li><li>如果某些关键词出现的次数越多，在可视化界面的字就会越大。</li></ul><h4 id="5-4-5-数据表"><a href="#5-4-5-数据表" class="headerlink" title="5.4.5 数据表"></a>5.4.5 数据表</h4><p>本次实现功能：航班数、航班延误、航班取消统计。</p><p><strong>1、新建数据表并做相关指标配置</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626144530356.png" alt="image-20220626144530356"></p><p>接着，在一个图表中创建多个指标，比如，出了上述的航班数之外，我再新增<code>航班延误指标</code>和<code>航班取消指标</code>两项。</p><p><strong>2、继续添加分组（表字段）</strong></p><blockquote><p>可对字段进行数据过滤操作。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626145947536.png" alt="image-20220626145947536"></p><p>但是运行结果是所有数据的聚合，我们可以继续优化：</p><blockquote><p>这样的话就可以分段统计了。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626150315406.png" alt="image-20220626150315406"></p><p><strong>3、最后点击【保存】即可</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626150534232.png" alt="image-20220626150534232"></p><p><strong>结论：</strong></p><ul><li>通过图表二维关系进行展现，更加清晰；</li><li>同时图表具备多字段自定义及日志数据过滤（筛选）。</li></ul><h4 id="5-4-6-区域地图"><a href="#5-4-6-区域地图" class="headerlink" title="5.4.6 区域地图"></a>5.4.6 区域地图</h4><p>本次实现功能：通过地图来展示不同国家的不同票价。</p><p><strong>1、新建区域地图并做相关指标配置</strong></p><blockquote><p>票价越高，地图颜色就越红（当然也可以自定义颜色）</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626151053068.png" alt="image-20220626151053068"></p><p><strong>2、最后点击【保存】即可</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626151629958.png" alt="image-20220626151629958"></p><p><strong>结论：</strong></p><ul><li>对于市场遍布全球的公司，区域地图是一个很不错的选择；</li><li>该模式下，可对日志数据进行相关统计（关联国际地区），统计结果将以地图形式展现。</li></ul><h4 id="5-4-7-TSVB-图"><a href="#5-4-7-TSVB-图" class="headerlink" title="5.4.7 TSVB 图"></a>5.4.7 TSVB 图</h4><p>对于较为复杂的 ES 聚合操作，需要使用到我们的 <code>TSVB</code>，即下方综合图表：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626153037832.png" alt="image-20220626153037832"></p><p>本次实现功能：统计航班延误率</p><p><strong>1、新建 Visual Builder 并做相关指标配置</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626160249808.png" alt="image-20220626160249808"></p><p><strong>2、接着点击面板选项生成数据</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626160425229.png" alt="image-20220626160425229"></p><h4 id="5-4-8-问题？"><a href="#5-4-8-问题？" class="headerlink" title="5.4.8 问题？"></a>5.4.8 问题？</h4><p>对于 kibana 上点点的操作，就可以得到对应的数据信息。创建一个可视化图表之后，其后端是如何实现数据采集的呢？</p><p><strong>1、点击可视化上方的【检查】按钮</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626152527228.png" alt="image-20220626152527228"></p><p><strong>2、查看【亲求】部分</strong></p><blockquote><p>可以看到，这其实是 <code>ES 后端的聚合查询语句</code>，也就是我们点点点操作的时候，就已经帮我们自动实现了。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626152231495.png" alt="image-20220626152231495"></p><h3 id="5-5-仪表板管理"><a href="#5-5-仪表板管理" class="headerlink" title="5.5 仪表板管理"></a>5.5 仪表板管理</h3><h4 id="5-5-1-新建仪表板"><a href="#5-5-1-新建仪表板" class="headerlink" title="5.5.1 新建仪表板"></a>5.5.1 新建仪表板</h4><p><strong>1、点击右侧仪表板，并创建新的仪表板</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626122031574.png" alt="image-20220626122031574"></p><p><strong>2、点击上方菜单栏【添加】按钮</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626122323899.png" alt="image-20220626122323899"></p><p><strong>3、依次点击，就会被添加到仪表板中</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626122437730.png" alt="image-20220626122437730"></p><p><strong>4、最后点击【保存】即可</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626122606449.png" alt="image-20220626122606449"></p><p>仪表板上查看：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626122816077.png" alt="image-20220626122816077"></p><p><strong>5、仪表板管理</strong></p><blockquote><ul><li>检查</li><li>编辑</li><li>定制</li><li>全屏</li><li>删除</li></ul></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626123122624.png" alt="image-20220626123122624"></p><h4 id="5-5-2-共享仪表板"><a href="#5-5-2-共享仪表板" class="headerlink" title="5.5.2 共享仪表板"></a>5.5.2 共享仪表板</h4><p>如果我们需要将仪表板的内容共享给同事看，这是就需要 Kibana 的<code>仪表板</code>共享功能。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626124409535.png" alt="image-20220626124409535"></p><p>点击【复制链接】</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626143600702.png" alt="image-20220626143600702"></p><h3 id="5-6-管理空间"><a href="#5-6-管理空间" class="headerlink" title="5.6 管理空间"></a>5.6 管理空间</h3><h4 id="5-6-1-用途"><a href="#5-6-1-用途" class="headerlink" title="5.6.1 用途"></a>5.6.1 用途</h4><p>管理空间可进行权限管理，比如某些组配置的可视化界面仅限该组查看，此时就可以应用到<code>管理空间</code>了，每个管理空间可管理自己独立的一套可视化界面，<code>类似于 K8s 的 namespace</code>。</p><h4 id="5-6-2-新建管理空间"><a href="#5-6-2-新建管理空间" class="headerlink" title="5.6.2 新建管理空间"></a>5.6.2 新建管理空间</h4><p><strong>1、如下图，点击【管理空间】</strong></p><blockquote><p>或点击菜单栏左侧【管理】—&gt;【Kibana】—&gt;【工作区】新建</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626162253440.png" alt="image-20220626162253440"></p><p><strong>2、点击创建空间</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220626162956733.png" alt="image-20220626162956733"></p><p><strong>3、创建好后，就可以登录到不同的管理空间</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220627102247042.png" alt="image-20220627102247042"></p><h3 id="5-7-日志查询"><a href="#5-7-日志查询" class="headerlink" title="5.7 日志查询"></a>5.7 日志查询</h3><h4 id="5-7-1-根据索引查询"><a href="#5-7-1-根据索引查询" class="headerlink" title="5.7.1 根据索引查询"></a>5.7.1 根据索引查询</h4><p><strong>1、Discover 下选择定义的索引</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220627170107635.png" alt="image-20220627170107635"></p><p><strong>2、选择对应的索引就可以查看具体日志</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220627170359681.png" alt="image-20220627170359681"></p><h4 id="5-7-2-根据时间查询"><a href="#5-7-2-根据时间查询" class="headerlink" title="5.7.2 根据时间查询"></a>5.7.2 根据时间查询</h4><p>如果你根据索引字段来匹配某个时间节点的话，则该时间点需要在下图时间范围内才能过滤出来。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220627180831755.png" alt="image-20220627180831755"></p><h4 id="5-7-3-根据索引字段查询"><a href="#5-7-3-根据索引字段查询" class="headerlink" title="5.7.3 根据索引字段查询"></a>5.7.3 根据索引字段查询</h4><p><strong>1、查看指定索引有哪些可用字段</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220627165956033.png" alt="image-20220627165956033"></p><p><strong>2、根据字段筛选日志内容</strong></p><ul><li><p>单条件筛选</p><blockquote><p>根据某个文件名来匹配</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220627170725521.png" alt="image-20220627170725521"></p><blockquote><p>匹配结果如下</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220627170656835.png"></p><blockquote><p>被匹配的字段会以高亮形式显示</p></blockquote></li><li><p>多条件筛选</p><blockquote><p>精准匹配</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220627171139004.png" alt="image-20220627171139004"></p></li></ul><p><strong>说明</strong>：根据字段来筛选数据是比较灵活的手段，可以快速定位到日志的具体位置。</p><h3 id="5-8-索引生命周期管理"><a href="#5-8-索引生命周期管理" class="headerlink" title="5.8 索引生命周期管理"></a>5.8 索引生命周期管理</h3><h4 id="5-8-1-创建生命周期策略"><a href="#5-8-1-创建生命周期策略" class="headerlink" title="5.8.1 创建生命周期策略"></a>5.8.1 创建生命周期策略</h4><p>1、进入索引生命周期策略并创建策略</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220816135703698.png" alt="image-20220816135703698"></p><p>2、点击上图【创建策略】进入以下具体配置</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220816140755604.png" alt="image-20220816140755604"></p><p>3、最后查看创建的生命周期策略列表</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220817104821612.png" alt="image-20220817104821612"></p><h4 id="5-8-2-索引添加生命周期策略"><a href="#5-8-2-索引添加生命周期策略" class="headerlink" title="5.8.2 索引添加生命周期策略"></a>5.8.2 索引添加生命周期策略</h4><p>1、进入索引管理并添加对应索引生命周期</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220817105256831.png" alt="image-20220817105256831"></p><p>2、然后添加策略即可</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220817105504026.png" alt="image-20220817105504026"></p><p>3、可以同个生命周期策略查看其关联的索引</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220817105724955.png" alt="image-20220817105724955"></p><h4 id="5-8-3-索引删除生命周期策略"><a href="#5-8-3-索引删除生命周期策略" class="headerlink" title="5.8.3 索引删除生命周期策略"></a>5.8.3 索引删除生命周期策略</h4><p>1、进入索引生命周期策略执行删除即可</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220817110518507.png" alt="image-20220817110518507"></p><p>2、如果你生命周期策略关联的索引正在被使用，是无法删除的，如下图</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220817110009045.png" alt="image-20220817110009045"></p><blockquote><p>这种情况下，可以去索引管理解除对应的索引生命周期策略</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220817110905668.png" alt="image-20220817110905668"></p>]]></content>
      
      
      <categories>
          
          <category> 日志系统 </category>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>没事千万别动生产服数据库 - 来自小菜鸟的忠告</title>
      <link href="/posts/articles/90a42e.html"/>
      <url>/posts/articles/90a42e.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/common-issues-mysql-thumb.png" alt="common-issues-mysql-thumb"></p><p><a href="https://help.aliyun.com/document_detail/41817.html?spm=5176.19908310.help.dexternal.39bf1450lprd8o#d8a0edc0ce8cv">阿里云官方参考文档</a></p><hr><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天把一张  5500 多万条记录的表进行按年度拆分，本来打算将表数据拆分为 2020 年、2021 年、2022 年三张新表，提升原表查询效率，仅保留 2023 年数据。表拆分完毕后，就陆续删除原表中 2020 年、2021 年、2022 年的数据。结果在执行 SQL 过程中误操作执行了删除 2023 年全年的 SQL 语句，具体如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from kys_convert_order where add_time between &#x27;2022-11-01 00:00:01&#x27; and &#x27;2023-12-01 00:00:00&#x27;;</span><br></pre></td></tr></table></figure><p>原本是需要执行这条 SQL 语句的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from kys_convert_order where add_time between &#x27;2022-11-01 00:00:01&#x27; and &#x27;2022-12-01 00:00:00&#x27;;</span><br></pre></td></tr></table></figure><p>发现不对劲后，赶紧 kill 掉 SQL 进程。但庆幸数据没有被删除，我初步猜测是因为 <code>&#39;2022-11-01 00:00:01&#39; and &#39;2023-12-01 00:00:00&#39;</code> 这段时间的数据量很大，SQL 进程可能在做扫表的一个操作。</p><p>为了验证数据是否被删除，于是将备份数据 <code>dump</code> 下来（我们使用的是阿里云的 <code>RDS MySQL</code>），备份方式为物理备份，最新备份数据为每天早上 <code>8:00</code>（即备份 策略为一天一次全量备份，共保留 7 天数据）。因此新开了一台按量付费的 Linux 实例，安装好 MySQL 环境，并进行数据恢复，验证与生产环境数据的一致性。以下是恢复详细步骤。</p><h2 id="一、环境部署"><a href="#一、环境部署" class="headerlink" title="一、环境部署"></a>一、环境部署</h2><p><strong>1、MySQL</strong></p><blockquote><p>与 RDS MySQL 版本保持一致（大版本）</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rds MySQL 版本：5.7</span></span><br><span class="line"><span class="comment"># 本次安装 MySQL 版本：5.7.34</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 MySQL 5.7 和 MySQL 官方的 Yum 源管理器</span></span><br><span class="line">yum -y install https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 MySQL 5.7</span></span><br><span class="line">yum -y install mysql-community-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 MySQL</span></span><br><span class="line">systemctl start mysqld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取初始密码</span></span><br><span class="line">grep password /var/log/mysqld.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改初始密码</span></span><br><span class="line">mysqladmin -u root -p<span class="string">&#x27;旧密码&#x27;</span> password <span class="string">&#x27;新密码&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MySQL登录验证</span></span><br><span class="line">mysql -u root -p<span class="string">&#x27;新密码&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>2、qpress</strong></p><blockquote><p>解压工具</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载可执行文件的tar包</span></span><br><span class="line">wget <span class="string">&quot;https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/file-manage-files/zh-CN/20230406/flxd/qpress-11-linux-x64.tar&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压下载的tar包，取出可执行文件</span></span><br><span class="line">tar -xvf qpress-11-linux-x64.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置qpress文件的执行权限</span></span><br><span class="line">sudo <span class="built_in">chmod</span> 775 qpress</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝qpress到/usr/bin中</span></span><br><span class="line">sudo <span class="built_in">cp</span> qpress /usr/bin</span><br></pre></td></tr></table></figure><p><strong>3、Percona XtraBackup</strong></p><blockquote><p>备份&#x2F;恢复工具</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wget如果下载很慢，你可以先下载到你Windows本地再上传</span></span><br><span class="line">wget https://downloads.percona.com/downloads/Percona-XtraBackup-2.4/Percona-XtraBackup-2.4.28/binary/redhat/7/x86_64/percona-xtrabackup-24-2.4.28-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始安装XtraBackup</span></span><br><span class="line">sudo yum localinstall -y percona-xtrabackup-24-2.4.28-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><h2 id="二、目录规划"><a href="#二、目录规划" class="headerlink" title="二、目录规划"></a>二、目录规划</h2><p><strong>1、解压目录</strong></p><blockquote><p>用于存放解压后的备份文件（压缩文件从 RDS MySQL 下载并上传到服务器）</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /var/mysql_bkdata</span><br><span class="line"><span class="built_in">chown</span> -R <span class="variable">$USER</span>:<span class="variable">$USER</span> /var/mysql_bkdata</span><br></pre></td></tr></table></figure><p><strong>2、数据目录</strong></p><blockquote><p>用于将备份文件恢复到此目录，启动自建数据库时，自建数据库的数据目录使用此目录的数据。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /var/mysql_newdata</span><br><span class="line"><span class="built_in">chown</span> -R <span class="variable">$USER</span>:<span class="variable">$USER</span> /var/mysql_newdata</span><br></pre></td></tr></table></figure><h2 id="三、操作步骤"><a href="#三、操作步骤" class="headerlink" title="三、操作步骤"></a>三、操作步骤</h2><p><strong>1、下载备份文件</strong></p><p>通过阿里云 RDS 控制台下载即可，过程略。可通过 wget 下载，下载的文件后缀有一定要求，否则无法解压，具体看官方说明：<br><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230606175552896.png" alt="image-20230606175552896"></p><p><strong>2、解压备份文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qpress -<span class="keyword">do</span>  test_xb.qp | xbstream -x -v -C /var/mysql_bkdata/</span><br></pre></td></tr></table></figure><p>实测了一下，我在自建 MySQL 主机上 wget 了备份文件，且后缀名为 <code>ddz_xb.qp</code>，符合后缀名命名要求，但是通过上面这条命令是执行失败的，但你可以将 <code>ddz_xb.qp</code> 重命名为 <code>ddz_qp.xb</code>，然后使用上图 <code>xbstream</code> 的方式来解压是完全没问题的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> ddz_xb.qp ddz_qp.xb</span><br></pre></td></tr></table></figure><p>开始解压文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 步骤一：解包</span></span><br><span class="line"><span class="built_in">cat</span> ddz_qp.xb | xbstream -x -v -C /var/mysql_bkdata/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤二：解压（时间较长，需耐心等待）</span></span><br><span class="line"><span class="comment"># 适用于MySQL 5.5/5.6/5.7</span></span><br><span class="line">innobackupex --decompress --remove-original /var/mysql_bkdata/</span><br></pre></td></tr></table></figure><p><strong>3、恢复数据</strong></p><p><mark>恢复数据库前，请先停止自建数据库服务。</mark></p><ul><li><p>停止自建 MySQL 服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop mysqld.service</span><br></pre></td></tr></table></figure></li><li><p>恢复前准备</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innobackupex --defaults-file=/var/mysql_bkdata/backup-my.cnf --apply-log /var/mysql_bkdata/</span><br></pre></td></tr></table></figure><blockquote><p>参数解释</p></blockquote><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>–defaults-file</td><td>通过传入配置文件设置MySQL默认选项。RDS MySQL备份文件中，提供名为<code>backup-my.cnf</code>的配置文件，该文件位于<strong>备份解压目录</strong>，即<code>/var/mysql_bkdata/</code>。</td></tr><tr><td>–apply-log</td><td>XtraBackup工具的准备命令。该命令后配置存放备份文件的目录，即<strong>备份解压目录</strong><code>/var/mysql_bkdata/</code>。</td></tr></tbody></table></li><li><p>恢复数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innobackupex --defaults-file=/etc/my.cnf --copy-back /var/mysql_bkdata/</span><br></pre></td></tr></table></figure><blockquote><p>参数解释</p></blockquote><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>–defaults-file</td><td>自建数据库的<code>my.cnf</code>文件，根据此配置文件中设置的<strong>数据目录</strong>（datadir），获取恢复数据的目标路径。</td></tr><tr><td>–copy-back</td><td>XtraBackup工具的恢复命令。该命令后配置存放备份文件的目录，即<strong>备份解压目录</strong><code>/var/mysql_bkdata/</code>，XtraBackup工具将此目录数据恢复到自建数据库的<strong>数据目录</strong>中。</td></tr></tbody></table></li><li><p>修改自建数据库配置文件<code>my.cnf</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/my.cnf</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment"># 指定新的数据目录</span></span><br><span class="line">datadir = /var/mysql_newdata</span><br><span class="line"><span class="comment"># 参数innodb_undo_tablespaces的取值需要与/var/mysql_bkdata/backup-my.cnf中的取值相同</span></span><br><span class="line"><span class="comment"># 可以使用cat /var/mysql_bkdata/backup-my.cnf | grep innodb_undo_tablespaces查询。</span></span><br><span class="line">innodb_undo_tablespaces=2</span><br><span class="line">innodb_undo_directory=/var/mysql_newdata</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在RDS MySQL管理控制台中查看实例参数lower_case_table_names的取值，如果取值为1，则需要修改自建数据库配置文件my.cnf。</span></span><br><span class="line">lower_case_table_names=1</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><p><strong>4、启动自建 MySQL</strong></p><ul><li><p>为新的数据目录授权</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> -R mysql:mysql /var/mysql_newdata</span><br></pre></td></tr></table></figure></li><li><p>启动 MySQL 进程</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop mysqld.service</span><br><span class="line">systemctl status mysqld.service</span><br></pre></td></tr></table></figure></li></ul><p><strong>5、连接数据库并验证</strong></p><ul><li><p>登录自建数据库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p&lt;对应密码&gt;</span><br></pre></td></tr></table></figure></li><li><p>验证数据库是否完整</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure></li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>在删除数据库表数据时，需要注意这几点：</p><p>（1）使用 DELETE 命令和 WHERE 子句来选择指定时间段内的数据。例如，假设需要删除时间范围为 start_time 和 end_time 之间的数据，则可以使用如下命令：</p><pre><code>DELETE FROM kys_convert_order WHERE add_time BETWEEN &#39;2022-01-01 00:00:00&#39; AND &#39;2022-03-01 00:00:00&#39;;</code></pre><p>其中，table_name 是要删除数据的表名，time_column 是表中用于表示时间的列名，BETWEEN start_time AND end_time 是时间范围条件。</p><p>（2）使用 ORDER BY 子句按照时间升序（ASC）排序。例如，假设 time_column 是日期类型，则可以使用如下命令：</p><pre><code>DELETE FROM kys_convert_order WHERE add_time BETWEEN &#39;2022-01-01 00:00:00&#39; AND &#39;2022-03-01 00:00:00&#39; ORDER BY add_time ASC;</code></pre><p>这样就会按照时间顺序执行删除操作，从而确保数据是按照时间顺序删除的。</p><p>需要注意的是，如果表中数据比较多，一次性删除可能会导致性能问题，可以考虑使用 LIMIT 限制每次删除的行数。例如，可以使用如下命令：</p><pre><code>DELETE FROM kys_convert_order WHERE add_time BETWEEN &#39;2022-01-01 00:00:00&#39; AND &#39;2022-03-01 00:00:00&#39; ORDER BY add_time ASC LIMIT 50000;</code></pre><p>这里的 LIMIT 1000 表示每次最多删除 1000 行数据。需要多次执行命令，直到删除完所有指定时间段内的数据为止。</p><p><mark>最后开发人员进行数据可用性校验！</mark></p><p>-–END</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 关系型数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker attach VS exec</title>
      <link href="/posts/articles/1968d59e.html"/>
      <url>/posts/articles/1968d59e.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/docker-attach.webp" alt="docker-attach"></p><hr><p>我们知道，进入容器常用的两种方式为：<code>docker exec ...</code>、<code>docker attach ...</code>，那这两者有什么区别呢？</p><p>首先，运行一个测试容器，并在启动容器时运行相关指令，如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name <span class="built_in">test</span> -d ubuntu /bin/bash -c <span class="string">&quot;while true; do sleep 1; echo hello world; done&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230605112140003.png" alt="image-20230605112140003"></p><p><strong>1、attach 进入容器</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/20230605112331.png"></p><p>如何退出容器而不停止容器运行？方法：<code>Ctrl + p  + q</code>，如果使用 <code>exit</code> 那退出容器后，容器也会随之停止运行。</p><p><strong>2、exec 进入容器</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230605113008592.png" alt="image-20230605113008592"></p><p>那这又如何退出容器呢？exec 方式的话，直接 exit 退出容器即可（且容器不会停止运行）。</p><p>从这两者方式进入容器，不难发现，这两者的主要区别如下：</p><ul><li>attach 直接进入容器启动命令的终端，不会启动新进程，并以 <code>Ctrl + p  + q</code> 不终止容器退出；</li><li>exec 则是在容器中打开新的终端，且可启动新的进程，以 <code>exit</code> 不终止容器退出；</li><li>因此，如果想直接在终端中查看启动命令的输出，可使用 <code>attach</code>，否则使用 <code>exec</code>。</li></ul><p>但实际生产中，看启动输出，一般我们是通过 <code>docker logs -f ...</code> 命令，如下图所示：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230605113739418.png" alt="image-20230605113739418"></p><p>其中 <code>-f</code> 选项是以动态的形式查看输出结果，效果类似 <code>tailf</code> 或 <code>tail -f</code>。</p><p>-–END</p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 VuePress 的 RECO 主题博客系统搭建</title>
      <link href="/posts/articles/a90bd9b5.html"/>
      <url>/posts/articles/a90bd9b5.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230528135648671.png" alt="image-20230528135648671"></p><hr><h2 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h2><ul><li><strong>Windows</strong>：10</li><li><strong>NodeJs</strong>：v18.15.0</li><li><strong>Npm</strong>：v9.5.0（含于NodeJs）</li><li><strong>Yarn</strong>：1.22.19（通过 npm 安装）</li></ul><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><p><strong>1、npm 安装 yarn</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn --registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置源</span></span><br><span class="line">yarn config <span class="built_in">set</span> registry https://registry.npm.taobao.org -g</span><br><span class="line">yarn config <span class="built_in">set</span> sass_binary_site http://cdn.npm.taobao.org/dist/node-sass -g</span><br></pre></td></tr></table></figure><p><strong>2、初始化项目</strong></p><blockquote><p><a href="https://v1.vuepress.vuejs.org/zh/guide/getting-started.html">https://v1.vuepress.vuejs.org/zh/guide/getting-started.html</a></p><p>按照步骤一步步执行，并最终启动即可，过程中若遇到错误，请看 FAQ 部分。</p></blockquote><p><strong>3、本地访问验证</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230427111334709.png" alt="image-20230427111334709"></p><p><mark>如何添加状态栏？</mark></p><p><strong>4、docs 目录下创建 .vuepress 目录</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> .vuepress </span><br></pre></td></tr></table></figure><p><strong>5、.vuepress  目录下创建 config.js 文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> config.js</span><br></pre></td></tr></table></figure><p><strong>6、config.js 文件中添加如下内容</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    title: <span class="string">&#x27;Rabcnops&#x27;</span>,</span><br><span class="line">    description: <span class="string">&#x27;云计算、云原生、云开发学习文档！&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230427170306751.png" alt="image-20230427170306751"></p><h2 id="三、RECO-主题"><a href="#三、RECO-主题" class="headerlink" title="三、RECO 主题"></a>三、RECO 主题</h2><blockquote><p>主题地址：<a href="https://vuepress-theme-reco.recoluan.com/">vuepress-reco (recoluan.com)</a></p></blockquote><h3 id="3-1-初始化"><a href="#3-1-初始化" class="headerlink" title="3.1 初始化"></a>3.1 初始化</h3><p>1、初始化环境</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化，并选择 2.x</span></span><br><span class="line">npm install @vuepress-reco/theme-cli@1.0.7 -g</span><br><span class="line">theme-cli init my-blog   <span class="comment"># 初始化一个my-blog工程（自定义）</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230427173913739.png" alt="image-20230427173913739"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230427183712771.png" alt="image-20230427183712771"></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230427183517241.png" alt="image-20230427183517241"></p><h3 id="3-2-说明"><a href="#3-2-说明" class="headerlink" title="3.2 说明"></a>3.2 说明</h3><p>这个主题暂时先不研究了，后面打算通过 Python 自行开发一套。</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="启动服务报错"><a href="#启动服务报错" class="headerlink" title="启动服务报错"></a>启动服务报错</h3><p><strong>1、报错现象</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn docs:dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行报错</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221209113113605.png" alt="image-20221209113113605"></p><p><strong>2、报错原因</strong></p><p>出现这个错误是因为 node.js V17 版本中最近发布的OpenSSL3.0, 而OpenSSL3.0对允许算法和密钥大小增加了严格的限制，可能会对生态系统造成一些影响.</p><p><strong>3、解决方案</strong></p><p>有两种解决方案：<code>降级到 Node.js v16</code>或<code>启用旧版 OpenSSL 提供程序</code></p><ul><li><p>降低版本至 node.js V16（永久解决）</p></li><li><p>终端执行启用旧版 OpenSSL 相关命令（临时解决）</p><ul><li><p>在类 Unix 上（Linux、macOS、Git bash 等）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NODE_OPTIONS=--openssl-legacy-provider</span><br></pre></td></tr></table></figure></li><li><p>在 Windows 命令提示符下（CMD）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> NODE_OPTIONS=--openssl-legacy-provider</span><br></pre></td></tr></table></figure></li><li><p>在 Windows PowerShell 上</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$env</span>:NODE_OPTIONS = <span class="string">&quot;--openssl-legacy-provider&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>完成之后，再次启动服务即可解决！</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
          <category> VuePress </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VuePress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EduSoho 网校部署</title>
      <link href="/posts/articles/e7cab59a.html"/>
      <url>/posts/articles/e7cab59a.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230524094717828.png" alt="image-20230524094717828"></p><hr><h2 id="一、初始化环境"><a href="#一、初始化环境" class="headerlink" title="一、初始化环境"></a>一、初始化环境</h2><p><strong>1、安装wget</strong></p><p>如果系统已安装wget,请跳过此步骤</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install wget</span><br></pre></td></tr></table></figure><p><strong>2、关闭防火墙&#x2F;Selinux</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure><p>在命令行输入：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0</span><br></pre></td></tr></table></figure><p>或者修改配置文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/selinux/config</span><br></pre></td></tr></table></figure><p>将<code>SELINUX=enforcing</code>改为：<code>SELINUX=disabled</code></p><h2 id="二、安装-Nginx"><a href="#二、安装-Nginx" class="headerlink" title="二、安装 Nginx"></a>二、安装 Nginx</h2><p><strong>1、安装nginx源</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#下载源</span></span><br><span class="line">wget https://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装源</span></span><br><span class="line">rpm -ivh nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br></pre></td></tr></table></figure><p><strong>2、安装配置nginx包</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装nginx</span></span><br><span class="line">yum install -y nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改nginx默认配置</span></span><br><span class="line">vim /etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#在http&#123;&#125;配置中加入：</span></span><br><span class="line">client_max_body_size 1024M;</span><br></pre></td></tr></table></figure><p><strong>3、启动nginx</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx.service</span><br></pre></td></tr></table></figure><p><strong>4、设置nginx为开机启动</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> nginx.service</span><br></pre></td></tr></table></figure><h2 id="三、安装-MySQL"><a href="#三、安装-MySQL" class="headerlink" title="三、安装 MySQL"></a>三、安装 MySQL</h2><p><strong>1、安装mysql官方源</strong></p><p>注意 CentOS 7 默认 mysql 版本过低，这里我们采用 mysql 官方发行的 MySQL57 源,当然，也可以安装MySQL80的源。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://repo.mysql.com/mysql57-community-release-el7.rpm</span><br><span class="line">rpm -ivh mysql57-community-release-el7.rpm</span><br></pre></td></tr></table></figure><p><strong>2、建立 Yum 缓存</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><p><strong>3、安装mysql包</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y mysql mysql-server</span><br></pre></td></tr></table></figure><p><strong>4、启动mysql</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld.service</span><br></pre></td></tr></table></figure><p><strong>5、设置mysql为开机启动</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> mysqld.service</span><br></pre></td></tr></table></figure><p><strong>6、mysql 配置</strong></p><p>默认安装结束，mysql的root密码不为空，系统默认创建临时密码，执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&#x27;temporary password&#x27;</span> /var/log/mysqld.log</span><br></pre></td></tr></table></figure><p>可以看到密码，如例子</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-02-28T06:52:06.110216Z 1 [Note] A temporary password is generated <span class="keyword">for</span> root@localhost: **************</span><br></pre></td></tr></table></figure><p>后面<code>*</code>的位置就是临时密码，要手动修改mysql <code>root</code>账户密码，否则mysql会不允许创核表等操作，mysql 修改密码操作请自行搜索解决。</p><p>修改密码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -u root -p<span class="string">&#x27;&lt;初始密码&gt;&#x27;</span>  password <span class="string">&#x27;&lt;新密码&gt;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="四、安装-PHP"><a href="#四、安装-PHP" class="headerlink" title="四、安装 PHP"></a>四、安装 PHP</h2><blockquote><p>参考：<a href="https://www.myfreax.com/install-php-7-on-centos-7/">https://www.myfreax.com/install-php-7-on-centos-7/</a></p></blockquote><p><strong>1、安装php源</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release yum-utils</span><br><span class="line">yum install -y http://rpms.remirepo.net/enterprise/remi-release-7.rpm</span><br></pre></td></tr></table></figure><p><strong>2、启用 73 版本</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --<span class="built_in">enable</span> remi-php73</span><br></pre></td></tr></table></figure><p><strong>3、安装php包</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上一步源中，可供安装的php版本有很多，本文安装的php73</span></span><br><span class="line">yum install -y \</span><br><span class="line">  php \</span><br><span class="line">  php-cli \</span><br><span class="line">  php-common \</span><br><span class="line">  php-fpm \</span><br><span class="line">  php-gd \</span><br><span class="line">  php-mbstring \</span><br><span class="line">  php-intl \</span><br><span class="line">  php-mcrypt \</span><br><span class="line">  php-mysql \</span><br><span class="line">  php-pdo \</span><br><span class="line">  php-xml</span><br></pre></td></tr></table></figure><p><strong>4、修改PHP配置</strong></p><p>编辑 php.ini , 将以下配置的值修改为1024M</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/php.ini</span><br><span class="line"></span><br><span class="line">post_max_size = 1024M</span><br><span class="line">memory_limit = 1024M</span><br><span class="line">upload_max_filesize = 1024M</span><br></pre></td></tr></table></figure><p><strong>5、启动php-fpm</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start php-fpm.service</span><br></pre></td></tr></table></figure><p><strong>6、设置fpm开机启动</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> php-fpm.service</span><br></pre></td></tr></table></figure><h2 id="五、上线-EduSoho"><a href="#五、上线-EduSoho" class="headerlink" title="五、上线 EduSoho"></a>五、上线 EduSoho</h2><p><strong>1、创建EduSoho数据库</strong></p><blockquote><p>这里创不创建无所谓，在浏览器访问的时候会自动创建。</p></blockquote><ul><li><p>登录mysql</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line"><span class="comment">#按照提示，如果设置了密码，请输入正确的密码，`Enter`键登录mysql；如果未设置密码，请直接`Enter`键登录mysql.</span></span><br></pre></td></tr></table></figure></li><li><p>创建数据库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE edusoho DEFAULT CHARACTER SET utf8;</span><br><span class="line">GRANT ALL PRIVILEGES ON `edusoho`.* TO <span class="string">&#x27;esuser&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;Zhurs@123&#x27;</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></li></ul><p><strong>2、下载解压EduSoho</strong></p><blockquote><p>资源包下载：<a href="http://www.edusoho.com/open/show">http://www.edusoho.com/open/show</a></p><p>安装文档：<a href="http://www.qiqiuyu.com/my/course/20">http://www.qiqiuyu.com/my/course/20</a></p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230524093931660.png" alt="image-20230524093931660"></p><p><strong>3、增加 EduSoho nginx 配置</strong></p><blockquote><p>注意1：教培版和企培版的项目包目录有些许不一样，稍微更改即可。</p><p>注意2：edusoho访问目录是edusoho&#x2F;web,只有在nginx或者Apache配置里面把根目录定位到web目录下，才不会出现奇怪的问题，否则就会出现图片不能显示或者文件无法上传的问题。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/edusoho.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意端口不要冲突</span></span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.example.com;</span><br><span class="line">    <span class="attribute">root</span> /var/www/edusoho/web;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/edusoho.access.log;</span><br><span class="line">    <span class="attribute">error_log</span> /var/log/nginx/edusoho.<span class="literal">error</span>.log;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span> app.php;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">@rewriteapp</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> <span class="variable">@rewriteapp</span> &#123;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> /app.php/<span class="variable">$1</span> <span class="literal">last</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> <span class="regexp">~ ^/udisk</span> &#123;</span><br><span class="line">        internal;</span><br><span class="line">        <span class="attribute">root</span> /var/www/edusoho/app/data/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> <span class="regexp">~ ^/(app|app_dev)\.php(/|$)</span> &#123;</span><br><span class="line">        <span class="attribute">fastcgi_pass</span>   <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">        <span class="attribute">fastcgi_split_path_info</span><span class="regexp"> ^(.+\.php)(/.*)$</span>;</span><br><span class="line">        <span class="attribute">include</span> fastcgi_params;</span><br><span class="line">        <span class="attribute">fastcgi_param</span>  SCRIPT_FILENAME    <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">        <span class="attribute">fastcgi_param</span>  HTTPS              <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">fastcgi_param</span> HTTP_X-Sendfile-Type X-Accel-Redirect;</span><br><span class="line">        <span class="attribute">fastcgi_param</span> HTTP_X-Accel-Mapping /udisk=/var/www/edusoho/app/data/udisk;</span><br><span class="line">        <span class="attribute">fastcgi_buffer_size</span> <span class="number">128k</span>;</span><br><span class="line">        <span class="attribute">fastcgi_buffers</span> <span class="number">8</span> <span class="number">128k</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> <span class="regexp">~* \.(jpg|jpeg|gif|png|ico|swf)$</span> &#123;</span><br><span class="line">        <span class="attribute">expires</span> <span class="number">3y</span>;</span><br><span class="line">        <span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">gzip</span> <span class="literal">off</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> <span class="regexp">~* \.(css|js)$</span> &#123;</span><br><span class="line">        <span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">expires</span> <span class="number">3y</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> <span class="regexp">~ ^/files/.*\.(php|php5)$</span> &#123;</span><br><span class="line">        <span class="attribute">deny</span> all;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">        <span class="attribute">fastcgi_pass</span>   <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">        <span class="attribute">fastcgi_split_path_info</span><span class="regexp"> ^(.+\.php)(/.*)$</span>;</span><br><span class="line">        <span class="attribute">fastcgi_param</span>  SCRIPT_FILENAME    <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">        <span class="attribute">fastcgi_param</span>  HTTPS              <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">include</span>        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、重启nginx服务</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx.service</span><br></pre></td></tr></table></figure><h2 id="六、验证"><a href="#六、验证" class="headerlink" title="六、验证"></a>六、验证</h2><p>本地浏览器访问：<a href="http://192.168.56.153/">http://192.168.56.153/</a></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>访问 <a href="http://192.168.56.153/">http://192.168.56.153/</a> 后，在预检查阶段显示 web 不可写：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230524004417917.png" alt="image-20230524004417917"></p><p>解决方案：对项目<code>edusoho</code>目录 777 权限即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 -R edusoho</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="built_in">chown</span> apache.apache -R edusoho</span><br></pre></td></tr></table></figure><p>完成后，再次点击上图的<code>重新检测按钮</code>即可！</p>]]></content>
      
      
      <categories>
          
          <category> Linux 服务器运维实战 </category>
          
          <category> 项目实战部署篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 推送(提交)时如何忽略某个文件或目录？</title>
      <link href="/posts/articles/e8e17be2.html"/>
      <url>/posts/articles/e8e17be2.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/improved-git-flow-2.png" alt="improved-git-flow-2"></p><p><strong>1、在工作目录下新建 <code>.gitignore</code> 文件</strong></p><blockquote><p>阿里云效 DevOps 实测！</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> .gitignore</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230511182631942.png" alt="image-20230511182631942"></p><p><strong>2、配置忽略规则（支持正则）</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略项目根目录下所有以 .a 结尾的文件</span></span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># lib.a 除外（也就是说，除了lib.a文件外，项目根目录下其他文件或目录均被忽略）</span></span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO（就是说如果其他目录下有同名的目录，那与下面指定的是没关系的）</span></span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略 build/ 目录下的所有文件（如果远程仓库也没有build目录，该目录也不会被推送，因为此时相当于空目录，空目录无法推送）</span></span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略项目根目录下的 doc 目录下的所有以 .txt 结尾的文件，但不包括 doc/server/*.txt</span></span><br><span class="line">doc/*.txt</span><br></pre></td></tr></table></figure><p><code>.gitignore</code> 只能忽略那些原来没有被 <code>track</code> 的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。解决方法就是先把本地缓存删除（改变成未 <code>track</code> 状态），然后再提交。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> -r --cached .</span><br></pre></td></tr></table></figure><p>代码提交（根据自己分支提交即可）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;update .gitignore&#x27;</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.jianshu.com/p/854672c36692">https://www.jianshu.com/p/854672c36692</a></p><p>-–END</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 主从复制涉及到了几个线程？</title>
      <link href="/posts/articles/f4b248ff.html"/>
      <url>/posts/articles/f4b248ff.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/ms-mysql.png" alt="ms-mysql"></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说到主从，我相信大家在 MySQL 这一节面试经常被问到<code>MySQL 的主从复制原理</code>，而且大家背得滚瓜烂熟。但是在主从复制的过程中，是如何进程数据同步的，又涉及到了哪些线程呢？这些线程又是充当的什么角色呢？</p><p>首先，MySQL 有如下几种复制模式：</p><ul><li>主从复制模式：A - - &gt; B</li><li>主主复制模式：A &lt; - - &gt; B</li><li>链式复制模式：A - - &gt; B - - &gt; C</li><li>环形复制模式：A - - &gt; B - - &gt; C - - &gt; A</li></ul><p>生产环境中一般建议部署为<code>主从模式</code>，这也是比较稳健的一种 MySQL 复制方式，如果想实现一定程度上的高可用，可选择使用主主模式，但是主主模式必须确保任何一个时刻都只有一个数据库是 Active 状态（即读写状态），另一个数据库作为备用，否则就要解决<code>自增键/主键</code>的冲突问题。</p><h2 id="一、主从同步原理"><a href="#一、主从同步原理" class="headerlink" title="一、主从同步原理"></a>一、主从同步原理</h2><p>简单的主从复制基本原理如下：</p><ul><li>主库将更新写入二进制文件，并维护文件的一个索引来跟踪日志循环；</li><li>从库复制主库的二进制日志事件到本地的中继日志（relay log）；</li><li>从库重放中继日志实现与主库的数据同步。</li></ul><p>这里不进行深入的源码分析，有兴趣的自行查阅<a href="https://dev.mysql.com/doc/">官方文档</a>。</p><h2 id="二、主从同步分析"><a href="#二、主从同步分析" class="headerlink" title="二、主从同步分析"></a>二、主从同步分析</h2><p>MySQL 使用 3 个线程来实现同步（复制）功能，一个线程在主库上，另两个线程在从库上。</p><p>当从库执行 <code>start slave</code>指令时，从库将创建一个 I&#x2F;O 线程，该线程用于连接主库并让主库发送记录在其二进制日志（主库二进制日志）中的语句。此时，主库会创建一个线程将其二进制日志的内容发送到从库，如下图，就是其创建的线程，有两个线程，是因为我的 MySQL 复制是双主双从架构（关于如何部署双主，可看看我前面的博文<a href="https://blog.rabcnops.cn/posts/articles/96e13b9f.html">《基于 Docker 的 MySQL GTID 主从复制与测试》</a>），下图是在某个一个主库上查询的，因此它有两个从库，所有就会生成两个 Binlog Dump 线程，该线程会发送更新的二进制内容到从库，并等待新的二进制日志更新，有更新就会推送。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show processlist\G</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230505182639729.png" alt="image-20230505182639729"></p><p>然后从库的 I&#x2F;O 线程读取主库 Binlog Dump 线程发送的内容并将读取的数据存储到从库的中继日志文件中，最后从库的 SQL 线程会将中继日志中的事件重演并最终落盘。I&#x2F;O 线程与 SQL 线程位于从库上，如下图：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230508095040342.png" alt="image-20230508095040342"></p><p>而且要确保这两个线程均处于 <code>Yes</code> 状态，才能实现主从复制。</p><p><mark>以上就是 MySQL 主从复制过程涉及到的三个线程！</mark></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 关系型数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 Docker 的 MySQL GTID 主从复制与测试</title>
      <link href="/posts/articles/96e13b9f.html"/>
      <url>/posts/articles/96e13b9f.html</url>
      
        <content type="html"><![CDATA[<h1 id="基于-Docker-的-MySQL-GTID-主从复制与测试"><a href="#基于-Docker-的-MySQL-GTID-主从复制与测试" class="headerlink" title="基于 Docker 的 MySQL GTID 主从复制与测试"></a><center>基于 Docker 的 MySQL GTID 主从复制与测试</center></h1><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/ms-mysql.png" alt="ms-mysql"></p><hr><h2 id="一、规划"><a href="#一、规划" class="headerlink" title="一、规划"></a>一、规划</h2><h3 id="1-1-基础环境"><a href="#1-1-基础环境" class="headerlink" title="1.1 基础环境"></a>1.1 基础环境</h3><p>1、服务器环境</p><ul><li><p>Linux：CentOS 7.9</p></li><li><p>Docker：23.0.4</p></li><li><p>Docker-compose：2.7.0</p></li><li><p>Sysbench：1.0.20</p></li></ul><p>2、服务&#x2F;应用</p><ul><li>MySQL：8.0.33</li></ul><h3 id="1-2-应用架构"><a href="#1-2-应用架构" class="headerlink" title="1.2 应用架构"></a>1.2 应用架构</h3><blockquote><p>复制：双主双从，实现主从复制、主主复制；</p><p>读写：master 实例具备<code>读写权限</code>，slave 实例具备<code>只读权限</code>。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/M-S.png" alt="M-S"></p><h3 id="1-3-路径规划"><a href="#1-3-路径规划" class="headerlink" title="1.3 路径规划"></a>1.3 路径规划</h3><blockquote><p>数据持久化管理。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">├── master1</span><br><span class="line">│   ├── conf</span><br><span class="line">│   ├── data</span><br><span class="line">│   └── logs</span><br><span class="line">├── master2</span><br><span class="line">│   ├── conf</span><br><span class="line">│   ├── data</span><br><span class="line">│   └── logs</span><br><span class="line">├── slave1</span><br><span class="line">│   ├── conf</span><br><span class="line">│   ├── data</span><br><span class="line">│   └── logs</span><br><span class="line">└── slave2</span><br><span class="line">    ├── conf</span><br><span class="line">    ├── data</span><br><span class="line">    └── logs</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230429181901803.png" alt="image-20230429181901803"></p><h2 id="二、部署"><a href="#二、部署" class="headerlink" title="二、部署"></a>二、部署</h2><h3 id="2-1-服务部署"><a href="#2-1-服务部署" class="headerlink" title="2.1 服务部署"></a>2.1 服务部署</h3><p>1、安装 docker 服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://csdn-rab.oss-cn-chengdu.aliyuncs.com/shellscript/docker_install.sh | bash</span><br></pre></td></tr></table></figure><p>2、安装 docker-compse 编排工具</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://rab-package.oss-cn-hangzhou.aliyuncs.com/binary/el7/docker-compose/2.7.0/docker-compose-linux-x86_64</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x docker-compose-linux-x86_64 &amp;&amp; <span class="built_in">mv</span> docker-compose-linux-x86_64 /usr/bin/docker-compose</span><br></pre></td></tr></table></figure><p>3、安装 MySQL 服务</p><blockquote><p>使用 Docker-compose 进行编排。</p></blockquote><ul><li><p>创建持久化目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /root/mysql_install/&#123;master1/&#123;data,logs,conf&#125;,master2/&#123;data,logs,conf&#125;,slave1/&#123;data,logs,conf&#125;,slave2/&#123;data,logs,conf&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改权限</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> -R 777 /root/mysql_install/&#123;master1/&#123;data,logs&#125;,master2/&#123;data,logs&#125;,slave1/&#123;data,logs&#125;,slave2/&#123;data,logs&#125;&#125;</span><br></pre></td></tr></table></figure><p>临时测试-删除</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf /root/mysql_install/&#123;master1/&#123;data/*,logs/*&#125;,master2/&#123;data/*,logs/*&#125;,slave1/&#123;data/*,logs/*&#125;,slave2/&#123;data/*,logs/*&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>分别上传配置文件（my.cnf）至 conf 目录下</p><blockquote><p>Master1 配置文件（server-id 为1，其他不变）</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">port = 3306</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># innodb_force_recovery = 6  # 数据恢复参数，在数据表结构异常时使用（缺省值为0）</span></span><br><span class="line">port = 3306</span><br><span class="line">datadir         = /var/lib/mysql</span><br><span class="line">log-error       = /var/log/mysql/error.log</span><br><span class="line">innodb-data-file-path = /var/lib/mysql/ibdata1:1G;/var/lib/mysql/ibdata2:1G;/var/lib/mysql/ibdata3:1G</span><br><span class="line"></span><br><span class="line"><span class="comment"># Disabling symbolic-links is recommended to prevent assorted security risks</span></span><br><span class="line">symbolic-links = 0</span><br><span class="line">max_connections = 2000</span><br><span class="line">max_user_connections = 1900</span><br><span class="line">max_connect_errors = 100000</span><br><span class="line">max_allowed_packet = 50M</span><br><span class="line">lower_case_table_names = 1</span><br><span class="line">default-time_zone = <span class="string">&#x27;+8:00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1055异常处理</span></span><br><span class="line">sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</span><br><span class="line"></span><br><span class="line"><span class="comment"># GTID及二进制日志</span></span><br><span class="line">server-id = 1</span><br><span class="line">gtid_mode = on</span><br><span class="line">enforce_gtid_consistency = on</span><br><span class="line">master-info-repository = TABLE</span><br><span class="line">relay-log-info-repository = TABLE</span><br><span class="line"><span class="comment"># 设置binlog日志</span></span><br><span class="line">log-bin = /var/log/mysql/mysql-binlog</span><br><span class="line"><span class="comment"># 为每个session分配的内存，在事务过程中用来存储二进制日志的缓存</span></span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line"><span class="comment"># 主从复制的格式（mixed,statement,row，默认格式是statement）官方推荐在使用GTID情况下，基于行复制</span></span><br><span class="line">binlog_format=row</span><br><span class="line"><span class="comment"># 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。</span></span><br><span class="line">expire_logs_days=7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不需要同步的数据库</span></span><br><span class="line">binlog-ignore-db = mysql</span><br><span class="line">binlog_ignore_db = information_schema</span><br><span class="line">binlog_ignore_db = performation_schema</span><br><span class="line">binlog_ignore_db = sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql_native_password</span></span><br><span class="line">default_authentication_plugin = <span class="string">&#x27;mysql_native_password&#x27;</span></span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">skip-name-resolve</span><br></pre></td></tr></table></figure><blockquote><p>Master2 配置文件（server-id 为2，其他不变）</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">port = 3306</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># innodb_force_recovery = 6  # 数据恢复参数，在数据表结构异常时使用（缺省值为0）</span></span><br><span class="line">port = 3306</span><br><span class="line">datadir         = /var/lib/mysql</span><br><span class="line">log-error       = /var/log/mysql/error.log</span><br><span class="line">innodb-data-file-path = /var/lib/mysql/ibdata1:1G;/var/lib/mysql/ibdata2:1G;/var/lib/mysql/ibdata3:1G</span><br><span class="line"></span><br><span class="line"><span class="comment"># Disabling symbolic-links is recommended to prevent assorted security risks</span></span><br><span class="line">symbolic-links = 0</span><br><span class="line">max_connections = 2000</span><br><span class="line">max_user_connections = 1900</span><br><span class="line">max_connect_errors = 100000</span><br><span class="line">max_allowed_packet = 50M</span><br><span class="line">lower_case_table_names = 1</span><br><span class="line">default-time_zone = <span class="string">&#x27;+8:00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1055异常处理</span></span><br><span class="line">sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</span><br><span class="line"></span><br><span class="line"><span class="comment"># GTID及二进制日志</span></span><br><span class="line">server-id = 2</span><br><span class="line">gtid_mode = on</span><br><span class="line">enforce_gtid_consistency = on</span><br><span class="line">master-info-repository = TABLE</span><br><span class="line">relay-log-info-repository = TABLE</span><br><span class="line"><span class="comment"># 设置binlog日志</span></span><br><span class="line">log-bin = /var/log/mysql/mysql-binlog</span><br><span class="line"><span class="comment"># 为每个session分配的内存，在事务过程中用来存储二进制日志的缓存</span></span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line"><span class="comment"># 主从复制的格式（mixed,statement,row，默认格式是statement）官方推荐在使用GTID情况下，基于行复制</span></span><br><span class="line">binlog_format=row</span><br><span class="line"><span class="comment"># 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。</span></span><br><span class="line">expire_logs_days=7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不需要同步的数据库</span></span><br><span class="line">binlog-ignore-db = mysql</span><br><span class="line">binlog_ignore_db = information_schema</span><br><span class="line">binlog_ignore_db = performation_schema</span><br><span class="line">binlog_ignore_db = sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql_native_password</span></span><br><span class="line">default_authentication_plugin = <span class="string">&#x27;mysql_native_password&#x27;</span></span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">skip-name-resolve</span><br></pre></td></tr></table></figure><blockquote><p>Slave1 配置文件（server-id 为3，其他不变）</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">port = 3306</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># innodb_force_recovery = 6  # 数据恢复参数，在数据表结构异常时使用（缺省值为0）</span></span><br><span class="line">port = 3306</span><br><span class="line">datadir         = /var/lib/mysql</span><br><span class="line">log-error       = /var/log/mysql/error.log</span><br><span class="line">innodb-data-file-path = /var/lib/mysql/ibdata1:1G;/var/lib/mysql/ibdata2:1G;/var/lib/mysql/ibdata3:1G</span><br><span class="line"></span><br><span class="line"><span class="comment"># Disabling symbolic-links is recommended to prevent assorted security risks</span></span><br><span class="line">symbolic-links = 0</span><br><span class="line">max_connections = 2000</span><br><span class="line">max_user_connections = 1900</span><br><span class="line">max_connect_errors = 100000</span><br><span class="line">max_allowed_packet = 50M</span><br><span class="line">lower_case_table_names = 1</span><br><span class="line">default-time_zone = <span class="string">&#x27;+8:00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1055异常处理</span></span><br><span class="line">sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</span><br><span class="line"></span><br><span class="line"><span class="comment"># GTID及二进制日志</span></span><br><span class="line">server-id = 3</span><br><span class="line">gtid_mode = on</span><br><span class="line">enforce_gtid_consistency = on</span><br><span class="line">master-info-repository = TABLE</span><br><span class="line">relay-log-info-repository = TABLE</span><br><span class="line"><span class="comment"># 设置binlog日志</span></span><br><span class="line">log-bin = /var/log/mysql/mysql-binlog</span><br><span class="line"><span class="comment"># 为每个session分配的内存，在事务过程中用来存储二进制日志的缓存</span></span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line"><span class="comment"># 主从复制的格式（mixed,statement,row，默认格式是statement）官方推荐在使用GTID情况下，基于行复制</span></span><br><span class="line">binlog_format=row</span><br><span class="line"><span class="comment"># 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。</span></span><br><span class="line">expire_logs_days=7</span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql_native_password</span></span><br><span class="line">default_authentication_plugin = <span class="string">&#x27;mysql_native_password&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># slave实例设置为只读</span></span><br><span class="line">read_only = on</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">skip-name-resolve</span><br></pre></td></tr></table></figure><blockquote><p>Slave2 配置文件（server-id 为4，其他不变）</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">port = 3306</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># innodb_force_recovery = 6  # 数据恢复参数，在数据表结构异常时使用（缺省值为0）</span></span><br><span class="line">port = 3306</span><br><span class="line">datadir         = /var/lib/mysql</span><br><span class="line">log-error       = /var/log/mysql/error.log</span><br><span class="line">innodb-data-file-path = /var/lib/mysql/ibdata1:1G;/var/lib/mysql/ibdata2:1G;/var/lib/mysql/ibdata3:1G</span><br><span class="line"></span><br><span class="line"><span class="comment"># Disabling symbolic-links is recommended to prevent assorted security risks</span></span><br><span class="line">symbolic-links = 0</span><br><span class="line">max_connections = 2000</span><br><span class="line">max_user_connections = 1900</span><br><span class="line">max_connect_errors = 100000</span><br><span class="line">max_allowed_packet = 50M</span><br><span class="line">lower_case_table_names = 1</span><br><span class="line">default-time_zone = <span class="string">&#x27;+8:00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1055异常处理</span></span><br><span class="line">sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</span><br><span class="line"></span><br><span class="line"><span class="comment"># GTID及二进制日志</span></span><br><span class="line">server-id = 3</span><br><span class="line">gtid_mode = on</span><br><span class="line">enforce_gtid_consistency = on</span><br><span class="line">master-info-repository = TABLE</span><br><span class="line">relay-log-info-repository = TABLE</span><br><span class="line"><span class="comment"># 设置binlog日志</span></span><br><span class="line">log-bin = /var/log/mysql/mysql-binlog</span><br><span class="line"><span class="comment"># 为每个session分配的内存，在事务过程中用来存储二进制日志的缓存</span></span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line"><span class="comment"># 主从复制的格式（mixed,statement,row，默认格式是statement）官方推荐在使用GTID情况下，基于行复制</span></span><br><span class="line">binlog_format=row</span><br><span class="line"><span class="comment"># 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。</span></span><br><span class="line">expire_logs_days=7</span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql_native_password</span></span><br><span class="line">default_authentication_plugin = <span class="string">&#x27;mysql_native_password&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># slave实例设置为只读</span></span><br><span class="line">read_only = on</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">skip-name-resolve</span><br></pre></td></tr></table></figure></li><li><p>编写 docker-compose 文件</p><blockquote><p>指定 IP 时，注意不要与原网段重复，否则将创建失败！</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  master1:</span><br><span class="line">    image: mysql:8.0.33</span><br><span class="line">    container_name: master1</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 33061:3306</span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_ROOT_PASSWORD=Zhurs@123!</span><br><span class="line">    volumes:</span><br><span class="line">      - /root/mysql_install/master1/conf:/etc/mysql/conf.d</span><br><span class="line">      - /root/mysql_install/master1/logs:/var/log/mysql</span><br><span class="line">      - /root/mysql_install/master1/data:/var/lib/mysql</span><br><span class="line">    networks:</span><br><span class="line">      mysql-network:</span><br><span class="line">        ipv4_address: 172.31.1.11</span><br><span class="line">  master2:</span><br><span class="line">    image: mysql:8.0.33</span><br><span class="line">    container_name: master2</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 33062:3306</span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_ROOT_PASSWORD=Zhurs@123!</span><br><span class="line">    volumes:</span><br><span class="line">      - /root/mysql_install/master2/conf:/etc/mysql/conf.d</span><br><span class="line">      - /root/mysql_install/master2/logs:/var/log/mysql</span><br><span class="line">      - /root/mysql_install/master2/data:/var/lib/mysql</span><br><span class="line">    networks:</span><br><span class="line">      mysql-network:</span><br><span class="line">        ipv4_address: 172.31.1.12</span><br><span class="line">  slave1:</span><br><span class="line">    image: mysql:8.0.33</span><br><span class="line">    container_name: slave1</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 33063:3306</span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_ROOT_PASSWORD=Zhurs@123!</span><br><span class="line">    volumes:</span><br><span class="line">      - /root/mysql_install/slave1/conf:/etc/mysql/conf.d</span><br><span class="line">      - /root/mysql_install/slave1/logs:/var/log/mysql</span><br><span class="line">      - /root/mysql_install/slave1/data:/var/lib/mysql</span><br><span class="line">    networks:</span><br><span class="line">      mysql-network:</span><br><span class="line">        ipv4_address: 172.31.1.13</span><br><span class="line">  slave2:</span><br><span class="line">    image: mysql:8.0.33</span><br><span class="line">    container_name: slave2</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 33064:3306</span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_ROOT_PASSWORD=Zhurs@123!</span><br><span class="line">    volumes:</span><br><span class="line">      - /root/mysql_install/slave2/conf:/etc/mysql/conf.d</span><br><span class="line">      - /root/mysql_install/slave2/logs:/var/log/mysql</span><br><span class="line">      - /root/mysql_install/slave2/data:/var/lib/mysql</span><br><span class="line">    networks:</span><br><span class="line">      mysql-network:</span><br><span class="line">        ipv4_address: 172.31.1.14</span><br><span class="line">      </span><br><span class="line">networks:</span><br><span class="line">  mysql-network:</span><br><span class="line">    driver: bridge</span><br><span class="line">    ipam:</span><br><span class="line">      driver: default</span><br><span class="line">      config:</span><br><span class="line">        - subnet: 172.31.1.0/24</span><br><span class="line">          gateway: 172.31.1.1</span><br></pre></td></tr></table></figure></li><li><p>运行 MySQL 服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><blockquote><p>查看容器是否正常运行。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230502225451248.png" alt="image-20230502225451248"></p></li></ul><h3 id="2-2-主从配置"><a href="#2-2-主从配置" class="headerlink" title="2.2 主从配置"></a>2.2 主从配置</h3><h4 id="2-2-1-主从同步配置"><a href="#2-2-1-主从同步配置" class="headerlink" title="2.2.1 主从同步配置"></a>2.2.1 主从同步配置</h4><p>1、配置 <code>master1 - - &gt; slave1</code> 主从</p><ul><li><p>master1 实例创建主从同步账号</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入master1容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it master1 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录MySQL</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line"><span class="comment"># 注意：MySql8有新的安全要求，不能像之前的版本那样一次性创建用户并授权需要先创建用户，再进行授权操作</span></span><br><span class="line">create user <span class="string">&#x27;repl_master1&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&#x27;zhurs@123.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权（主从同步权限即可）</span></span><br><span class="line"><span class="comment"># replication slave权限：拥有此权限可以查看从服务器，从主服务器读取二进制日志。</span></span><br><span class="line"><span class="comment"># super权限：允许用户使用修改全局变量的SET语句以及CHANGE（属于MASTER语句）</span></span><br><span class="line"><span class="comment"># reload权限：必须拥有reload权限，才可以执行flush  [tables | logs | privileges]</span></span><br><span class="line">grant replication  slave,reload,super on *.* to <span class="string">&#x27;repl_master1&#x27;</span>@<span class="string">&#x27;%&#x27;</span> with grant option;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新授权</span></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></li><li><p>slave1 实例进行同步</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入slave1容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it slave1 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录MySQL</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接master1主库</span></span><br><span class="line">CHANGE MASTER TO master_host=<span class="string">&#x27;172.31.1.11&#x27;</span>, master_port=3306, master_user=<span class="string">&#x27;repl_master1&#x27;</span>, master_password=<span class="string">&#x27;zhurs@123.com&#x27;</span>, master_auto_position=1;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动slave连接</span></span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure></li><li><p>查看同步状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status\G</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503000000879.png" alt="image-20230503000000879"></p></li></ul><p>2、配置 <code>master2 - - &gt; slave2</code> 主从</p><ul><li><p>master2 实例创建主从同步账号</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入master2容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it master2 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录MySQL</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line"><span class="comment"># 注意：MySql8有新的安全要求，不能像之前的版本那样一次性创建用户并授权需要先创建用户，再进行授权操作</span></span><br><span class="line">create user <span class="string">&#x27;repl_master2&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&#x27;zhurs@123.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权（主从同步权限即可）</span></span><br><span class="line"><span class="comment"># replication slave权限：拥有此权限可以查看从服务器，从主服务器读取二进制日志。</span></span><br><span class="line"><span class="comment"># super权限：允许用户使用修改全局变量的SET语句以及CHANGE（属于MASTER语句）</span></span><br><span class="line"><span class="comment"># reload权限：必须拥有reload权限，才可以执行flush  [tables | logs | privileges]</span></span><br><span class="line">grant replication  slave,reload,super on *.* to <span class="string">&#x27;repl_master2&#x27;</span>@<span class="string">&#x27;%&#x27;</span> with grant option;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新授权</span></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></li><li><p>slave2 实例进行同步</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入slave2容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it slave2 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录MySQL</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接master2主库</span></span><br><span class="line">CHANGE MASTER TO master_host=<span class="string">&#x27;172.31.1.12&#x27;</span>, master_port=3306, master_user=<span class="string">&#x27;repl_master2&#x27;</span>, master_password=<span class="string">&#x27;zhurs@123.com&#x27;</span>, master_auto_position=1;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动slave连接</span></span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure></li><li><p>查看同步状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status\G</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503001352692.png" alt="image-20230503001352692"></p></li></ul><p><mark>至此，MySQL 的主从复制完成！接下来配置主主复制过程！</mark></p><h4 id="2-2-2-主主同步配置"><a href="#2-2-2-主主同步配置" class="headerlink" title="2.2.2 主主同步配置"></a>2.2.2 主主同步配置</h4><p>1、配置 <code>master1 - - &gt; master2</code> 主从</p><blockquote><p>master1 为主，master2 为从</p></blockquote><ul><li><p>master1 实例创建主从同步账号</p><blockquote><p>已经创建。</p></blockquote></li><li><p>master2 实例进行同步</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入slave1容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it master2 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录MySQL</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接master1主库</span></span><br><span class="line">CHANGE MASTER TO master_host=<span class="string">&#x27;172.31.1.11&#x27;</span>, master_port=3306, master_user=<span class="string">&#x27;repl_master1&#x27;</span>, master_password=<span class="string">&#x27;zhurs@123.com&#x27;</span>, master_auto_position=1;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动slave连接</span></span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure></li><li><p>查看同步状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status\G</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503001450209.png" alt="image-20230503001450209"></p></li></ul><p>2、配置 <code>master2 - - &gt; master1</code> 主从</p><blockquote><p>master2 为主，master1 为从</p></blockquote><ul><li><p>master2 实例创建主从同步账号</p><blockquote><p>已经创建。</p></blockquote></li><li><p>master1 实例进行同步</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入slave1容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it master1 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录MySQL</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接master1主库</span></span><br><span class="line">CHANGE MASTER TO master_host=<span class="string">&#x27;172.31.1.12&#x27;</span>, master_port=3306, master_user=<span class="string">&#x27;repl_master2&#x27;</span>, master_password=<span class="string">&#x27;zhurs@123.com&#x27;</span>, master_auto_position=1;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动slave连接</span></span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure></li><li><p>查看同步状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status\G</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503001757491.png" alt="image-20230503001757491"></p></li></ul><p><mark>至此，主从复制、主主复制结束！</mark></p><blockquote><p><strong>注</strong>：在配置 SLAVE 同步时</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先停止数据同步相关的线程： slave I/O 线程和 slave SQL 线程</span></span><br><span class="line">STOP SLAVE;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了避免可能发生的错误，直接重置客户端</span></span><br><span class="line">RESET  SLAVE;</span><br></pre></td></tr></table></figure><h3 id="2-3-主从验证"><a href="#2-3-主从验证" class="headerlink" title="2.3 主从验证"></a>2.3 主从验证</h3><h4 id="2-3-1-主从同步验证"><a href="#2-3-1-主从同步验证" class="headerlink" title="2.3.1 主从同步验证"></a>2.3.1 主从同步验证</h4><p>1、master1 创建测试数据库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database <span class="keyword">if</span> not exists master1 default charset utf8 collate utf8_general_ci;</span><br></pre></td></tr></table></figure><p>2、slave1 验证是否同步</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如下图，已经同步</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503002355116.png" alt="image-20230503002355116"></p><h4 id="2-3-2-主主同步验证"><a href="#2-3-2-主主同步验证" class="headerlink" title="2.3.2 主主同步验证"></a>2.3.2 主主同步验证</h4><p>此时，master2、slave2 也都有名为 <code>master1</code> 的测试数据库，因为 master2 与 master1 互为主从，而 slave2 又是 master2 的从库。</p><p>因此得出结论，这种数据库架构下，只要你在任意一 master 节点上创建数据库，每个 MySQL 实例都会实现数据同步。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503002458446.png" alt="image-20230503002458446"></p><h3 id="2-4-客户端连接"><a href="#2-4-客户端连接" class="headerlink" title="2.4 客户端连接"></a>2.4 客户端连接</h3><h4 id="2-4-1-控制台"><a href="#2-4-1-控制台" class="headerlink" title="2.4.1 控制台"></a>2.4.1 控制台</h4><blockquote><p>需安装MySQL客户端命令（mysql）。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -pZhurs@123! -h 192.168.56.120 -P 33061</span><br></pre></td></tr></table></figure><h4 id="2-4-2-图形化"><a href="#2-4-2-图形化" class="headerlink" title="2.4.2 图形化"></a>2.4.2 图形化</h4><blockquote><p>如 client 通过 navicat 客户端软件连接 master 节点（只需要连接其中之一即可），或以 VIP 的方式连接（配置 keepalived 实现 master 节点高可用），由于在单台 Host 虚拟机下运行的多 MySQL 实例，就无法做高可用演示，生产中至少两台 master 的 Host 节点来实现高可用。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503003905267.png" alt="image-20230503003905267"></p><p><strong>查看数据库：</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503003945019.png" alt="image-20230503003945019"></p><p><mark>至此，主从复制 + 主主复制 + 客户端连接已经配置完毕！</mark></p><h2 id="三、压测"><a href="#三、压测" class="headerlink" title="三、压测"></a>三、压测</h2><blockquote><p>测试：主从读写性能。</p><p>工具：<code>sysbench</code></p></blockquote><h3 id="3-1-安装-sysbench"><a href="#3-1-安装-sysbench" class="headerlink" title="3.1 安装 sysbench"></a>3.1 安装 sysbench</h3><p>1、执行脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://packagecloud.io/install/repositories/akopytov/sysbench/script.rpm.sh | sudo bash</span><br></pre></td></tr></table></figure><p>2、开始安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y install sysbench</span><br></pre></td></tr></table></figure><p>3、验证</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysbench --version</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503213303900.png" alt="image-20230503213303900"></p><h3 id="3-2-sysbench-压测"><a href="#3-2-sysbench-压测" class="headerlink" title="3.2 sysbench 压测"></a>3.2 sysbench 压测</h3><blockquote><p>由于我的系统主机资源有限，因此就简单的 10 张表、每张表 1千条数据进行 5 分钟压测</p><p>参考：<a href="https://help.aliyun.com/document_detail/146103.html">https://help.aliyun.com/document_detail/146103.html</a></p></blockquote><h4 id="3-2-1-读性能"><a href="#3-2-1-读性能" class="headerlink" title="3.2.1  读性能"></a>3.2.1  读性能</h4><p>1、准备数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sysbench \</span><br><span class="line">  --db-driver=mysql \</span><br><span class="line">  --mysql-host=192.168.56.120 \</span><br><span class="line">  --mysql-port=33061 \</span><br><span class="line">  --mysql-user=root \</span><br><span class="line">  --mysql-password=Zhurs@123! \</span><br><span class="line">  --mysql-db=master1 \</span><br><span class="line">  --table_size=1000 \</span><br><span class="line">  --tables=10 \</span><br><span class="line">  --events=0 \</span><br><span class="line">  --time=300  oltp_read_only prepare</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 说明：</span></span><br><span class="line"><span class="comment"># --table_size：表记录数</span></span><br><span class="line"><span class="comment"># --tables：表数量</span></span><br></pre></td></tr></table></figure><blockquote><p>执行完毕后，来查看数据库。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503223241087.png" alt="image-20230503223241087"></p><p>2、运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sysbench \</span><br><span class="line">  --db-driver=mysql \</span><br><span class="line">  --mysql-host=192.168.56.120 \</span><br><span class="line">  --mysql-port=33061 \</span><br><span class="line">  --mysql-user=root \</span><br><span class="line">  --mysql-password=Zhurs@123! \</span><br><span class="line">  --mysql-db=master1 \</span><br><span class="line">  --table_size=1000 \</span><br><span class="line">  --tables=10 \</span><br><span class="line">  --events=0 \</span><br><span class="line">  --time=300 \</span><br><span class="line">  --threads=5 \</span><br><span class="line">  --percentile=95 \</span><br><span class="line">  --range_selects=0 \</span><br><span class="line">  --skip-trx=1 \</span><br><span class="line">  --report-interval=1 oltp_read_only run</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 说明：</span></span><br><span class="line"><span class="comment"># --threads：并发线程数，可以理解为模拟的客户端并发连接数</span></span><br><span class="line"><span class="comment"># --skip-trx：省略begin/commit语句。默认是off</span></span><br></pre></td></tr></table></figure><p>**执行结果：**从中可看出每秒查询，每秒事务等执行结果。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503224520488.png" alt="image-20230503224520488"></p><p>除此之外，Host 系统的平均负载也在升高：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503225222279.png" alt="image-20230503225222279"></p><p>3、清理</p><blockquote><p>测试完成后清理数据，释放空间</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sysbench \</span><br><span class="line">  --db-driver=mysql \</span><br><span class="line">  --mysql-host=192.168.56.120 \</span><br><span class="line">  --mysql-port=33061 \</span><br><span class="line">  --mysql-user=root \</span><br><span class="line">  --mysql-password=Zhurs@123! \</span><br><span class="line">  --mysql-db=master1 \</span><br><span class="line">  --table_size=1000 \</span><br><span class="line">  --tables=10 \</span><br><span class="line">  --events=0 \</span><br><span class="line">  --time=300   \</span><br><span class="line">  --threads=5 \</span><br><span class="line">  --percentile=95 \</span><br><span class="line">  --range_selects=0 oltp_read_only cleanup</span><br></pre></td></tr></table></figure><h4 id="3-2-2-写性能"><a href="#3-2-2-写性能" class="headerlink" title="3.2.2 写性能"></a>3.2.2 写性能</h4><p>1、准备数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sysbench \</span><br><span class="line">  --db-driver=mysql \</span><br><span class="line">  --mysql-host=192.168.56.120 \</span><br><span class="line">  --mysql-port=33061 \</span><br><span class="line">  --mysql-user=root \</span><br><span class="line">  --mysql-password=Zhurs@123! \</span><br><span class="line">  --mysql-db=master1 \</span><br><span class="line">  --table_size=1000 \</span><br><span class="line">  --tables=10 \</span><br><span class="line">  --events=0 \</span><br><span class="line">  --time=300  oltp_write_only prepare</span><br></pre></td></tr></table></figure><p>2、运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sysbench \</span><br><span class="line">  --db-driver=mysql \</span><br><span class="line">  --mysql-host=192.168.56.120 \</span><br><span class="line">  --mysql-port=33061 \</span><br><span class="line">  --mysql-user=root \</span><br><span class="line">  --mysql-password=Zhurs@123! \</span><br><span class="line">  --mysql-db=master1 \</span><br><span class="line">  --table_size=1000 \</span><br><span class="line">  --tables=10 \</span><br><span class="line">  --events=0 \</span><br><span class="line">  --time=300 \</span><br><span class="line">  --threads=5 \</span><br><span class="line">  --percentile=95 \</span><br><span class="line">  --report-interval=1 oltp_write_only run</span><br></pre></td></tr></table></figure><p><strong>执行结果：</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503225733818.png" alt="image-20230503225733818"></p><p>3、清理</p><blockquote><p>测试完成后清理数据，释放空间</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sysbench \</span><br><span class="line">  --db-driver=mysql \</span><br><span class="line">  --mysql-host=192.168.56.120 \</span><br><span class="line">  --mysql-port=33061 \</span><br><span class="line">  --mysql-user=root \</span><br><span class="line">  --mysql-password=Zhurs@123! \</span><br><span class="line">  --mysql-db=master1 \</span><br><span class="line">  --table_size=1000 \</span><br><span class="line">  --tables=10 \</span><br><span class="line">  --events=0 \</span><br><span class="line">  --time=300 \</span><br><span class="line">  --threads=5 \</span><br><span class="line">  --percentile=95 oltp_write_only cleanup</span><br></pre></td></tr></table></figure><h4 id="3-2-3-读写性能"><a href="#3-2-3-读写性能" class="headerlink" title="3.2.3 读写性能"></a>3.2.3 读写性能</h4><p>1、准备数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sysbench \</span><br><span class="line">  --db-driver=mysql \</span><br><span class="line">  --mysql-host=192.168.56.120 \</span><br><span class="line">  --mysql-port=33061 \</span><br><span class="line">  --mysql-user=root \</span><br><span class="line">  --mysql-password=Zhurs@123! \</span><br><span class="line">  --mysql-db=master1 \</span><br><span class="line">  --table_size=1000 \</span><br><span class="line">  --tables=10 \</span><br><span class="line">  --events=0 \</span><br><span class="line">  --time=300 oltp_read_write prepare</span><br></pre></td></tr></table></figure><p>2、运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sysbench \</span><br><span class="line">  --db-driver=mysql  \</span><br><span class="line">  --mysql-host=192.168.56.120 \</span><br><span class="line">  --mysql-port=33061 \</span><br><span class="line">  --mysql-user=root \</span><br><span class="line">  --mysql-password=Zhurs@123! \</span><br><span class="line">  --mysql-db=master1 \</span><br><span class="line">  --table_size=1000 \</span><br><span class="line">  --tables=10 \</span><br><span class="line">  --events=0 \</span><br><span class="line">  --time=300 \</span><br><span class="line">  --threads=5 \</span><br><span class="line">  --percentile=95 \</span><br><span class="line">  --report-interval=1 oltp_read_write run</span><br></pre></td></tr></table></figure><p><strong>执行结果：</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503231502157.png" alt="image-20230503231502157"></p><p>3、清理</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sysbench \</span><br><span class="line">  --db-driver=mysql \</span><br><span class="line">  --mysql-host=192.168.56.120 \</span><br><span class="line">  --mysql-port=33061 \</span><br><span class="line">  --mysql-user=root \</span><br><span class="line">  --mysql-password=Zhurs@123! \</span><br><span class="line">  --mysql-db=master1 \</span><br><span class="line">  --table_size=1000 \</span><br><span class="line">  --tables=10 \</span><br><span class="line">  --events=0 \</span><br><span class="line">  --time=300 \</span><br><span class="line">  --threads=5 \</span><br><span class="line">  --percentile=95 oltp_read_write cleanup</span><br></pre></td></tr></table></figure><h4 id="3-2-4-主从复制延迟"><a href="#3-2-4-主从复制延迟" class="headerlink" title="3.2.4 主从复制延迟"></a>3.2.4 主从复制延迟</h4><p>以 10 张表，每张表 1000 条记录，读写压测 5 分钟的数据来看，主从复制的延迟在为 1s，不超过 2s（本次测试结果），如下图所示。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503225703898.png" alt="image-20230503225703898"></p><h2 id="四、扩展"><a href="#四、扩展" class="headerlink" title="四、扩展"></a>四、扩展</h2><h3 id="4-1-主从复制方式"><a href="#4-1-主从复制方式" class="headerlink" title="4.1 主从复制方式"></a>4.1 主从复制方式</h3><h4 id="4-1-1-异步复制（Asynchronous-replication）"><a href="#4-1-1-异步复制（Asynchronous-replication）" class="headerlink" title="4.1.1 异步复制（Asynchronous replication）"></a>4.1.1 异步复制（Asynchronous replication）</h4><p>MySQL 默认使用的是异步复制，官方解释如下：</p><p><code>the master writes events to its binary log and slaves request them when they are ready. There is no guarantee that any event will ever reach any slave.</code></p><p>即 master 服务器将事件写入其二进制日志，slave 服务器在事件准备好时请求事件。不能保证任何事件都会影响到任何一个 slave。</p><p><strong>说白了就是</strong>：主库只管把 events 写入 binlog 中，不管从库有没有收到。</p><h4 id="4-1-2-全同步复制（Fully-synchronous-replication）"><a href="#4-1-2-全同步复制（Fully-synchronous-replication）" class="headerlink" title="4.1.2 全同步复制（Fully synchronous replication）"></a>4.1.2 全同步复制（Fully synchronous replication）</h4><p>官方解释如下：</p><p><code>when a master commits a transaction, all slaves also will have committed the transaction before the master returns to the session that performed the transaction. The drawback of this is that there might be a lot of delay to complete a transaction.</code></p><p>即 master 服务器提交事务时，在 master 服务器返回到执行该事务的会话之前，所有 slave 服务器也将提交该事务。这样做的缺点是完成事务可能会有很多延迟。</p><p><strong>说白了就是</strong>：主库提交一个事物，需要等待所有从库先提交才能返回结果，执行这个事物。这样会造成一个事物延时。</p><h4 id="4-1-3-半同步复制（Semisynchronous-replication）"><a href="#4-1-3-半同步复制（Semisynchronous-replication）" class="headerlink" title="4.1.3 半同步复制（Semisynchronous replication）"></a>4.1.3 半同步复制（Semisynchronous replication）</h4><p>官方解释如下：</p><p><code>falls between asynchronous and fully synchronous replication. The master waits only until at least one slave has received and logged the events. It does not wait for all slaves to acknowledge receipt, and it requires only receipt, not that the events have been fully executed and committed on the slave side.</code></p><p>即介于异步复制和全同步复制之间。master 服务器只等待至少一个 slave 服务器接收并记录事件。它不等待所有从服务器确认接收，它只需要接收，而不需要在从服务器端完全执行和提交事件。</p><p><strong>说白了就是</strong>：介于异步复制和全复制之间，主库仅仅只要等待至少一个从库收到和记录 events。它不需要等待所有的从库告诉它收到events，也不需要从库执行和提交事物，从库只是收到 events 就会告诉主库，这样主库就可以提前提交事物了。</p><h3 id="4-2-GTID-与-Binary-Log"><a href="#4-2-GTID-与-Binary-Log" class="headerlink" title="4.2 GTID 与 Binary Log"></a>4.2 GTID 与 Binary Log</h3><p>1、GTID</p><p><code>MySQL GTID（Global Transaction ID）</code>是一种用于在复制环境中唯一标识事务的机制。GTID 能够在复制拓扑中帮助识别和跟踪每个事务的状态，从而更方便的进行数据同步和故障恢复。在 MySQL 5.6 版本及以上，可以使用 GTID 进行复制。</p><p>2、Binary Log</p><p><code>binlog（Binary Log）</code>是 MySQL 中的一种日志文件，用于记录对 MySQL 数据库进行的更改操作。它记录了所有的数据更改操作，包括对表的插入、更新和删除等操作。binlog 日志可以用于数据恢复、复制和备份等操作。</p><p>3、两者区别</p><ul><li>功能不同：GTID 用于唯一标识复制环境中的事务，而 binlog 用于记录数据库的更改操作。</li><li>数据结构不同：GTID 是由服务器生成的唯一标识符，用于标识每个事务。而 binlog 是一种二进制格式的日志文件，记录了每个事务的更改操作。</li><li>使用方式不同：GTID 用于在复制拓扑中标识和跟踪每个事务的状态，从而更方便地进行数据同步和故障恢复。而 binlog 可以用于数据恢复、复制和备份等操作。</li></ul><p><mark>需要注意的是</mark>：使用 GTID 进行复制需要 MySQL 5.6 及以上版本的支持。在 MySQL 5.5 及以下版本中，只能使用 binlog 进行数据复制和备份。本次使用的是基于 GTID 的主从复制。</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>MySQL 5.1.7 + 已经不支持 <code>“master-host”</code> 类似的参数。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503195146922.png" alt="image-20230503195146922"></p><p>因此 <code>docker-compose</code> 中就无法实现启动时主从同步（如下图 command 部分）：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503195256475.png" alt="image-20230503195256475"></p><p>所以，通过 docker-compose 运行主从时，需进入从库进行配置！</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 关系型数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 的 Protected Mode 解读</title>
      <link href="/posts/articles/e42dd192.html"/>
      <url>/posts/articles/e42dd192.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/redis-social-1200x628-1.webp" alt="redis-social-1200x628-1"></p><hr><p><strong>官方配置文件自带的注释：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Protected mode is a layer of security protection, <span class="keyword">in</span> order to avoid that Redis instances left open on the internet are accessed and exploited.</span><br><span class="line"></span><br><span class="line">When protected mode is on and <span class="keyword">if</span>:</span><br><span class="line"></span><br><span class="line">1) The server is not binding explicitly to a <span class="built_in">set</span> of addresses using the <span class="string">&quot;bind&quot;</span> directive.</span><br><span class="line">2) No password is configured.</span><br><span class="line"></span><br><span class="line">The server only accepts connections from clients connecting from the IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain sockets.</span><br><span class="line"></span><br><span class="line">By default protected mode is enabled. You should <span class="built_in">disable</span> it only <span class="keyword">if</span> you are sure you want clients from other hosts to connect to Redis even <span class="keyword">if</span> no authentication is configured, nor a specific <span class="built_in">set</span> of interfaces are explicitly listed using the <span class="string">&quot;bind&quot;</span> directive.</span><br></pre></td></tr></table></figure><p><strong>Google 的翻译结果：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">保护模式是一层安全保护，以避免在互联网上开放的 Redis 实例被访问和利用。</span><br><span class="line"></span><br><span class="line">当保护模式打开时，如果：</span><br><span class="line"></span><br><span class="line">1) 服务器未使用“<span class="built_in">bind</span>”指令显式绑定到一组地址。</span><br><span class="line">2) 没有配置密码。</span><br><span class="line"></span><br><span class="line">服务器只接受来自环回地址127.0.0.1（IPv4）和 ::1（IPv6）以及来自 Unix 域套接字的客户端的连接。</span><br><span class="line"></span><br><span class="line">默认情况下启用保护模式。仅当您确定希望来自其他主机的客户端连接到 Redis，即使没有配置身份验证，也没有使用“<span class="built_in">bind</span>”指令明确列出一组特定接口时，才应禁用它。</span><br></pre></td></tr></table></figure><p><mark>也就是说，会存在这两种情况：</mark></p><p><strong>1、当 <code>protected-mode yes</code></strong></p><ul><li><p><code># bind 192.168.56.120</code>     - - &gt;   注释</p></li><li><p><code># requirepass zhurs@123</code> - - &gt;   注释</p><blockquote><p>此时，redis 的保护模式生效；</p><p>客户端只能通过本地连接，即环回地址127.0.0.1（IPv4）和 ::1（IPv6）以及来自 Unix 域套接字的客户端的连接。</p></blockquote></li><li><p><code># bind 192.168.56.120</code>     - - &gt;   注释</p></li><li><p><code>requirepass zhurs@123</code></p><blockquote><p>此时，redis 的保护模式不生效（yes 或 no 都无影响）；</p><p>客户端可指定 <code>IP（192.168.56.120）+ 端口 + 密码</code>来连接 redis。</p></blockquote></li><li><p><code>bind 192.168.56.120</code></p></li><li><p><code># requirepass zhurs@123</code> - - &gt;   注释</p><blockquote><p>此时，redis 的保护模式不生效（yes 或 no 都无影响）；</p><p>客户端可指定 <code>IP（192.168.56.120）+ 端口</code>来连接 redis（此时无密码）。</p></blockquote></li><li><p><code>bind 192.168.56.120</code></p></li><li><p><code>requirepass zhurs@123</code></p><blockquote><p>此时，redis 的保护模式不生效（yes 或 no 都无影响）；</p><p>客户端可指定 <code>IP（192.168.56.120）+ 端口 + 密码</code>来连接 redis。</p></blockquote></li></ul><p><strong>2、当 <code>protected-mode no</code></strong></p><ul><li>无论上面的哪种场景，客户端都可以根据 <code>bind</code> 及 <code>requirepass</code> 实际参数来连接到 redis；</li><li>然后通过指定 <code>IP（192.168.56.120）</code> 或 <code>IP（192.168.56.120） + 端口</code>或<code>IP（192.168.56.120）+ 端口 + 密码</code>来连接 redis。</li></ul><p>—END</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 6.0+ 的 ACL 常用操作指令</title>
      <link href="/posts/articles/b4beeb2a.html"/>
      <url>/posts/articles/b4beeb2a.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/Screenshot-2022-09-28-135602.png" alt="Redis Encryption"></p><hr><p>关于 redis 6.0+ 的 ACL 机制与基本配置在<a href="https://blog.rabcnops.cn/posts/articles/464f6e46.html">《Redis 6.0+ 的 ACL 机制》</a>一文中已经有提到，现在列举一些与 ACL 相关常用的指令。</p><p><strong>1、查看当前登录用户</strong></p><blockquote><p>如果你是这样登录的，默认就是 default 用户：</p><p>redis-cli -p 7001</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL WHOAMI</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425144116317.png" alt="image-20230425144116317"></p><p><strong>2、创建用户</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acl setuser rab</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425121649936.png" alt="image-20230425121649936"></p><blockquote><p>不设置密码与权限，则默认没有密码没有任何权限，且用户处于未激活状态（off），此时用户不可登录。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425121933381.png" alt="image-20230425121933381"></p><p><strong>3、启用（激活）用户</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acl setuser rab on</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425122108069.png" alt="image-20230425122108069"></p><p><strong>4、给用户增加密码</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acl setuser rab on &gt;Zhurs@2023!</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425143800401.png" alt="image-20230425143800401"></p><p><strong>5、查看命令分类</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acl <span class="built_in">cat</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425152710868.png" alt="image-20230425152710868"></p><p>查看某个分类具体可以执行哪些命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acl <span class="built_in">cat</span> slow</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425152907538.png" alt="image-20230425152907538"></p><p><strong>6、给用户设置权限</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acl setuser rab on &gt;Zhurs@2023! ~* +@all</span><br><span class="line"></span><br><span class="line"><span class="comment"># rab 用户对所有的 key 具备所有权限</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425144500649.png" alt="image-20230425144500649"></p><blockquote><p>查看用户权限</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acl list</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425144615971.png" alt="image-20230425144615971"></p><blockquote><p>设置对指定 key 拥有指定的权限</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acl setuser rab on &gt;Zhurs@2023! ~dum* -@all +<span class="built_in">set</span> +get</span><br><span class="line"></span><br><span class="line"><span class="comment"># rab 用户对 dum 开头的 key 具备 set、get 权限</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425150207114.png" alt="image-20230425150207114"></p><p><strong>7、列出所有用户</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acl list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 入下图，共三个用户</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425150020060.png" alt="image-20230425150020060"></p><p><strong>8、删除用户</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acl deluser rab</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425145717048.png" alt="image-20230425145717048"></p><blockquote><p>再次查看用户列表，发现用户已经被删除。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425145749678.png" alt="image-20230425145749678"></p><p><mark>以上的设置，如创建用户、给用户授权等操作都是在命令行（终端执行），那我们如何持久化这些设置呢？通过外部 aclfile 文件来存储这些信息，具体操作如下，aclfile 如何配置？在前面的文章中有具体演示。</mark></p><p>比如，先创建一个用户并授权：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acl setuser tom on &gt;Zhurs@2023! ~* +@all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可见，下图中有4个用户</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425150754669.png" alt="image-20230425150754669"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acl sava</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425151005484.png" alt="image-20230425151005484"></p><p>最后去 aclfile 文件去查看是否有用户信息记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> users.acl</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425151203149.png" alt="image-20230425151203149"></p><p><strong>小结：</strong></p><ul><li>关于更多 ACL 命令，我们可以通过 ACL HELP 去查看；</li><li>acl 的持久化方式我们可以这样操作：<ul><li>登录集群，通过 acl save 指令来持久化；</li><li>直接在 aclfile 文件中添加用户相关信息（包括权限等）。</li></ul></li></ul><p>—END</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何理解 Linux 的 CPU 上下文切换？（连载）</title>
      <link href="/posts/articles/fe7524c5.html"/>
      <url>/posts/articles/fe7524c5.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/linux-protection-rings.jpg" alt="linux-protection-rings"></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇说到了 CPU 的上下文切换，以及各种场景下的上下文切换，如<code>进程上下文切换</code>、<code>线程上下文切换</code>、<code>中断上下文切换</code>。我们知道，过多的上下文切换，会把 CPU 时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，缩短进程真正运行的时间，造成系统性能大幅下降。那我们怎么查看操作系统上的 CPU 上下文切换情况呢？在这里，我们可以使用 vmstat 这个工具，来查询系统的上下文切换情况。</p><h2 id="一、查看系统上下文切换"><a href="#一、查看系统上下文切换" class="headerlink" title="一、查看系统上下文切换"></a>一、查看系统上下文切换</h2><h3 id="1-1-vmstat-基本使用"><a href="#1-1-vmstat-基本使用" class="headerlink" title="1.1 vmstat 基本使用"></a>1.1 vmstat 基本使用</h3><p>vmstat 是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vmstat 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没隔 5s 输出一组数据。</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230423141944922.png" alt="image-20230423141944922"></p><p>上图中的结果重点关注这几项：</p><ul><li><strong>cs（context switch）</strong>：每秒上下文切换的次数；</li><li><strong>in（interrupt）</strong>：每秒中断次数；</li><li><strong>r（running or runnable）</strong>：就绪队列长度（即正在运行和等待 CPU 的进程数）；</li><li><strong>b（blocked）</strong>：处于不可中断睡眠状态的进程数。</li></ul><p>可看见上图中第一条内容：上下文切换次数 cs 为 19 次，系统中断次数 in 为 12 次，就绪队列长度 r 为 1，不可中断睡眠进程数 b 为 0。</p><p>而上图中的结果只是给出了系统总体的上下文切换情况，如果想要每个进程的详细情况，可使用 <code>pidstat</code> 命令，如下。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pidstat -w 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没隔 5s 输出一组数据。</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230423143205743.png" alt="image-20230423143205743"></p><p>上图中的结果重点关注这两项：</p><ul><li><p>cswch：每秒自愿上下文切换次数；</p><p>指进程无法获取所需资源，导致的上下文切换。比如 I&#x2F;O、内存等系统资源不足时，就会发生自愿上下文切换。</p></li><li><p>nvcswch：秒非自愿上下文切换次数。</p><p>指进程由于时间片已到（即分配到的 CPU 时间使用完了），被系统强制调度，进而发生的上下文切换。比如，大量进程竞争 CPU 时，就容易发生非自愿上下文切换。</p></li></ul><h3 id="1-2-模拟多线程调度切换"><a href="#1-2-模拟多线程调度切换" class="headerlink" title="1.2 模拟多线程调度切换"></a>1.2 模拟多线程调度切换</h3><p>1、环境</p><p>使用 sysbench 来模拟系统多线程调度切换的情况。sysbench 是一个多线程的基准测试工具，一般用来评估不同系统参数下的数据库负载情况。当然，在这次案例中，我们只把它当成一个异常进程来看，作用是模拟上下文切换过多的问题。</p><p>虚拟机配置：</p><ul><li>Linux：CentOS 7.9</li><li>配置：2C 4G</li><li>服务器安装软件：yum install -y sysbench sysstat</li></ul><p>2、开始实验</p><ul><li><p>在第一个终端运行 sysbench，模拟系统多线程调度的瓶颈</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以 10 个线程运行 5 分钟的基准测试，模拟多线程切换的问题</span></span><br><span class="line">sysbench --threads=10 --max-time=300 threads run</span><br></pre></td></tr></table></figure></li><li><p>在第二个终端运行 vmstat ，观察上下文切换情况</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔 1 秒输出 1 组数据</span></span><br><span class="line">vmstat 1</span><br></pre></td></tr></table></figure><blockquote><p>可见 cs 上下文切换瞬间上升到 329 万。</p><p><code>r</code>就绪队列：平均达到了 7~8，远远超过了系统 CPU 的个数 2，所以肯定会有大量的 CPU 竞争；</p><p><code>us（user）</code>和 <code>sy（system）</code>CPU使用率：几乎达到 100%，且明显看到时系统 CPU 使用率占大头（高达 86% 以上），说明 CPU 主要是被内核占用了；</p><p><code>in</code> 中断次数：中断次数也上升到了 5 万左右，说明中断处理也是个潜在的问题。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230424170358753.png" alt="image-20230424170358753"></p><p>综合这几个指标，我们可以知道，系统的就绪队列过长，也就是正在运行和等待 CPU 的进程数过多，导致了大量的上下文切换，而上下文切换又导致了系统 CPU 的占用率升高。</p></li><li><p>在第三个终端再用 pidstat 来看到底是什么进程导致了这些问题</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔 1 秒输出 1 组数据</span></span><br><span class="line"><span class="comment"># -w 参数表示输出进程切换指标，而 -u 参数则表示输出 CPU 使用指标</span></span><br><span class="line">pidstat -w -u 1</span><br></pre></td></tr></table></figure><p>下图中可见，sysbench 这个进程的 CPU 使用率已经高达 190%。但 CPU 上下文切换与上图进行对比，你会发现上图中通过 vmstat 查询的 CPU 上下文切换达到了 300 多万，而下图中通过 pidstat 查询的 CPU 自愿上下文切换才几十（20 多），为什么会相差这么大呢？</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230424172801619.png" alt="image-20230424172801619"></p><p>实际上是因为 pidstat 默认查看的是进程的相关指标，如果你要显示线程的相关指标数据，你需要添加 <code>-t</code> 选项，再次测试一下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -wt 1</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230424174500386.png" alt="image-20230424174500386"></p><p>可见，这才是 sysbench 进程的线程的 CPU 上下文切换指标数据，与 vmstat 看到的数据基本吻合。</p><p>此时，我们已经找出了导致 CPU 大量上下文切换的进程，那除此之外，还可能有什么系统性能影响因素吗？显然是还有的，在第二个终端的时候可看到，除了 CPU 上下文飙升之外，中断也是骤然飙升，因此，还有中断问题可能会影响系统性能。</p><p>那是什么类型的中断会真么高呢？前面几个命令都没有输出详细的中断信息，因此我们需要参考系统中的 <code>/proc/interrupts</code> 文件，该文件用于内核空间与用户空间之间的通信使用。因此，我们继续来观察该文件的变化情况：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -d <span class="built_in">cat</span> /proc/interrupts</span><br></pre></td></tr></table></figure><blockquote><p>在压测下，可以发现，变化速度最快的是<code>重调度中断(RES)</code>，表示唤醒空闲状态的 <code>CPU</code> 来调度新的任务运行。这是多处理器系统(SMP)中，调度器用来分散任务队列到不同 <code>CPU</code> 的机制，通常也被称为<code>处理器间中断</code>。根本原因还是因为过多任务的调度问题，跟前边分析结果是一致的。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230424180408568.png" alt="image-20230424180408568"></p></li></ul><h2 id="二、每秒上下文切换多少次算正常"><a href="#二、每秒上下文切换多少次算正常" class="headerlink" title="二、每秒上下文切换多少次算正常"></a>二、每秒上下文切换多少次算正常</h2><p><strong>这个数值其实取决于系统本身的 CPU 性能</strong>。如果系统的上下文切换次数比较稳定，那么从数百到一万以内，都应该算是正常的。但当上下文切换次数超过一万次，或者切换次数出现数量级的增长时，就很可能已经出现了性能问题。</p><p>这时，你还需要根据上下文切换的类型，再做具体分析。比方说：</p><ul><li>自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I&#x2F;O 等其他问题；</li><li>非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈；</li><li>中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 &#x2F;proc&#x2F;interrupts 文件来分析具体的中断类型。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于 CPU 上下文切换，我们应该灵活使用相关的命令工具，如 <strong>mpstat、vmstat 、 pidstat</strong>等命令，关键是要明白每个工具输出的指标数据代表的是什么，会对系统有什么影响。</p>]]></content>
      
      
      <categories>
          
          <category> 优化篇 </category>
          
          <category> Linux 系统 </category>
          
          <category> CPU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何理解 Linux 的 CPU 上下文切换？</title>
      <link href="/posts/articles/371209c6.html"/>
      <url>/posts/articles/371209c6.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/linux-protection-rings.jpg#pic_center" alt="linux-protection-rings"></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们说，Linux 是一个多用户多任务的操作系统，前面说到理想情况下如果每个 CPU 都执行着一个进程，那我们说 CPU 的使用率刚刚完全被利用（无 CPU 浪费），如果进程数超过 CPU  个数，可能会出现 CPU 使用率或系统平均负载升高的问题。</p><p>实际上，Linux 操作系统支持远大于 CPU 数量的任务（进程）同时运行，而这些进程实际上并不是真正的在同时运行，就好比在你的 windows 上同时运行多个软件（如听歌的同时在玩游戏），宏观上貌似是同时运行的，但实际上是轮流运行的。之所以会有这样的感觉，是因为操作系统在短时间内将 CPU 轮流分配给它们，造成多任务同时运行的错觉。此时就会设计到<code>并发</code>与<code>并行</code>的基本概念（这里指的就是<code>并发</code>），大家可以自行 Google 它们之间的区别，这里不作为重点。</p><p>此时，你会想，进程在竞争 CPU 时并没有真正运行，那为什么会导致系统负载升高呢？实际上就是因为 CPU 上下文切换导致。</p><h2 id="一、什么是-CPU-上下文？"><a href="#一、什么是-CPU-上下文？" class="headerlink" title="一、什么是 CPU 上下文？"></a>一、什么是 CPU 上下文？</h2><p>首先，在每个任务（进程）运行之前，CPU 都需要知道任务从哪里加载、又从哪里开始运行，也就是说，需要操作系统事先帮它设置好 <code>CPU 寄存器和程序计数器</code>。</p><ul><li><strong>CPU 寄存器</strong>：CPU 内置的容量小、但速度快的内存；</li><li><strong>程序计数器</strong>：用来存储 CPU 正在执行的指令位置或即将执行的下一条指令位置。</li></ul><p>这两项都是 CPU 在运行任何进程前，必须依赖的环境，因此我们也称之为 <code>CPU 上下文</code>。</p><h2 id="二、什么是-CPU-上下文切换？"><a href="#二、什么是-CPU-上下文切换？" class="headerlink" title="二、什么是 CPU 上下文切换？"></a>二、什么是 CPU 上下文切换？</h2><p>通过上面的 CPU 上下文概念，我想应该很好理解<code>CPU 上下文切换</code>的概念。</p><p>所谓的 <code>CPU 上下文切换</code>，就是先把前一个任务的 <code>CPU</code> 上下文保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳到程序计数器所指的新位置，运行新任务。而前面这些保存下来的上下文，会存储在系统内核中，并在这些任务被重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</p><p>此时，根据任务的不同，<code>CPU</code> 的上下文切换可以分为几个不同的场景：<code>进程上下文切换</code>、<code>线程上下文切换</code>、<code>中断上下文切换</code>。</p><h3 id="2-1-进程上下文切换"><a href="#2-1-进程上下文切换" class="headerlink" title="2.1 进程上下文切换"></a>2.1 进程上下文切换</h3><p>Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间，分别对应着下图中， CPU 特权等级的 Ring 0 和 Ring 3。</p><ul><li>内核空间（Ring 0）具有最高权限，可以直接访问所有资源；</li><li>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。</li></ul><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/4d3f622f272c49132ecb9760310ce1a7.png" alt="img"></p><p>也就是说，进程既可以在用户空间运行，又可以在内核空间中运行。进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。从用户态到内核态的转变，需要通过<strong>系统调用</strong>来完成。比如，当我们查看文件内容时，就需要多次系统调用来完成：首先调用 open() 打开文件，然后调用 read() 读取文件内容，并调用 write() 将内容写到标准输出，最后再调用 close() 关闭文件。</p><p>那么，系统调用的过程有没有发生 CPU 上下文的切换呢？答案自然是肯定的。</p><p>CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。</p><p>而系统调用结束后，CPU 寄存器需要<strong>恢复</strong>原来保存的用户态，然后再切换到用户空间，继续运行进程。所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换。简单理解系统调用时发生的两次 CPU 上下文切换就是：</p><ul><li><code>进程1上下文（用户态）</code> - - 1次切换 - - &gt; <code>进程1上下文（内核态）</code> - - 2次切换 - - &gt; <code>进程1上下文（用户态）</code></li></ul><p>不过，需要注意的是，系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。这跟我们通常所说的进程上下文切换是不一样的：</p><ul><li>进程上下文切换，是指从一个进程切换到另一个进程运行。</li><li>而系统调用过程中一直是同一个进程在运行。</li></ul><p>需要注意的是：<strong>系统调用过程通常称为特权模式切换，而不是上下文切换</strong>。而实际上，系统调用过程中，CPU 的上下文切换还是无法避免的。</p><p><strong>那么，进程上下文切换跟系统调用又有什么区别呢？</strong></p><p>首先，你需要知道，进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以，进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。</p><p>因此，进程的上下文切换就比系统调用时多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。</p><p>如下图所示，保存上下文和恢复上下文的过程并不是“免费”的，需要内核在 CPU 上运行才能完成。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/395666667d77e718da63261be478a96b.png" alt="img"></p><p>根据<a href="https://blog.tsunanet.net/2010/11/how-long-does-it-take-to-make-context.html"> Tsuna </a>的测试报告，每次上下文切换都需要几十纳秒到数微秒的 CPU 时间。这个时间还是相当可观的，特别是在进程上下文切换次数较多的情况下，很容易导致 CPU 将大量时间耗费在寄存器、内核栈以及虚拟内存等资源的保存和恢复上，进而大大缩短了真正运行进程的时间。这也正是上一节中我们所讲的，导致平均负载升高的一个重要因素。</p><p>另外，我们知道， Linux 通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB 也需要刷新，内存的访问也会随之变慢。特别是在多处理器系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程。</p><p>知道了进程上下文切换潜在的性能问题后，我们再来看，究竟什么时候会切换进程上下文。</p><p>显然，进程切换时才需要切换上下文，换句话说，只有在进程调度的时候，才需要切换上下文。Linux 为每个 CPU 都维护了一个就绪队列，将活跃进程（即正在运行和正在等待 CPU 的进程）按照优先级和等待 CPU 的时间排序，然后选择最需要 CPU 的进程，也就是优先级最高和等待 CPU 时间最长的进程来运行。</p><p><strong>那么，进程在什么时候才会被调度到 CPU 上运行呢？</strong></p><p>最容易想到的一个时机，就是进程执行完终止了，它之前使用的 CPU 会释放出来，这个时候再从就绪队列里，拿一个新的进程过来运行。其实还有很多其他场景，也会触发进程调度，在这里我给你逐个梳理下。</p><ul><li><p>其一：为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行。</p></li><li><p>其二：进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。</p></li><li><p>其三：当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。</p></li><li><p>其四：当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。</p></li><li><p>最后一个：发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。</p></li></ul><p>了解这几个场景是非常有必要的，因为一旦出现上下文切换的性能问题，它们就是幕后凶手。</p><h3 id="2-2-线程上下文切换"><a href="#2-2-线程上下文切换" class="headerlink" title="2.2 线程上下文切换"></a>2.2 线程上下文切换</h3><p>说完了进程的上下文切换，我们再来看看线程相关的问题。</p><p>线程与进程最大的区别在于，<strong>线程是调度的基本单位，而进程则是资源拥有的基本单位</strong>。说白了，所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源。所以，对于线程和进程，我们可以这么理解：</p><ul><li>当进程只有一个线程时，可以认为进程就等于线程。</li><li>当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。</li><li>另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。</li></ul><p>这么一来，线程的上下文切换其实就可以分为两种情况：</p><ul><li><p>第一种：前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。</p></li><li><p>第二种：前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。</p></li></ul><p>到这里你应该也发现了，虽然同为上下文切换，但同进程内的线程切换，要比多进程间的切换消耗更少的资源，而这也正是多线程代替多进程的一个优势。</p><h3 id="2-3-中断上下文切换"><a href="#2-3-中断上下文切换" class="headerlink" title="2.3 中断上下文切换"></a>2.3 中断上下文切换</h3><p>除了前面两种上下文切换，还有一个场景也会切换 CPU 上下文，那就是中断。</p><p>为了快速响应硬件的事件，<strong>中断处理会打断进程的正常调度和执行</strong>，转而调用中断处理程序，响应设备事件。而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。</p><p>跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。</p><p><strong>对同一个 CPU 来说，中断处理比进程拥有更高的优先级</strong>，所以中断上下文切换并不会与进程上下文切换同时发生。同样道理，由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。</p><p>另外，跟进程上下文切换一样，中断上下文切换也需要消耗 CPU，切换次数过多也会耗费大量的 CPU，甚至严重降低系统的整体性能。所以，当你发现中断次数过多时，就需要注意去排查它是否会给你的系统带来严重的性能问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>CPU 上下文切换，是保证 Linux 系统正常工作的核心功能之一，一般情况下不需要我们特别关注；</li><li>但过多的上下文切换，会把 CPU 时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，从而缩短进程真正运行的时间，导致系统的整体性能大幅下降。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 优化篇 </category>
          
          <category> Linux 系统 </category>
          
          <category> CPU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你真理解 Linux 系统的平均负载吗？</title>
      <link href="/posts/articles/f026fcb9.html"/>
      <url>/posts/articles/f026fcb9.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420135405814.png" alt="image-20230420135405814"></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们经常用到 top、uptime 来查看系统的平均负载，那下图的这三个值的含义你真正理解了吗？</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420133044303.png" alt="image-20230420133044303"></p><p><strong>平均负载是 CPU 使用率吗？</strong></p><p>显然不是，平均负载指的是<code>单位时间内，系统处于“可运行状态”和“不可中断状态”的平均进程数</code>，即<code>平均活跃进程数</code>，它和 CPU 的使用率并没有直接关系。</p><p><strong>什么是可运行状态？什么又是不可中断状态？</strong></p><ul><li><p><code>可运行状态</code>：正在使用 CPU 或正在等待 CPU 的调度的进程（如 R 状态的进程 - - Running&#x2F;Runnable）；</p></li><li><p><code>不可中断状态</code>：处于系统内核态关键流程中的进程，且这些流程是不可打断的（如 D 状态的进程）。</p><blockquote><p>比如：向磁盘写入数据，这个过程在未得到磁盘响应前一般是不允许中断的，否则将导致磁盘数据与进程数据不一致的问题。因此，不可中断状态实际上是系统对进程和硬件设备的一种保护机制。</p></blockquote></li></ul><p><strong>因此，理想情况下就是每个 CPU 上都刚好运行着一个进程，这样每个 CPU 都得到了充分的利用。</strong></p><p><strong>当平均负载为 2 时，意味着什么呢？</strong></p><ul><li>在只有 2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用；</li><li>在 4 个 CPU 的系统上，意味着 CPU 有 50% 的空闲；</li><li>而在只有 1 个 CPU 的系统上，则意味着有一半的进程竞争不到 CPU。</li></ul><h2 id="一、如何判断系统是否过载？"><a href="#一、如何判断系统是否过载？" class="headerlink" title="一、如何判断系统是否过载？"></a>一、如何判断系统是否过载？</h2><p>上面我们大体了解了什么是平均负载，那在实际工作中，如何判定某台服务器的平均负载过高呢？上面说到可通过 <code>top</code>、<code>uptime</code> 等命令来查看 Linux 系统的负载情况。</p><p>理想情况下，平均负载等于 CPU 个数，因此，判断负载是否过高，首先要知道你当前系统有几个 CPU，可通过 <code>top</code> 命令 + 快捷键 <code>1</code> 查看 CPU  个数：如下图，我当前的 Linux 系统只有 1 个 CPU（%Cpu0）。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420144125852.png" alt="image-20230420144125852"></p><p>或通过 shell 命令查看也是可以的：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&#x27;model name&#x27;</span> /proc/cpuinfo | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420144308842.png" alt="image-20230420144308842"></p><p>有了 CPU 个数，我们就可以判断：当平均负载 &gt; CPU 个数时，系统就已经过载。在 Linux 中，系统给我们提供了三个值，这三个值分别表示过去 1 分钟、5 分钟、15 分钟的系统平均负载。那我们主要看哪一个值呢？答案是都要看，这三个值是作为变化趋势的参考，仅凭一个值是很难准确判断的。</p><ul><li>如果 1 分钟、5 分钟、15 分钟的三个值基本相同（或者相差不大），那就说明系统负载很稳定；</li><li>但如果 1 分钟的值远小于 15 分钟的值，就说明系统最近 1 分钟的负载在减少，而过去 15 分钟内却有很大的负载；</li><li>反过来，如果 1 分钟的值远大于 15 分钟的值，就说明近 1 分钟的负载在增加，这种增加可能是临时性的（因为就短短的 1 分钟），也有持续增加或逐步减少的可能，因此这种情况需要持续观察。</li></ul><p>再举个例子：假设在单个 CPU 的系统上有 1.73，0.60，7.98 的负载，那就说明过去 1 分钟内系统有 73% 的过载、15 分钟内系统有 698% 的超载，但是从整体来看，系统的负载在降低。</p><p><strong>那么，在实际生产环境中，平均负载多高时，需要我们重点关注呢？</strong></p><p>一般，<strong>当平均负载高于 CPU 数量 70% 的时候</strong>，就应该分析排查负载高的问题了。因为负载过高，就可能导致进程响应变慢，进而影响服务的正常功能。</p><p><mark>因此，对于系统平均负载是否过载的问题，我们最好是通过 Zabbix 或 Prometheus 等监控工具监控起来，这样便于观察系统平均负载在某个时间段的变化趋势。</mark></p><h2 id="二、平均负载与-CPU-使用率关联"><a href="#二、平均负载与-CPU-使用率关联" class="headerlink" title="二、平均负载与 CPU 使用率关联"></a>二、平均负载与 CPU 使用率关联</h2><p>前面说到，平均负载与 CPU 使用率并不是同一个 <code>“东西”</code>，是有一定的区别和联系的。一般在实际生产中会遇到这三种情况：CPU 使用率高系统平均负载低、CPU 使用率低系统平均负载高、CPU 使用率与系统平均负载都高。</p><p>其实，这是在特定场景下产生的不同现象：</p><ul><li>对于 CPU 密集型进程而言：使用大量 CPU 会导致平均负载过高。此时就是 CPU 使用率高平均负载也会过高的情况；</li><li>对于 I&#x2F;O 密集型进程而言：等待 I&#x2F;O 会导致平均负载过高，但 CPU 不一定很高。此时就是 CPU 使用率低平均负载过高的情况；</li><li>大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。</li></ul><p><strong>什么是 CPU 密集型？什么又是 I&#x2F;O 密集型？</strong></p><blockquote><p>参考：<a href="https://blog.csdn.net/youanyyou/article/details/78990156">什么是CPU密集型、IO密集型？</a></p></blockquote><ul><li><p><code>CPU 密集型（CPU-bound）</code>：也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作大部分的状况是 CPU Loading 100%，CPU 要读&#x2F;写I&#x2F;O(硬盘&#x2F;内存)，I&#x2F;O 在很短的时间就可以完成，而 CPU 还有许多运算要处理，CPU Loading 很高。</p><p>在多重程序系统中，大部份时间用来做计算、逻辑判断等 CPU 动作的程序称之 CPU bound。例如一个计算圆周率至小数点一千位以下的程序，在执行的过程当中绝大部份时间用在三角函数和开根号的计算，便是属于 CPU bound 的程序。</p><p>CPU bound 的程序一般而言 CPU 占用率相当高。这可能是因为任务本身不太需要访问 I&#x2F;O 设备，也可能是因为程序是多线程实现因此屏蔽掉了等待 I&#x2F;O 的时间。</p></li><li><p><code>IO 密集型（I/O bound）</code>：IO 密集型指的是系统的 CPU 性能相对硬盘、内存要好很多，此时，系统运作大部分的状况是 CPU 在等 I&#x2F;O (硬盘&#x2F;内存) 的读&#x2F;写操作，此时 CPU Loading 并不高。</p><p>I&#x2F;O bound 的程序一般在达到性能极限时，CPU 占用率仍然较低。这可能是因为任务本身需要大量 I&#x2F;O 操作，而 Pipeline 做得不是很好，没有充分利用处理器能力。</p></li></ul><h2 id="三、案例分析"><a href="#三、案例分析" class="headerlink" title="三、案例分析"></a>三、案例分析</h2><p>准备实现所需环境：</p><ul><li>Linux 系统：CentOS 7.9 2C&#x2F;4G</li><li>压测工具：stress</li><li>性能分析工具：sysstat（包含 mpstat、pidstat 等工具）</li></ul><p>安装相关工具：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y stress sysstat</span><br></pre></td></tr></table></figure><h3 id="3-1-CPU-密集型进程"><a href="#3-1-CPU-密集型进程" class="headerlink" title="3.1 CPU 密集型进程"></a>3.1 CPU 密集型进程</h3><p>1、终端1 - - 压测：模拟一个进程 CPU 使用率 100% 的场景</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress --cpu 1 --<span class="built_in">timeout</span> 600</span><br></pre></td></tr></table></figure><p>2、终端2 - - 查看负载：运行 uptime 查看系统平均负载变化情况</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">watch -d <span class="built_in">uptime</span></span><br><span class="line"><span class="comment"># -d 参数表示高亮显示变化的区域</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420162317536.png" alt="image-20230420162317536"></p><p>3、终端3 - - 查看 CPU 使用率：运行 mpstat 查看 CPU 使用率的变化情况</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mpstat -P ALL 5</span><br><span class="line"><span class="comment"># -P ALL 表示监控所有 CPU，后面数字 5 表示间隔 5 秒后输出一组数据</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420160456532.png" alt="image-20230420160456532"></p><p>输出结果可见：%Cpu1 的使用率基本上也是 100% 了。</p><p>那么，到底是哪个进程导致了 CPU 使用率为 100% 呢？可以使用 <code>pidstat</code> 来查询：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pidstat -u 5 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 间隔 5 秒后输出一组数据</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420161018814.png" alt="image-20230420161018814"></p><p>Command 字段就是对应的执行程序。</p><p>当然，方法有很多，你也可以通过 <code>top + C + P</code> 来查看占用 CPU 的程序，如下图：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420161231638.png" alt="image-20230420161231638"></p><h3 id="3-2-I-x2F-O-密集型进程"><a href="#3-2-I-x2F-O-密集型进程" class="headerlink" title="3.2 I&#x2F;O 密集型进程"></a>3.2 I&#x2F;O 密集型进程</h3><p>1、同理进行 I&#x2F;O 测试</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress -i 1 --<span class="built_in">timeout</span> 600</span><br></pre></td></tr></table></figure><p>2、uptime 查看系统平均负载变化情况</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -d <span class="built_in">uptime</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420162638463.png" alt="image-20230420162638463"></p><p>3、mpstat 查看 CPU 使用率的变化情况</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpstat -P ALL 5</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420162908212.png" alt="image-20230420162908212"></p><p>可见，其中一个 CPU 的系统 CPU 使用率升高，但并不是因为 <code>iowait</code>  导致（但实际场景中一般会因为 IO 等待导致），说明系统 IO 还未出现瓶颈。</p><p>查看是由那个进程导致的系统层 CPU 使用率过高的方法同上！</p><h3 id="3-3-大量进程的场景"><a href="#3-3-大量进程的场景" class="headerlink" title="3.3 大量进程的场景"></a>3.3 大量进程的场景</h3><p>当系统中运行进程超出 CPU 运行能力时，就会出现等待 CPU 的进程。</p><p>1、模拟 8 个进程使用 CPU 的场景</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress --cpu 8 --<span class="built_in">timeout</span> 600</span><br></pre></td></tr></table></figure><p>2、查看系统平均负载</p><blockquote><p>由于系统只有 2 个 CPU，明显比 8 个进程要少得多，因而，系统的 CPU 处于严重过载状态，平均负载高达 7.23。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -d <span class="built_in">uptime</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420165023013.png" alt="image-20230420165023013"></p><p>3、查看 CPU 使用率的变化情况</p><blockquote><p>这两个 CPU 几乎都跑满了。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420165117693.png" alt="image-20230420165117693"></p><p>查看导致 CPU 过高的进程</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -u 5 1</span><br></pre></td></tr></table></figure><blockquote><p>这 8 个进程几乎竞争到了相同的 CPU，整体算下来严重过载了。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420165216815.png" alt="image-20230420165216815"></p><p>由于 CentOS 没有 iowait 字段，我换到 ubuntu 去看看效果：</p><blockquote><p>Linux：Ubuntu 20 1C 2G</p><p>可见，8 个进程在争抢 1 个 CPU，每个进程等待 CPU 的时间（也就是代码块中的 %wait 列）高达 87%。这些超出 CPU 计算能力的进程，最终导致 CPU 过载。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -u 5 1</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420170058200.png" alt="image-20230420170058200"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>平均负载高有可能是 CPU 密集型进程导致的；</li><li>平均负载高并不一定代表 CPU 使用率高，还有可能是 I&#x2F;O 更繁忙了；</li><li>当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 优化篇 </category>
          
          <category> Linux 系统 </category>
          
          <category> CPU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 6.0+ 的 ACL 机制</title>
      <link href="/posts/articles/464f6e46.html"/>
      <url>/posts/articles/464f6e46.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/Screenshot-2022-09-28-135602.png" alt="Redis Encryption"></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redis 6.0+ 引入了 ACL 机制，类似 MySQL 一样全部权限管理，Redis 6.0 之前默认为 default 用户登录，该用户具备 root 权限，在生产中实际上是不安全的，因为只要具备 Redis 实例的密码，就可以以 root 身份对 Redis 进行操作。</p><p>因此 Redis 6.0+ 引入了 ACL 机制，ACL是使用 DSL（domain specific language）定义的，该 DSL 描述了给定用户能够执行的操作。那引用 ACL 的目的是什么呢？</p><ul><li><strong>访问安全性</strong>：ACL 使不受信任的客户端无法访问，而受信任的客户端仅具有对数据库的最低访问级别才能执行所需的工作。</li><li><strong>操作安全性</strong>：以防止由于软件错误或人为错误而导致进程或人员访问 Redis，从而损坏数据或配置。例如，没有必要让其他人员从 Redis 调用 <code>FLUSHALL</code> 命令。</li></ul><h2 id="一、安装-Redis-服务"><a href="#一、安装-Redis-服务" class="headerlink" title="一、安装 Redis 服务"></a>一、安装 Redis 服务</h2><p><strong>1、安装 Docker</strong></p><p><strong>2、安装 Redis</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name=redis-server-6.0 -p 16379:6379 redis:6.0-alpine</span><br></pre></td></tr></table></figure><p><strong>3、登录验证</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it redis-server-6.0 redis-cli</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418163454677.png" alt="image-20230418163454677"></p><h2 id="二、创建-ACL-用户"><a href="#二、创建-ACL-用户" class="headerlink" title="二、创建 ACL 用户"></a>二、创建 ACL 用户</h2><p><strong>1、创建用户并设置明文密码</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER rab on &gt;zhurs@123</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;&gt;&#x27;符号后是明文密码</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418162643165.png" alt="image-20230418162643165"></p><p><strong>2、创建用户并设置 Hash 密码</strong></p><ul><li><p>获取 Hash 值</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;zhurs@123&quot;</span> | shasum -a 256</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418162937832.png" alt="image-20230418162937832"></p><blockquote><p>随机获取 Hash 值密码</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419151021926.png" alt="image-20230419151021926"></p></li><li><p>创建用户</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER ops on <span class="comment">#a9db6465cac424cb70a81fae6f42cd63b7e2292b45795ea88695e9da2baea040</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;#&#x27;符号后是Hash值</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418163257814.png" alt="image-20230418163257814"></p></li></ul><p><strong>3、查看所有用户</strong></p><blockquote><p>会发现，不管是明文还是Hash设置密码，Redis 最终存储都是以 Hash 值存储密码。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418163600209.png" alt="image-20230418163600209"></p><p>这些用户是没有权限的，如果你要在创建用户时添加权限，你可以：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER rab on &gt;zhurs@123 ~* +@all</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;~*&#x27; 表示该用户可以访问所有key</span></span><br><span class="line"><span class="comment"># &#x27;+@all&#x27; 表示拥有这些key的所有权   + 表示授权  - 表示销权</span></span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>user</td><td>用户</td></tr><tr><td>default</td><td>用户名（default为默认用户）- - 也可是自定义用户（redis 6.0+）</td></tr><tr><td>on</td><td>是否启用该用户（on 启用，off 禁用）</td></tr><tr><td>#…</td><td>用户密码（#… 密文形式显示，oppass 表示无密码）</td></tr><tr><td>~*</td><td>用户可访问的 key（正则匹配 - -  <code>~*</code> 表示用户可访问所有 key）</td></tr><tr><td>+@</td><td>用户权限，+ 代表授权，- 代表销权；@ 后为权限类型，+@all 表示用户对 redis 具备所有权限</td></tr></tbody></table><p><strong>4、查看指定用户信息</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL GETUSER rab</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418175412239.png" alt="image-20230418175412239"></p><p><strong>5、用户登录认证</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 6.0-</span></span><br><span class="line">AUTH &lt;密码&gt;     <span class="comment"># 这种方式的用户为default用户，相当于MySQL的root用户</span></span><br><span class="line"><span class="comment"># 6.0+</span></span><br><span class="line">AUTH &lt;用户&gt; &lt;密码&gt;</span><br><span class="line"></span><br><span class="line">AUTH rab zhurs@123</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418175604891.png" alt="image-20230418175604891"></p><p>Windows 客户端工具登录：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418174020712.png" alt="image-20230418174020712"></p><p>正常连接：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418174311679.png" alt="image-20230418174311679"></p><h2 id="三、用户密码管理"><a href="#三、用户密码管理" class="headerlink" title="三、用户密码管理"></a>三、用户密码管理</h2><h3 id="3-1-删除密码"><a href="#3-1-删除密码" class="headerlink" title="3.1 删除密码"></a>3.1 删除密码</h3><p><strong>1、通过 <code>&lt;</code> 与 <code>!</code> 删除用户密码</strong></p><blockquote><p>删除密码后，AUTH 无法登录，redis 客户端也无法连接，想要连接，需再次设置密码。</p><p>相当于是删除密码，而不是设置密码为<code>空</code>，如果要设置密码为<code>空</code>，可使用<code>nopass</code>来设置。</p></blockquote><ul><li><p>明文密码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER rab &lt;zhurs@123</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;&lt;&#x27; 符号之后是前面创建用户时设置的明文密码</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418180333209.png" alt="image-20230418180333209"></p></li><li><p>Hash 密码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER ops !a9db6465cac424cb70a81fae6f42cd63b7e2292b45795ea88695e9da2baea040</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;!&#x27; 符号之后是前面创建用户时设置的Hash密码</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418180444997.png" alt="image-20230418180444997"></p></li></ul><p><strong>2、通过 <code>nopass</code> 删除用户密码</strong></p><p>为了演示，再创建一个用户 <code>test</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER <span class="built_in">test</span> on &gt;nba ~* +@all</span><br></pre></td></tr></table></figure><p>注意：一个用户可设置多个密码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER <span class="built_in">test</span> on &gt;cba ~* +@all</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418181412964.png" alt="image-20230418181412964"></p><p>查看用户详细信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL GETUSER <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418181917296.png" alt="image-20230418181917296"></p><p>开始设置 <code>test</code> 用户密码为 <code>空</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER <span class="built_in">test</span> nopass</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418182159429.png" alt="image-20230418182159429"></p><p>与<code>&lt;</code>、<code>#</code>不同的是，该用户是可以登录的，因为密码是空，只需设置密码为空即可登录，如果不设置空密码，也是无法进行用户认证。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auth <span class="built_in">test</span>      <span class="comment"># 无法认证</span></span><br><span class="line">auth <span class="built_in">test</span> <span class="string">&#x27;&#x27;</span>   <span class="comment"># 可以认证（为空或填任意密码都不影响）</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418182501637.png" alt="image-20230418182501637"></p><p>redis 客户端测试验证：</p><blockquote><p>密码处填不填不影响。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418182609602.png" alt="image-20230418182609602"></p><p>连接验证：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418182640220.png" alt="image-20230418182640220"></p><h3 id="3-2-重置用户和密码"><a href="#3-2-重置用户和密码" class="headerlink" title="3.2 重置用户和密码"></a>3.2 重置用户和密码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER <span class="built_in">test</span> reset</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419150556176.png" alt="image-20230419150556176"></p><p>重置后，该用户无法登录连接，可见 test 用户处于 <code>off</code> 禁用状态。</p><h2 id="四、权限管理"><a href="#四、权限管理" class="headerlink" title="四、权限管理"></a>四、权限管理</h2><h3 id="4-1-key-管理"><a href="#4-1-key-管理" class="headerlink" title="4.1 key 管理"></a>4.1 key 管理</h3><p><strong>1、对 test 用户设置可操作的 key</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER <span class="built_in">test</span> on &gt;zhurs@123 ~foo* ~bar* +@all</span><br><span class="line"></span><br><span class="line"><span class="comment"># test用户可管理foo、bar开头的key</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419152531283.png" alt="image-20230419152531283"></p><p><strong>2、取消用户可操作的 key</strong></p><p>通过 resetkeys 实现，此时只能操作 ob 开头的 key，<code>~foo*、~bar*</code> key 已经被 resetkeys 清空。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER <span class="built_in">test</span> on &gt;zhurs@123 ~foo* ~bar* resetkeys ~ob* +@all</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419152823519.png" alt="image-20230419152823519"></p><p><strong>3、操作所有 key</strong></p><blockquote><p><code>allkeys</code> 和 <code>~*</code> 效果一样</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER <span class="built_in">test</span> on &gt;zhurs@123 ~* +@all</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419170056975.png" alt="image-20230419170056975"></p><h3 id="4-2-权限管理"><a href="#4-2-权限管理" class="headerlink" title="4.2 权限管理"></a>4.2 权限管理</h3><p><strong>1、权限类型</strong></p><p>权限有很多，如下是 redis 所有的权限列表：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL CAT</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419171923038.png" alt="image-20230419171923038"></p><p>如查看某个权限的具体信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL CAT <span class="built_in">read</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419172131962.png" alt="image-20230419172131962"></p><p><strong>2、权限设置</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER <span class="built_in">test</span> on &gt;zhurs@123 ~foo* ~bar* +@<span class="built_in">hash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># test用户只有对hash类型的key有权限</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419172659504.png" alt="image-20230419172659504"></p><p>可见，取消了所有权限，仅限制为 hash 权限。其他权限就不一一举例了，各位可自行尝试。</p><h2 id="五、ACL-用户存储"><a href="#五、ACL-用户存储" class="headerlink" title="五、ACL 用户存储"></a>五、ACL 用户存储</h2><p>这里注意一下，以上的操作是通过 ACL 命令实现的，这些操作都只是临时存储与内存中，如果服务器或实例重启后，ACL 所设置的数据将会丢失。如下图你会发现，前面创建的 test 用户已经不见了。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419173312166.png" alt="image-20230419173312166"></p><p>那 Redis 6.0+ 是如何存储创建的用户呢？<strong>官方给出了两种方法</strong>：直接将用户信息写入配置文件 redis.conf 中、指定外部 ACL 文件。</p><p>这两种方法是<em>相互不兼容</em>的，因此，我们只能选择其中任意一种，考虑到生产上的复杂环境问题，官方建议使用外部 ACL 文件方式。</p><h3 id="5-1-配置文件实现"><a href="#5-1-配置文件实现" class="headerlink" title="5.1 配置文件实现"></a>5.1 配置文件实现</h3><p>方法比较简单，直接在 redis.conf 配置文件中追加以下内容，如果有多个用户继续往下追加即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user worker +@list +@connection ~<span class="built_in">jobs</span>:* on &gt;ffa9203c493aa99</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419175928830.png" alt="image-20230419175928830"></p><p>然后重启一下 redis 实例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart redis</span><br></pre></td></tr></table></figure><p>登录验证：</p><blockquote><p>是没问题的。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419180108307.png" alt="image-20230419180108307"></p><h3 id="5-2-外部-ACL-文件实现"><a href="#5-2-外部-ACL-文件实现" class="headerlink" title="5.2 外部 ACL 文件实现"></a>5.2 外部 ACL 文件实现</h3><p>因为不兼容，所以在做这个实验前先去掉配置文件中追加的 <code>user work ...</code> 内容，然后在配置文件中指定外部 ACL 文件路径：</p><p>找到配置文件 <code>aclfile /etc/redis/users.acl</code> 部分，并打开注释。</p><blockquote><p>我自定义的配置文件路径为：&#x2F;data&#x2F;users.acl</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419180652171.png" alt="image-20230419180652171"></p><p>手动创建 <code>users.acl</code> 文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim users.acl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件加入下面内容</span></span><br><span class="line">user root +@all ~* on &gt;zhurs@123</span><br><span class="line">user dev +@list +@connection ~<span class="built_in">jobs</span>:* on &gt;ffa9203c493aa99</span><br><span class="line">user ops +@list +@connection ~<span class="built_in">jobs</span>:* on &gt;kka2023addwedw4</span><br></pre></td></tr></table></figure><p>重启 Redis 实例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart redis</span><br></pre></td></tr></table></figure><p>登录查看：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419181841209.png" alt="image-20230419181841209"></p><p>此时<code>redis.conf</code> 配置文件中定义的密码已经失效，因此这就导致原本的 default 用户又可以无密码登录了，所以我们需要禁用 default 用户：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER default reset</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419183105049.png" alt="image-20230419183105049"></p><p><mark>哨兵和副本的 ACL 规则可查看<a href="https://redis.io/docs/management/security/acl/">官方文档。</a></mark></p><p><strong>参考</strong>：<a href="https://redis.io/docs/management/security/acl/">官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何将 Linux 系统时区设置为 CST ？</title>
      <link href="/posts/articles/a20318db.html"/>
      <url>/posts/articles/a20318db.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419162034139.png" alt="image-20230419162034139"></p><hr><p>有时候，你的 Linux 系统的时区默认为 UTC：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419160158341.png" alt="image-20230419160158341"></p><p>为了能与我们本地时间对应，我们可以将系统时区设置为 CST，如何设置？接下来是详细步骤。</p><p>开始设置时区：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419160646623.png" alt="image-20230419160646623"></p><p>复制时区：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> -rf /etc/localtime</span><br><span class="line">sudo <span class="built_in">ln</span> -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要设置UTC时间</span></span><br><span class="line"><span class="comment"># sudo rm -rf /etc/localtime</span></span><br><span class="line"><span class="comment"># sudo ln -s /usr/share/zoneinfo/UTC /etc/localtime</span></span><br></pre></td></tr></table></figure><p>重新登录终端进行验证：</p><blockquote><p>PM 下午</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419161028327.png" alt="image-20230419161028327"></p><p>如果时区设置了 CST 但时间还不准确时，可进行时间同步：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y ntp ntpdate</span><br><span class="line">sudo ntpdate 0.asia.pool.ntp.org</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux 服务器运维实战 </category>
          
          <category> 系统基础运维篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 用户如何与系统内核通信？</title>
      <link href="/posts/articles/f96953ab.html"/>
      <url>/posts/articles/f96953ab.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/v2-7a788c9f21efafc861328add1802a614_720w.jpg" alt="oss"></p><hr><p>了解过 Linux 的都知道，在 Linux 中有一个叫 shell 的 <code>“东西”</code>，这个 shell 是什么呢？Google 一下 shell 的含义：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418094620363.png" alt="image-20230418094620363"></p><p>你可以把 Linux 系统想象成一个<code>“鸡蛋”</code>，shell 就是鸡蛋的壳，蛋心就是 Linux 系统内核，用户想要与系统内核通信，那必定是通过<code>壳</code>的交互来实现。与 Linux 类似，像 Windows 也是有自己的 shell（command.com 程序）。</p><p>同样，Linux 系统的 shell 本身是一个由 C 编写的程序，目前的 Linux 系统发行版一般都是以 bash 作为默认的 shell，因此，shell 既是一种命令解释程序，也是一种解释型程序设计语言。作为命令解释程序，shell 可以解释用户的输入命令，然后提交到内核处理，最后把结果返回给用户。</p><p>为了加快命令的运行，shell 中定义了一些例如 cp、cd、echo、pwd 等内置命令。当用户登录操作系统后，这些内置命令就会被装载至内存并一直运行，直到用户退出系统为止。</p><p>当然，为了满足某些生产上的需求，仅凭这些内置命令是不够的，因此引入了<code>外置命令</code>的概念。与<code>内置命令</code>不同的是，只有当外置命令被调用时，这些外置命令才会被装载至内存执行。</p><p>因此，shell 执行命令解释的过程为：</p><ul><li>用户命令行中提交可执行命令；</li><li>shell 程序检测用户输入的命令是否为内置命令。<ul><li>如果是：就通过内部的解释器将命令解释为系统调用，然后提交给内核执行；</li><li>如果不是：那 shell 会根据用户给出的命令路径或系统环境变量的路径配置寻找到可用的二进制命令，然后将其装载至内存，再将其解释为系统调用，最后提交给内核执行。</li></ul></li></ul><p><strong>综上不难看出，其实 Linux 系统其实就是用户通过与 shell 的交互来实现与系统内核的通信！</strong></p>]]></content>
      
      
      <categories>
          
          <category> Linux 服务器运维实战 </category>
          
          <category> 系统基础运维篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 安全优化</title>
      <link href="/posts/articles/c1852d71.html"/>
      <url>/posts/articles/c1852d71.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230413105645046.png" alt="image-20230413105645046"></p><hr><p>作为混迹于 IT 行业的一员，相信大家都接触过 Nginx Web 服务，不管是开发、运维、测试、还是算法都离不开 Nginx，而且大家对于 Nginx 的部署也是得心应手。但有的时候我们只局限于部署应用层面，没有考虑其运行在 Internet 上的安全问题，接下来将总结常用也是生产环境上有必要配置的一些安全策略。</p><h3 id="1、使用-SSL-x2F-TLS-证书"><a href="#1、使用-SSL-x2F-TLS-证书" class="headerlink" title="1、使用 SSL&#x2F;TLS 证书"></a>1、使用 SSL&#x2F;TLS 证书</h3><p>传统的 HTTP 是一种以明文形式在端到端的超文本传输协议，在数据传输上存在很大的安全问题，如：窃听、篡改、冒充等安全问题。因此我们需要采用  SSL&#x2F;TLS 证书来实现数据加密，SSL&#x2F;TLS 证书是一种加密数字证书，<code>用于对客户端（Web 浏览器）和服务器之间的流量进行加密</code>。通过这样做，加密是安全的，并且可以防止攻击者使用中间人攻击来窃听和窃取机密信息，例如<code>用户名、密码和信用卡信息等</code>。</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen              443 ssl;</span><br><span class="line">    ssl_certificate     /etc/nginx/ssl/bundle.pem;</span><br><span class="line">    ssl_certificate_key /etc/nginx/ssl/hello.com.key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当然，在我们实际应用中，不同的云厂商会提供相应的参考配置</span></span><br></pre></td></tr></table></figure><h3 id="2、使用安全密钥交换机制"><a href="#2、使用安全密钥交换机制" class="headerlink" title="2、使用安全密钥交换机制"></a>2、使用安全密钥交换机制</h3><p>DH 参数的目的是允许交换一个秘密，该秘密将用于加密会话中的消息副本。临时 DH 提供前向安全性，这意味着会话密钥在会话终止时被删除。因此，攻击者无法检索超过上一个会话的两方之间交换的消息。</p><p>使用 OpenSSL 生成至少 2048 位的唯一 DH 组：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl dhparam -out /etc/ssl/dhparam.pem 2048</span><br></pre></td></tr></table></figure><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssl_dhparam  /etc/ssl/dhparam.pem; </span><br></pre></td></tr></table></figure><h3 id="3、禁用旧的-SSL-x2F-TLS-协议"><a href="#3、禁用旧的-SSL-x2F-TLS-协议" class="headerlink" title="3、禁用旧的 SSL&#x2F;TLS 协议"></a>3、禁用旧的 SSL&#x2F;TLS 协议</h3><p>较弱的 SSL&#x2F;TLS 协议（SSLv2.0、SSL v3.0、TLSv1.0 和 TLSv1.1）可能容易受到攻击并导致诸如 BEAST（针对 SSL&#x2F;TLS 的浏览器漏洞利用）、POODLE（在降级的旧版上填充 Oracle ）等攻击。因此建议使用更新和安全的 SSL&#x2F;TLS 协议。</p><p>什么是 BEAST 攻击？BEAST (CVE-2011-3389) 是一种明文攻击，通过从 SSL&#x2F;TLS 加密的会话中获取受害者的 COOKIE 值（通过进行一次会话劫持攻击），进而篡改一个加密算法的 CBC（密码块链）的模式以实现攻击目录，其主要针对 TLS1.0 和更早版本的协议中的对称加密算法 CBC 模式。</p><p>什么是 POODLE 攻击？很多系统与软体都会使用 Secure Socket Layer (SSL) 3.0 中的 cipher-block chaining (CBC) 模式来做资料 的加解密，而这套演算法已经被发现漏洞，其中 POODLE 是最出名的攻击方式， POODLE 全名 Padding Oracle On Downgraded Legacy Encryption ，它可以破解 web server 跟 web browser 之间的 SSLv3 传输加密。</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen              443 ssl;</span><br><span class="line">    ssl_certificate     /etc/nginx/ssl/bundle.pem;</span><br><span class="line">    ssl_certificate_key /etc/nginx/ssl/mytechnix.com.key;</span><br><span class="line">    ssl_protocols TLSv1.2 TLSv1.3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、禁用-SSL-x2F-TLS-弱密码套件"><a href="#4、禁用-SSL-x2F-TLS-弱密码套件" class="headerlink" title="4、禁用 SSL&#x2F;TLS 弱密码套件"></a>4、禁用 SSL&#x2F;TLS 弱密码套件</h3><p>较弱且旧的密码套件配置可能会很容易使你的网站受到攻击，比如攻击者可能会拦截或修改传输中的数据。因此，你可以更具你不同的 Nginx 版本和 SSL&#x2F;TLS 版本来选择更佳的密码套件，大家可以通过该网站来评估出最佳方案 —&gt; <a href="https://ssl-config.mozilla.org/">传送门</a>。输入 nginx 和 SSL&#x2F;TLS 版本后，会为你自动生成最佳配置文件，比如我输入的 Nginx 版本为 1.18.0、SSL&#x2F;TLS 版本为 1.1.1，则会生成如下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">generated 2022-04-27, Mozilla Guideline v5.6, nginx 1.18.0, OpenSSL 1.1.1k, intermediate configuration</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">https://ssl-config.mozilla.org/<span class="comment">#server=nginx&amp;version=1.18.0&amp;config=intermediate&amp;openssl=1.1.1k&amp;guideline=5.6</span></span></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    listen [::]:80 default_server;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        return 301 https://$host$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl http2;</span><br><span class="line">    listen [::]:443 ssl http2;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /path/to/signed_cert_plus_intermediates;</span><br><span class="line">    ssl_certificate_key /path/to/private_key;</span><br><span class="line">    ssl_session_timeout 1d;</span><br><span class="line">    ssl_session_cache shared:MozSSL:10m;  # about 40000 sessions</span><br><span class="line">    ssl_session_tickets off;</span><br><span class="line"></span><br><span class="line">    # curl https://ssl-config.mozilla.org/ffdhe2048.txt &gt; /path/to/dhparam</span><br><span class="line">    ssl_dhparam /path/to/dhparam;</span><br><span class="line"></span><br><span class="line">    # intermediate configuration</span><br><span class="line">    ssl_protocols TLSv1.2 TLSv1.3;</span><br><span class="line">    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;</span><br><span class="line">    ssl_prefer_server_ciphers off;  # 需要使用的时候改为on即可</span><br><span class="line"></span><br><span class="line">    # HSTS (ngx_http_headers_module is required) (63072000 seconds)</span><br><span class="line">    add_header Strict-Transport-Security &quot;max-age=63072000&quot; always;</span><br><span class="line"></span><br><span class="line">    # OCSP stapling</span><br><span class="line">    ssl_stapling on;</span><br><span class="line">    ssl_stapling_verify on;</span><br><span class="line"></span><br><span class="line">    # verify chain of trust of OCSP response using Root CA and Intermediate certs</span><br><span class="line">    ssl_trusted_certificate /path/to/root_CA_cert_plus_intermediates;</span><br><span class="line"></span><br><span class="line">    # replace with the IP address of your resolver</span><br><span class="line">    resolver 127.0.0.1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、禁用不需要的-HTTP-方法"><a href="#5、禁用不需要的-HTTP-方法" class="headerlink" title="5、禁用不需要的 HTTP 方法"></a>5、禁用不需要的 HTTP 方法</h3><p>常用的 HTTP 方法是 GET 和 POST，如果允许其他方法如 TRACE、DELETE、PUT 和 OPTIONS 是有风险的，因为这可能允许攻击者发起<code>跨站点跟踪攻击</code>并从您的网站窃取 <code>cookie</code> 信息，因此建议禁用不需要的和未使用的 HTTP 方法。</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置方式1：此时，服务器将只允许 GET、HEAD 和 POST 方法。</span></span><br><span class="line">location / &#123;</span><br><span class="line">    limit_except GET HEAD POST &#123; deny all; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置方式2：效果同1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务器只允许 GET、HEAD 和 POST 方法，并通过发出 444 No Response 状态代码过滤掉任何其他 HTTP 方法。</span></span><br><span class="line">if ($request_method !~ ^(GET|HEAD|POST)$ )</span><br><span class="line">&#123;</span><br><span class="line">    return 444;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、防止缓冲区溢出攻击"><a href="#6、防止缓冲区溢出攻击" class="headerlink" title="6、防止缓冲区溢出攻击"></a>6、防止缓冲区溢出攻击</h3><p>缓冲区是系统内存中的一个小型存储位置，当数据开始从一个内存位置传输到另一个内存位置时，它可以暂时容纳数据。当数据大小超过缓冲区大小的容量时，就会发生缓冲区溢出。因此，攻击者可以利用此漏洞注入可以危害系统的恶意代码。</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">client_body_buffer_size 1K;</span><br><span class="line">client_header_buffer_size 1k;</span><br><span class="line">client_max_body_size 1k;</span><br><span class="line">large_client_header_buffers 2 1k;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其值如何设置，具体参考《Nginx性能优化》篇</span></span><br></pre></td></tr></table></figure><h3 id="7、防止-CSP、XSS-攻击"><a href="#7、防止-CSP、XSS-攻击" class="headerlink" title="7、防止 CSP、XSS 攻击"></a>7、防止 CSP、XSS 攻击</h3><p>CSP（内容安全策略）是额外的安全层，有助于缓解某些攻击，如 XSS 跨站脚本攻击。通过添加 CSP 标头，可以告诉浏览器它只能从你明确允许的域下载内容，包括 Javascript 和 CSS 文件。</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_header Content-Security-Policy &quot;default-src &#x27;self&#x27; http: https: data: blob: &#x27;unsafe-inline&#x27;&quot; always;</span><br></pre></td></tr></table></figure><p>针对 XSS 跨站脚本攻击，可做以下参数配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_header X-XSS-Protection &quot;1; mode=block&quot;;</span><br></pre></td></tr></table></figure><h3 id="8、防止-Click-jacking-劫持"><a href="#8、防止-Click-jacking-劫持" class="headerlink" title="8、防止 Click-jacking 劫持"></a>8、防止 Click-jacking 劫持</h3><p>Click-jacking（即点击劫持）是一种 Web 应用程序漏洞，攻击者利用该漏洞强制用户在未经用户同意的情况下点击，导致重定向到未知网站。HTTP 响应标头中的 X-Frame -Option 可用于指示 Web 浏览器是否应在框架或 iframe 中加载页面。因此，在 nginx.conf 文件的 HTTP 标头中附加 X-Frame-Options，这将指示浏览器仅从同一来源加载资源。</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_header X-Frame-Options &quot;SAMEORIGIN&quot;;</span><br></pre></td></tr></table></figure><h3 id="9、禁用内容嗅探"><a href="#9、禁用内容嗅探" class="headerlink" title="9、禁用内容嗅探"></a>9、禁用内容嗅探</h3><p>内容嗅探，也称为 <code>MIME（Multipurpose Internet Mail Extensions）</code>嗅探，即<code>多用途网络邮件扩展</code>嗅探，是一种用于检查字节流内容以确定其中数据的文件格式的技术。这也可能导致安全漏洞，因为攻击者可以利用 MIME 嗅探来发送 XSS 跨站点脚本攻击。</p><p>例如，如果你的网站允许用户上传图片等媒体内容，攻击者可能会上传包含一些 JavaScript 代码的恶意图片文件。当浏览器进行内容嗅探时，可能会被诱骗执行该恶意文件。为了防止内容嗅探攻击，可将 <code>X-Content-Type-Options</code> 响应标头设置为 <code>nosniff</code>，这告诉浏览器避免猜测响应类型并仅依赖 <code>Content-Type</code> 头。</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_header X-Content-Type-Options nosniff;</span><br></pre></td></tr></table></figure><h3 id="10、图片防盗链"><a href="#10、图片防盗链" class="headerlink" title="10、图片防盗链"></a>10、图片防盗链</h3><p>“图片防盗链”顾名思义就是防止别人盗用你的图片链接，这可能会导致你的带宽使用量增加，尤其是在现的服务器带宽使用策略中基本上都是按量付费的，因此这可能会间接性造成你们公司经济损失。</p><p>例如，假设在你 web 服务器根目录中有一个名为 images 的目录，其中存储了你在站点中使用的所有图像。为了防止其他方使用你的图像，你需要在 Nginx web 服务器上做如下配置。</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /images/ &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">只允许www.hello.com hello.com请求资源</span></span><br><span class="line">  valid_referers none blocked www.hello.com hello.com;</span><br><span class="line">   if ($invalid_referer) &#123;</span><br><span class="line">     return   403;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11、启用-HSTS-功能"><a href="#11、启用-HSTS-功能" class="headerlink" title="11、启用 HSTS 功能"></a>11、启用 HSTS 功能</h3><p>HSTS 功能只允许客户端（Web 浏览器）使用 HTTPS 进行通信，这 return 和 rewrite 方法的概念不同。当浏览器接收到 HSTS 标头时，它不会在指定的时间内以 HTTP 的形式与 web 服务端通信，保证了 HTTPS 严格安全传输问题。</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_header Strict-Transport-Security &quot;max-age=31536000; includeSubDomains&quot; always;</span><br></pre></td></tr></table></figure><h3 id="12、仅允许通过域名访问"><a href="#12、仅允许通过域名访问" class="headerlink" title="12、仅允许通过域名访问"></a>12、仅允许通过域名访问</h3><p>上线过 web 应用的同志都知道，上线完成后 IP 或域名形式我们都可以访问，如果你不想允许使用 IP 地址的请求，那只需要在 Nginx 做以下配置即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ($host !~ ^(hello.com|www.hello.com)$ ) &#123;</span><br><span class="line">    return 301 https://hello.com$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13、禁止自动用户代理"><a href="#13、禁止自动用户代理" class="headerlink" title="13、禁止自动用户代理"></a>13、禁止自动用户代理</h3><p>为了保护你的服务器免受机器人、脚本和其他自动网页检索方法的侵害，请明确拒绝这些用户代理。</p><p>例如，像 wget 这样的应用程序可以检索整个文档根目录结构，使它们成为有用的 DoS 攻击者或只是访问网站上的受保护文件。</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ($http_user_agent ~* LWP::Simple|BBBike|wget) &#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14、防止服务器信息泄露"><a href="#14、防止服务器信息泄露" class="headerlink" title="14、防止服务器信息泄露"></a>14、防止服务器信息泄露</h3><p>什么意思呢？Nginx 服务器的默认配置 server_tokens 指令在所有自动生成的错误页面以及 HTTP 响应标头上会显示 Nginx 版本号，我在之前做的一个项目中就存在这个问题，当时客户的安全工程师用工具扫出了这个问题。这可能会导致 web 服务器信息泄露，攻击者可以获得有关 Nginx 版本的信息，从而缩小攻击范围。因此，我们必须禁止在客户端（浏览器）显示 Nginx 版本号等相关信息。</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server_tokens off;</span><br></pre></td></tr></table></figure><h3 id="15、禁止指定浏览器访问"><a href="#15、禁止指定浏览器访问" class="headerlink" title="15、禁止指定浏览器访问"></a>15、禁止指定浏览器访问</h3><p>如果我们不希望有些浏览器访问我们 web 服务，则可做以下设置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">功能：如果是火狐或IE浏览器，则将会跳转到百度页面</span> </span><br><span class="line"></span><br><span class="line">if ($http_user_agent ~* &quot;Firefox|MSIE&quot;) &#123;</span><br><span class="line">    rewrite ^(.*) http://www.baidu.com/$1 permanent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16、升级-Nginx-版本"><a href="#16、升级-Nginx-版本" class="headerlink" title="16、升级 Nginx 版本"></a>16、升级 Nginx 版本</h3><p>建议将您的 Nginx 服务器更新到最新和稳定的版本，因为有很多性能改进、安全修复和新功能实现。</p><hr><h5 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h5><blockquote><p>通过上面的基础配置，现整合出完整的配置</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">==========全局配置文件============</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">避免 Nginx 版本信息泄露</span></span><br><span class="line">server_tokens off;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">防止 Click-jacking 点击劫持</span></span><br><span class="line">add_header X-Frame-Options SAMEORIGIN;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">禁用内容嗅探，防止 XSS 跨站脚本攻击</span></span><br><span class="line">add_header X-Content-Type-Options nosniff;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CSP 内容安全策略，告诉浏览器它只能从你明确允许的域下载内容，防止 XSS 跨站脚本攻击</span></span><br><span class="line">add_header X-XSS-Protection &quot;1; mode=block&quot;;</span><br><span class="line">add_header Content-Security-Policy &quot;default-src &#x27;self&#x27; http: https: data: blob: &#x27;unsafe-inline&#x27;&quot; always;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用 HSTS 功能，只允许客户端（Web 浏览器）使用 HTTPS 进行通信，保证了 HTTPS 严格安全传输问题。</span></span><br><span class="line">add_header Strict-Transport-Security &quot;max-age=31536000; includeSubDomains&quot; always;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">防止缓冲区溢出攻击，免密攻击者恶意代码注入</span></span><br><span class="line">client_body_buffer_size 1K;</span><br><span class="line">client_header_buffer_size 1k;</span><br><span class="line">client_max_body_size 1k;</span><br><span class="line">large_client_header_buffers 2 1k;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">==========虚拟主机配置============</span></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    listen [::]:80 default_server;</span><br><span class="line">    server_name hello.com;</span><br><span class="line">    return 301 https://$host$request_uri;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl http2;</span><br><span class="line">    listen [::]:443 ssl http2;</span><br><span class="line">    server_name hello.com;</span><br><span class="line"></span><br><span class="line">    # SSL/TLS 证书/密钥</span><br><span class="line">    ssl_certificate     /etc/nginx/ssl/bundle.pem;</span><br><span class="line">    ssl_certificate_key /etc/nginx/ssl/hello.com.key;</span><br><span class="line"></span><br><span class="line">    # DH 密钥交换机制，会话密钥在会话终止时被删除，攻击者无法检索双方之间交换的消息。</span><br><span class="line">    ssl_dhparam /etc/nginx/ssl/dhparam.pem;</span><br><span class="line"></span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">    # 禁用旧的 SSL/TLS 协议</span><br><span class="line">    ssl_protocols TLSv1.2 TLSv1.3;</span><br><span class="line"></span><br><span class="line">    # 禁用 SSL/TLS 弱密码套件</span><br><span class="line">    ssl_ciphers &#x27;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&#x27;;+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&#x27;;</span><br><span class="line"></span><br><span class="line">    # 禁用不需要的 HTTP 方法</span><br><span class="line">    if ($request_method !~ ^(GET|HEAD|POST)$ )&#123;</span><br><span class="line">        return 444;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 图片防盗链</span><br><span class="line">    location /images/ &#123;</span><br><span class="line">        valid_referers none blocked www.hello.com mytechnix.com;</span><br><span class="line">        if ($invalid_referer) &#123;</span><br><span class="line">            return   403;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    # 仅允许通过域名形式访问 web 服务器</span><br><span class="line">    if ($host !~ ^(hello.com|www.hello.com)$ ) &#123;</span><br><span class="line">        return 301 https://hello.com$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line">    # 禁止自动用户代理，防止 Dos 攻击</span><br><span class="line">    if ($http_user_agent ~* LWP::Simple|BBBike|wget) &#123;</span><br><span class="line">        return 403;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 优化篇 </category>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 性能优化</title>
      <link href="/posts/articles/31a3358a.html"/>
      <url>/posts/articles/31a3358a.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230413105645046.png" alt="image-20230413105645046"></p><hr><h3 id="1、调整-worker-进程数"><a href="#1、调整-worker-进程数" class="headerlink" title="1、调整 worker 进程数"></a>1、调整 worker 进程数</h3><p>nginx 有一个 master 进程和多个 work 进程。master 进程的主要目的是读取和评估配置，并维护 work 进程。work 进程对请求进行实际处理。在高并发、高访问的场景下，需要提前启动更多的 nginx 进程，以保证快速响应，处理大量并发用户的请求。</p><p>现在的服务器基本上都是多线程和多进程的，而 Nginx 默认不允许处理多个工作负载，因此你可以修改配置文件中<code>worker_processes</code>参数使其作为多线程 web 服务器来工作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看CPU核心数</span></span><br><span class="line">grep processor /proc/cpuinfo | wc -l</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">于是可设置工作进程为4并绑定到不同CPU</span></span><br><span class="line">worker_processes  2;  # 如果设置未auto，就不需要手动绑定，它会自动绑定</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果你的服务器是2核</span></span><br><span class="line">worker_cpu_affinity 0101 1010;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果你的服务器是4核</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">worker_cpu_affinity 0001 0010 0100 1000;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果你的服务器是8核</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;</span></span><br></pre></td></tr></table></figure><p>这里放一个 <code>worker_cpu_affinity</code> 的计算脚本，该脚本会根据你服务器的 CPU 核数来自动计算 <code>worker_cpu_affinity</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># @file: nginx-affinity.sh</span></span><br><span class="line"><span class="comment"># @brief:</span></span><br><span class="line"><span class="comment"># @author: YoungJoo.Kim &lt;http://vozlt.com&gt;</span></span><br><span class="line"><span class="comment"># @version:</span></span><br><span class="line"><span class="comment"># @date:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Linux only.</span></span><br><span class="line"><span class="comment"># Nginx worker_cpu_affinity</span></span><br><span class="line"><span class="comment"># http://wiki.nginx.org/CoreModule</span></span><br><span class="line"></span><br><span class="line">n=$(awk <span class="string">&#x27;/^processor/&#123;n=$3&#125; END&#123;print n&#125;&#x27;</span> /proc/cpuinfo)</span><br><span class="line">aff=$(<span class="built_in">printf</span> <span class="string">&quot;0%0<span class="variable">$&#123;n&#125;</span>d&quot;</span> 0)</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;worker_processes %d;\n&quot;</span> $((n+<span class="number">1</span>))</span><br><span class="line">[ <span class="variable">$n</span> -eq 0 ] &amp;&amp; <span class="built_in">exit</span>;</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;worker_cpu_affinity &quot;</span></span><br><span class="line"><span class="keyword">for</span> ((a=<span class="number">0</span>; a &lt;= n; a++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    poss=$((n - a))</span><br><span class="line">    pose=$((n - poss))</span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$pose</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">printf</span> <span class="string">&quot;%0<span class="variable">$&#123;poss&#125;</span>d1&quot;</span> 0</span><br><span class="line">    <span class="keyword">elif</span> [ <span class="variable">$poss</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">        [ <span class="variable">$poss</span> -eq 0 ] &amp;&amp; <span class="built_in">printf</span> <span class="string">&quot;1%0<span class="variable">$&#123;pose&#125;</span>d&quot;</span> 0</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        [ <span class="variable">$pose</span> -ne 0 ] &amp;&amp; <span class="built_in">printf</span> <span class="string">&quot;%0<span class="variable">$&#123;poss&#125;</span>d1%0<span class="variable">$&#123;pose&#125;</span>d&quot;</span> 0 0</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    [ <span class="variable">$n</span> != <span class="variable">$a</span> ] &amp;&amp; <span class="built_in">echo</span> -n <span class="string">&quot; &quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;;&quot;</span>;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221221103441811.png" alt="image-20221221103441811"></p><h3 id="2、调整-worker-连接数"><a href="#2、调整-worker-连接数" class="headerlink" title="2、调整 worker 连接数"></a>2、调整 worker 连接数</h3><p><code>work 连接数</code>与<code>work 进程数</code>息息相关，可通过 <code>worker_connections</code> 参数设置 work 连接数。worker_connections 参数用于设置 Nginx 单个 work 进程（worker_processes）允许的最大客户端连接数。</p><p>而 Nginx 默认的 1024 在生产环境来说是比较小的，因此需要调整该参数。该配置参数位于 events 事件中，Linux 中 nginx 采用 epoll 的 I&#x2F;O 复用模型，FreeBSD 中使用 kqueue 的 I&#x2F;O 复用模型，Solaris 中使用 &#x2F;dev&#x2F;poll 的 I&#x2F;O 复用模型，Windows中使用 ICOP 等。</p><p>因此，我们需要针对不同的系统类型来选择不同的事件处理模型。我用的是 CentOS 7，所以把 nginx 的事件处理模型调整为 epoll 模型。</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    use epoll;</span><br><span class="line">    worker_connections  20240;</span><br><span class="line">    multi_accept on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个参数也是需要注意的，就是 <code>multi_accept on</code>，该参数告诉 nginx 收到一个新连接通知后接受尽可能多的连接，<code>默认是on</code>，且为串行处理连接数。当为 off 时为并行处理连接数，即多个 work 进程同时处理连接。因此，<code>当你的客户端连接数较少时，参数值置为 on，相反在连接数较多、服务器吞吐量较大时，参数值置 off，可提高 Nginx 性能。</code></p><p>当然，这个 work 连接数也不是说可无限设置大，它和系统自身<code>内存</code>、<code>最大文件打开数</code>有关。一个连接分别对应一个 <code>read_event</code> 和一个 <code>write_event</code> 事件。一个连接本身占用 232 字节左右，两个事件总占 96 字节左右，于是一个连接（连接 + read_event + write_event）总共就占 328 字节。</p><p>因此，上面的 20240 的连接数就会占用 20240*328&#x2F;1024&#x2F;1024 &#x3D; 6M 大小内存。</p><p>在来看看 worker 进程最大打开文件数，该值其实在我们设置系统最大打开文件数的时候已经指定（*&#x2F;指定用户），如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/security/limits.conf</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">root soft nofile 65535</span><br><span class="line">root hard nofile 65535</span><br><span class="line">* soft nofile 65535</span><br><span class="line">* hard nofile 65535</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">End of file</span></span><br></pre></td></tr></table></figure><p>因此，只需要设置 <code>worker_rlimit_nofile</code> 值为以上 65535 值即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置Nginx worker进程最大打开文件数</span></span><br><span class="line">worker_rlimit_nofile 65535;</span><br></pre></td></tr></table></figure><h3 id="3、调整-work-进程最大打开文件数"><a href="#3、调整-work-进程最大打开文件数" class="headerlink" title="3、调整 work 进程最大打开文件数"></a>3、调整 work 进程最大打开文件数</h3><p>接下来调整配置 nginx 的 worker 进程的最大打开文件数，控制连接数的参数是 <code>worker_rlimit_nofile</code>，该值与 nginx 所在操作系统的最大打开文件数相关，也就是你 nginx 的 work 进程最大打开文件数必须小于或等于自身操作系统的最大打开文件数，要不然设置了也是没意义的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先查看系统自身最大打开文件数</span></span><br><span class="line">ulimit -n</span><br><span class="line">65536</span><br></pre></td></tr></table></figure><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">控制在系统最大打开文件数内即可</span></span><br><span class="line">worker_rlimit_nofile 65536;</span><br></pre></td></tr></table></figure><p>需要注意：</p><h3 id="4、开启高效文件传输模式"><a href="#4、开启高效文件传输模式" class="headerlink" title="4、开启高效文件传输模式"></a>4、开启高效文件传输模式</h3><p><code>sendfile on|off</code> 参数用于启用高效文件传输模式，默认是 off 的，作用域：http、server、location。该参数通常结合 <code>tcp_nopush on|off</code> 参数和 <code>tcp_nodelay on|off</code> 来防止网络和磁盘 I&#x2F;O 阻塞，提升 nginx 效率。当开启 sendfile 后 <code>tcp_nopush on|off</code> 参数和 <code>tcp_nodelay on|off</code> 只能二选一，而且开启 sendfile 后默认启用的是 <code>tcp_nopush on</code>。</p><ul><li><strong>tcp_nopush on|off</strong>：该参数会启用 tcp_cork 方法，仅当 sendfile 开启后生效，其功能是：当应用程序收到数据包时不会马上传送出去，而是等到数据包最大时，才一次性的传输出去。这样解决了网络堵塞问题。</li><li><strong>tcp_nodelay on|off</strong>：该参数会启用 tcp_nodelay 方法，其功能是：当应用程序收到数据包时会尽量发送小数据块，而不是等一定数据量满了之后才发送。这样解决了磁盘I&#x2F;O问题。</li></ul><p>如何选择？下面注释写得比较清楚</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sendfile on;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决网络拥塞问题</span></span><br><span class="line">tcp_nopush on;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决磁盘I/O问题</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcp_nodelay on;</span></span><br></pre></td></tr></table></figure><h3 id="5、限制文件上传大小"><a href="#5、限制文件上传大小" class="headerlink" title="5、限制文件上传大小"></a>5、限制文件上传大小</h3><p><code>限制文件上传大小</code> 指的是 <code>限制 HTTP 请求正文大小</code>，通过 <code>client_ max_ body_ Size</code> 参数设置。如果上传文件的大小超过此设置，则会响应 <code>413 Request Entity Too Large</code> 错误代码。如果服务器涉及上传文件的业务，就可以通过该参数来限制。</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client_max_body_Size 10m;</span><br></pre></td></tr></table></figure><p>nginx 对上传文件大小默认为 1m 大小，如果很大，还要适当调整上传超时时间。</p><ul><li><strong>client_header_timeout</strong>：读取请求头的超时时间，默认60秒。若超过所设定的大小，返回 408 错误。</li><li><strong>client_body_timeout</strong>：读取请求实体的超时时间，默认60秒。若超过所设定的大小，返回 413 错误。</li></ul><p>作为代理时的超时时间：</p><ul><li><strong>proxy_connect_timeout</strong>：HTTP 请求无法立即被容器（tomcat, netty 等）处理，被放在 nginx 的待处理池中等待被处理超时时间。默认为 60s，官方推荐最长不要超过 75s。</li><li><strong>proxy_read_timeout</strong>：HTTP 请求被容器（tomcat, netty 等）处理完后，nginx 等待处理结果的时长，默认60秒。</li><li><strong>proxy_send_timeout</strong>：HTTP 请求被容器（tomcat, netty 等）处理完后，把数据传返回给 nginx 的时长，默认60秒。</li></ul><p>最终配置参考：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">client_max_body_Size 10m;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其实以下参数你不配置，它都是默认生效的</span></span><br><span class="line">client_header_timeout 60;</span><br><span class="line">client_body_timeout 60;</span><br><span class="line">proxy_connect_timeout 60;</span><br><span class="line">proxy_read_timeout 60;</span><br><span class="line">proxy_send_timeout 60;</span><br></pre></td></tr></table></figure><h3 id="6、开启-gzip-压缩"><a href="#6、开启-gzip-压缩" class="headerlink" title="6、开启 gzip 压缩"></a>6、开启 gzip 压缩</h3><p>gzip 压缩模块提供了压缩文件内容的功能，在用户请求的内容发送到用户客户端之前，nginx 服务器会根据一些具体的策略执行压缩策略，从而节省网站的出口带宽，加快数据传输效率，提升用户体验。</p><p><code>最好是在有大文件时启用它，因为它本身也会消耗CPU资源。</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gzip  on;</span><br><span class="line">gzip_min_length  1k;</span><br><span class="line">gzip_buffers     4 16k;</span><br><span class="line">gzip_http_version 1.1;</span><br><span class="line">gzip_comp_level 9;</span><br><span class="line">gzip_types text/plain text/javascript application/javascript text/css application/xml application/json;</span><br><span class="line">gzip_disable &quot;MSIE [1-6]\.&quot;;</span><br><span class="line">gzip_vary on;</span><br></pre></td></tr></table></figure><h3 id="7、本地缓存静态资源"><a href="#7、本地缓存静态资源" class="headerlink" title="7、本地缓存静态资源"></a>7、本地缓存静态资源</h3><p>每个网站都有页面、图像和其他内容，这些内容在访问者在网站上的会话期间基本保持不变。现代网页上几乎 30% 的数据是静态的，应该缓存这些内容以提高 Nginx 的性能。</p><p>优点：</p><ul><li>静态资源加载快：因为不经过 Nginx 连接请求；</li><li>降低了 Nginx 的连接请求压力：可降低 Nginx 服务器负载。</li></ul><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ~* .(jpg|jpeg|png|gif|ico|css|js)$ &#123;</span><br><span class="line">    expires 365d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">该语句将会在客户端（浏览器）请求后，将这些静态资源缓存于本地（浏览器），并且设置有效期365天</span></span><br></pre></td></tr></table></figure><h3 id="8、调整缓冲区大小"><a href="#8、调整缓冲区大小" class="headerlink" title="8、调整缓冲区大小"></a>8、调整缓冲区大小</h3><ul><li><p><strong>Client_header_buffer_size</strong>：限制客户端（浏览器）请求头大小，一般设置为 1k 左右。如果（请求行 + 请求头）的大小如果没超过1k，则放行请求。如果（请求行 + 请求头）的大小如果超过1k，则以<code>large_client_header_buffers</code>配置为准决定是否放行。</p></li><li><p><strong>large_client_header_buffers</strong>：Client_header_buffer_size 的最大值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如：</span></span><br><span class="line">large_client_header_buffers 2 1k</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">请求行不能超过1k，否则返回414错误代码</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">请求头不能超过1k，否则返回400错误代码</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">请求行+请求头不能超过2k（2*1k），否则报错</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Client_body_buffer_size</strong>：客户端（浏览器）在 web 网站上发布请求的缓冲区大小，一般设置 128k 左右。</p></li><li><p><strong>Client_max_body_size</strong>：客户端（浏览器）在 web 网站上发布请求的最大主体大小，比如设置为 10m，当超过该值将向客户端返回 <code>Request Entity Too Large</code> 错误。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client_header_buffer_size 1k；</span><br><span class="line">large_client_header_buffers 2 1k;  # 这里是2个1k的大小（即最大为2*1K=2K）</span><br><span class="line">client_body_buffer_size 128k；</span><br><span class="line">client_max_body_size 10m；</span><br></pre></td></tr></table></figure><h3 id="9、尽可能少使用-if-检查-server-name-语句"><a href="#9、尽可能少使用-if-检查-server-name-语句" class="headerlink" title="9、尽可能少使用 if 检查 server_name 语句"></a>9、尽可能少使用 if 检查 server_name 语句</h3><p>你想想，每一个请求连接进来都要进行一次 if 判断，这势必会增加 web 服务器开销，尤其是在十万&#x2F;百万并发场景下。因此，你也可以在 if 语句层面来优化。</p><p>例如：server_name 指定 hello.com 和 <a href="http://www.hello.com/">www.hello.com</a> 两个域名，当 Nginx 收到请求时，无论请求的是哪个子域，如果始终对 if 指令进行评估，那效率都是很低的。</p><ul><li><p>低效率配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  server_name     hello.com www.hello.com;</span><br><span class="line">  if ($host = www.hello.com) &#123;</span><br><span class="line">    return   301 https://hello.com$request_uri;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>高效率配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name      www.hello.com;</span><br><span class="line">    return           301 $scheme://hello.com$request_uri;</span><br><span class="line">    ## If you force your web traffic to use HTTPS:</span><br><span class="line">    # return 301 https://domain.com$request_uri;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="10、避免过多正则表达"><a href="#10、避免过多正则表达" class="headerlink" title="10、避免过多正则表达"></a>10、避免过多正则表达</h3><ul><li><p>低效率配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">rewrite ^/(.*)$ https://example.com/$1 permanent;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">rewrite ^ https://example.com$request_uri? permanent;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>高效率配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">return 301 https://example.com$request_uri;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$request_uri</span>就是完整url中刨去最前面<span class="variable">$host</span>剩下的部分</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比如：http://www.baidu.com/test</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">那么<span class="variable">$request_uri</span>的值就是/test</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果只有：http://www.baidu.com，那么<span class="variable">$request_uri</span>的值就是/</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h3 id="11、return-代替-rewrite-实现重定向"><a href="#11、return-代替-rewrite-实现重定向" class="headerlink" title="11、return 代替 rewrite 实现重定向"></a>11、return 代替 rewrite 实现重定向</h3><ul><li><p>低效率配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  ...</span><br><span class="line">  if ($host = api.domain.com) &#123;</span><br><span class="line">    rewrite     ^/(.*)$ http://example.com/$1 permanent;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>高效率配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  ...</span><br><span class="line">  if ($host = api.domain.com) &#123;</span><br><span class="line">    return      403;</span><br><span class="line">    ## or other examples:</span><br><span class="line">    ##   return    301 https://domain.com$request_uri;</span><br><span class="line">    ##   return    301 $scheme://$host$request_uri;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="12、使用-try-files-指令确认文件是否存在"><a href="#12、使用-try-files-指令确认文件是否存在" class="headerlink" title="12、使用 try_files 指令确认文件是否存在"></a>12、使用 try_files 指令确认文件是否存在</h3><ul><li><p>低效率配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">root /var/www/example.com;</span><br><span class="line">location /images &#123;</span><br><span class="line">  if (-f $request_filename) &#123;</span><br><span class="line">    expires 30d;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>高效率配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  ...</span><br><span class="line">  root /var/www/example.com;</span><br><span class="line">  location /images &#123;</span><br><span class="line">    try_files $uri $uri/ =404;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比如，我请求 http://www.hello.com/images  那<span class="variable">$uri</span>的值就是/images</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$uri</span>：Nginx 首先判断images是否是个文件且存不存在，如果是且存在则返回，否则继续<span class="variable">$uri</span>/判断</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$uri</span>/：Nginx 再次判断images/是否是个目录且存不存在，如果是且存在则返回，否则将返回404错误代码</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="13、设置-keepalive-timeout"><a href="#13、设置-keepalive-timeout" class="headerlink" title="13、设置 keepalive_timeout"></a>13、设置 keepalive_timeout</h3><p>一般地，在我们的 web 网站中，为了避免同一个客户长时间占用连接，造成资源浪费，可设置相应的超时时间，实现对连接访问时间的控制。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">keepalive_timeout 65 180</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一个参数值65：表示客户发送请求头的超时时间，服务器会在这个时间之后关闭连接</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第二个参数值180：表示请求体读超时时间，客户端（浏览器）会在这个时间后关闭连接</span></span><br></pre></td></tr></table></figure><p>企业生产环境中，我们一般设置为该值就可以了（当然也需要根据实际情况来调整）。</p><h3 id="14、TCP-backlog"><a href="#14、TCP-backlog" class="headerlink" title="14、TCP_ backlog"></a>14、TCP_ backlog</h3><p>在 TCP 的优化一节中，我们提到了<code>tcp_max_syn_backlog</code>参数，该参数为 Linux 内核级别，指的是 TCP 半连接队列长度，而我们的 web 服务，如： nginx、tomcat、Apache 的默认值均为 511，因此我们可以根据不同 web 服务进行调整。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server ｛</span><br><span class="line">    listen 8089 default backlog=1024;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    ....</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><h3 id="15、日志文件轮转"><a href="#15、日志文件轮转" class="headerlink" title="15、日志文件轮转"></a>15、日志文件轮转</h3><p>随着业务量的增加，web 服务的日志访问量也越来越大，久而久之将会耗尽系统磁盘空间。因此，日志轮转就显得非常重要了，有关日志轮转的相关知识的可查看我之前的博文<a href="https://blog.csdn.net/IT_ZRS/article/details/108418623?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165166874716782425159797%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=165166874716782425159797&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-108418623.nonecase&utm_term=%E6%97%A5%E5%BF%97%E8%BD%AE%E8%BD%AC&spm=1018.2226.3001.4450">《Linux系统之计划任务及日志轮转》</a>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑nginx轮转文件</span></span><br><span class="line">cat /etc/logrotate.d/nginx</span><br><span class="line"></span><br><span class="line">/data/nginx/logs/access.log &#123;</span><br><span class="line">    missingok   # 丢失不提醒</span><br><span class="line">    notifempty  # 空文件不轮转</span><br><span class="line">    maxsize 4G  # 只要到了4G日志大小就轮转</span><br><span class="line">    rotate 4    # 保留文件数</span><br><span class="line">    daily       # 每天轮转一次</span><br><span class="line">    create 0600 root root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志轮转可配合计划任务来实现自动轮转！！</p>]]></content>
      
      
      <categories>
          
          <category> 优化篇 </category>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8s 应用版本升级与回退</title>
      <link href="/posts/articles/b808de0b.html"/>
      <url>/posts/articles/b808de0b.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/k8s-cert.png" alt="k8s-cert"></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Rolling Update</code> 即滚动更新，先更新一部分副本，成功后再继续更新更多副本，最终完成所有的副本更新。前面说到动态伸缩容并不会触发上线，仅当 Deployment Pod 模板（即 <code>.spec.template</code>）发生改变时才会触发上线。且上线实现了滚动特点，其好处就是无需停服的状态下即可完成服务升级，从而保证了业务的连续性。</p><p>接下来以更新 Nginx 容器镜像的版本号为例进行演示与验证。</p><h2 id="一、升级"><a href="#一、升级" class="headerlink" title="一、升级"></a>一、升级</h2><p>刚刚把副本数从 <code>2 ——&gt; 3</code>，执行 <code>kubectl apply -f nginx.yml</code> 启动服务，可看到并没有触发上线&#x2F;滚动更新：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220143311821.png" alt="image-20221220143311821"></p><p>接着修改镜像的版本号，从 <code>1.20.0 ——&gt; 1.21.4</code>：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220143737833.png" alt="image-20221220143737833"></p><p>再次启动服务，看看镜像版本是否已更新：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220144111103.png" alt="image-20221220144111103"></p><p>看看 Pod 是否正常运行：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220144225750.png" alt="image-20221220144225750"></p><p><mark>小结：</mark>可看到，原来 <code>ReplicaSet nginx-6b6cf7569</code> 的三个 <code>nginx:1.20.0 Pod</code>已经被<code>ReplicaSet nginx-7bfd89cc74</code>的三个<code>nginx:1.21.4 Pod</code>替换了。</p><p>再来看看 <code>deployment</code> 的详情，看看具实现过程：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe deployment nginx</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220144900690.png" alt="image-20221220144900690"></p><p>其流程就是：</p><ul><li><code>ReplicaSet nginx-7bfd89cc74</code> 新增一个 Pod，总数为 1；</li><li><code>ReplicaSet nginx-6b6cf7569</code> 减少一个 Pod，总数为 2（也就是说至少还有两个 Pod 是正常对外提供服务的）；</li><li><code>ReplicaSet nginx-7bfd89cc74</code> 新增一个 Pod，总数为 2；</li><li><code>ReplicaSet nginx-6b6cf7569</code> 减少一个 Pod，总数为 1（也就是说至少还有一个 Pod 是正常对外提供服务的）；</li><li><code>ReplicaSet nginx-7bfd89cc74</code> 新增一个 Pod，总数为 3；</li><li><code>ReplicaSet nginx-6b6cf7569</code> 减少一个 Pod，总数为 0（此时 <code>ReplicaSet nginx-6b6cf7569</code> 已经没有 Pod 了）。</li></ul><p><mark>可看到，其更新方式是以滚动的形式实现的，从而保证了业务的连续性。</mark></p><h2 id="二、回滚"><a href="#二、回滚" class="headerlink" title="二、回滚"></a>二、回滚</h2><p>K8s 在每次 <code>kubectl apply</code> 更新应用时，都会记录当前的配置，比如我原本的 Nginx 镜像为 1.20.0，那这个 1.20.0 及其其他信息都会被记录下来，其目的就是方便我们上线失败后可以回到正常的那个镜像版本。</p><p>默认情况下，K8s 只会保留近 10 个的 <code>revision</code>，我们可以在 Deployment 配置文件中使用 <code>revisionHistoryLimit</code> 字段来指定 revision 的保留数量。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit deployment nginx</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220150436717.png" alt="image-20221220150436717"></p><p>看看可回滚的历史版本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout <span class="built_in">history</span> deployment nginx</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220151203399.png" alt="image-20221220151203399"></p><p>虽然可看到有 2、3、4 这三个可会退的版本，但是 <code>CHANGE-CAUSE</code> 这个字段均为 <code>&lt;none&gt;</code>，这就不太利于我们进行版本会退，想要显示<code>CHANGE-CAUSE</code> 值，需要在 <code>kubectl apply</code> 时添加 <code>--record</code> 参数。所以这里重新在写两个 Deployment 的 YML 文件再来启动服务。</p><ul><li><p>nginx-a.yml</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220151707689.png" alt="image-20221220151707689"></p></li><li><p>nginx-b.yml</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220151801454.png" alt="image-20221220151801454"></p></li></ul><p>分别进行 <code>kubectl apply</code> 更新应用：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx-a.yml --record</span><br><span class="line">kubectl apply -f nginx-b.yml --record</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220152324505.png" alt="image-20221220152324505"></p><p>这样就能看到你是指定的哪个 YAML 文件启动的，但是这个 <code>--record</code> <mark>已经被弃用了</mark>，除了这种方法之外，我们可以通过指定具体的 revision 编号来查看其详细信息，这样你就可以根据实际情况会退到具体版本，比如我们查看 revision 为 4 的版本信息。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout <span class="built_in">history</span> deployment nginx --revision=4</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220153002310.png" alt="image-20221220153002310"></p><p>版本会退验证：</p><ul><li><p>先看看当前的 Pod 的 image 版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get deployment nginx -o wide</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220153136787.png" alt="image-20221220153136787"></p></li><li><p>比如就回到我们 revision 为 4 的版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout undo deployment nginx --to-revision=4</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220153805798.png" alt="image-20221220153805798"></p></li><li><p>会退完成，再次验证当前 image 镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get deployment nginx -o wide</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220154136759.png" alt="image-20221220154136759"></p><blockquote><p>可看到版本会退成功！</p></blockquote></li></ul><p><mark>以上就是 K8s Pod 版本升级&#x2F;回滚的详细流程。</mark></p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> K8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8s 的 DNS 机制</title>
      <link href="/posts/articles/6d84ddb0.html"/>
      <url>/posts/articles/6d84ddb0.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/k8s-cert.png" alt="k8s-cert"></p><hr><p>在 K8s 集群中，除了可以通过 Cluster IP 访问 Service 外，还可通过 DNS 进行访问，在查看系统名称空间的 deployment 时，你会发现有个叫 <code>coredns</code> 的组件，如下图所示：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221219101713029.png" alt="image-20221219101713029"></p><p><code>coredns</code> 是一个 DNS 服务器，每次创建 Service 时，coredns 都会添加该 Service 的 DNS 记录。</p><p>接下来创建一个临时 Pod 来验证通过 DNS 来访问 Service：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建Pod</span></span><br><span class="line">kubectl run busybox --<span class="built_in">rm</span> -it --image=busybox /bin/sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证（由于namespace都是default，所以可以忽略不写）</span></span><br><span class="line">wget &lt;ServiceName&gt;.&lt;namaspace&gt;</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221219105634832.png" alt="image-20221219105634832"></p><p>如果 namespace 不同，就需要跟上 namespace，具体案例如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先创建个namespace</span></span><br><span class="line">kubectl create namespace dns-test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再启动一个测试deployment/Service资源</span></span><br><span class="line">kubectl apply -f nginx1.yml</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221219112206001.png" alt="image-20221219112206001"></p><p><strong>验证：</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221219112721041.png" alt="image-20221219112721041"></p><p><mark>以上就是 DNS 访问 Service 的具体方法。</mark></p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> K8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8s Service 负载均衡底层分析</title>
      <link href="/posts/articles/ed05778b.html"/>
      <url>/posts/articles/ed05778b.html</url>
      
        <content type="html"><![CDATA[<p>当我们创建完 Pod 后，Pod 的 IP 是在容器中配置的，那创建完 Service 后，Service 的 Cluster IP 又是在哪配置的呢？答案是通过 Host 的 <code>iptables</code>（即 K8s 集群节点的 iptables）。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221216162035975.png" alt="image-20221216162035975"></p><p>Cluster IP 是一个虚拟 IP，由 K8s 集群节点的 iptables 规则管理，查看当前节点的 iptables，并过滤与 Service IP 有关的规则</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables-save |grep <span class="string">&#x27;10.99.153.224&#x27;</span></span><br></pre></td></tr></table></figure><p>下图中，我起了 2 个 Pod 副本和一个 Service 资源：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221216164110744.png" alt="image-20221216164110744"></p><p>上图中两条 iptables 规则含义为：</p><ul><li><strong>第一条规则</strong>：当其他源地址访问 Service IP（nginx-srv）时，跳转到 <code>KUBE-SVC-QEOPNOJG5FJIEAZE</code> 规则；</li><li><strong>第二条规则</strong>：当 Service IP（nginx-srv）收到来自集群 Pod IP（Pod）的请求时，则允许。</li></ul><p>那 K8s 集群外部是如何实现访问 Pod 的呢？我们继续看上图中第一条规则跳转后的 <code>KUBE-SVC-QEOPNOJG5FJIEAZE</code> 规则。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221216170246332.png" alt="image-20221216170246332"></p><p>看红框部分：<code>KUBE-SVC-QEOPNOJG5FJIEAZE</code> 分别有两次 50% 的机会转发到下一条规则</p><ul><li><p>第一条规则：其后的 <code>--probability 0.50000000000</code> 表示外部请求时，有 50% 的概率跳转到规则 <code>KUBE-SEP-JASFIS5KUS7Z3IZQ</code></p></li><li><p>第二条规则：其后没有 <code>--probability 0.50000000000</code>，是因为我就起了 2 个 Pod，也就表示外部请求时，也有 50% 的概率跳转到规则 <code>KUBE-SEP-7BD4EFXYOH3EVXAM</code></p></li></ul><p>继续看这两条规则的具体功能实现：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221216171619741.png" alt="image-20221216171619741"></p><p>上面的这两条规则就分别对应 K8s 中的两个 Pod IP，也就是 Host 将集群外部的请求分别转发到后端 2 个 Pod，从 iptables 规则来看，iptables 将 K8s 集群外部的请求转发到后端 Pod，且使用了类似轮询的负载均衡策略。</p><p>之所以外部客户端都可以通过 K8s 集群任意一节点来请求&#x2F;访问 K8s 资源，是因为在整个 K8s 集群中的每个节点都配置了相同的 iptables 规则。</p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> K8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8s Pod 迁移</title>
      <link href="/posts/articles/dae759d1.html"/>
      <url>/posts/articles/dae759d1.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/yys.jpeg" alt="yys"></p><p>K8s 版本：v1.23.6<br>K8s 集群规模（三节点）：Master（1） + work（2） </p><hr><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>k8s集群中的 node 节点要升级内存，以应对服务迁入、pod扩缩容导致的资源短缺，需要对 node 节点进行停机维护，那么此时 node 节点上的 pod 应该如何处理呢？</p><p>测试环境：我 K8s 集群的 default namespace 有两个运行的 Pod。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209144735128.png" alt="image-20230209144735128"></p><h2 id="一、默认迁移"><a href="#一、默认迁移" class="headerlink" title="一、默认迁移"></a>一、默认迁移</h2><p>当某个 node 节点关机后，k8s 集群并没有<code>立刻</code>发生任何自动迁移动作，如果该 node 节点上的副本数为1，则会出现服务中断的情况。<strong>其实事实并非如此，k8s在等待5分钟后，会自动将停机node节点上的pod自动迁移到其他node节点上</strong>。</p><p><strong>1、模拟节点宕机</strong></p><blockquote><p>此处为测试环境测试：对 k8s-work1 进行维护。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止kubelet</span></span><br><span class="line"></span><br><span class="line">systemctl stop kubelet.service</span><br></pre></td></tr></table></figure><p><strong>2、查看集群状态</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此时停机的node点处于NotReady状态</span></span><br><span class="line"></span><br><span class="line">kubectl get node</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209144948114.png" alt="image-20230209144948114"></p><p><strong>3、监控 Pod 状态</strong></p><blockquote><p>大约等待5分钟左右，集群开始有动作</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209145541573.png" alt="image-20230209145541573"></p><blockquote><p>5分钟后，pod终止并进行重建</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209145422644.png" alt="image-20230209145422644"></p><p>5 分钟后经过了 <strong>Terminating</strong>（终止）- - &gt; <strong>Pending</strong>（等待）- -&gt; <strong>ContainerCreating</strong>（创建）- -&gt; <strong>Running</strong>（运行）四个阶段。直到pod 在新节点启动并由 readiness 探针检测正常后并处于<code>1/1 Running</code> 状态才可以正式对外提供服务。</p><p>此时，停止维护的 k8s-work1 节点上的 Pod 一直是 Terminating 状态的（即使该节点上的 Pod 已经迁移至 k8s-work2 了），解决方法就是恢复 k8s-work1 可用即可。</p><p><mark>注意</mark>：在pod重新迁移到其他node节点时，服务是不可用的！</p><p><strong>4、可用性验证</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 10.244.84.191</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209152305390.png" alt="image-20230209152305390"></p><p><strong>迁移完毕！</strong></p><p><mark>在此大家可能有一个疑问：为什么 pod 在 5 分钟后开始迁移呢？</mark><br>此时需要涉及到 k8s 中的 Taint（污点）和 Toleration（容忍），这是从 Kubernetes 1.6 开始提供的高级调度功能。Taint 和 Toleration 相互配合，可以避免 pod 被分配到不合适的节点上。每个节点上都可以应用一个或多个 Taint，这表示对于那些不能容忍 Taint 的 pod，是不会被该节点接受的。如果将 Toleration 应用于 pod 上，则表示这些 pod 可以（但不要求）被调度到具有匹配 Taint 的节点上。</p><p>具体分析如下：</p><ul><li><p>查看停止服务节点的状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe node k8s-work1</span><br></pre></td></tr></table></figure><blockquote><p>kubelet 停止后，node 节点自动添加了 Taints，如下图所示。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209153207561.png" alt="image-20230209153207561"></p></li><li><p>查看 k8s-work1 上任一 Pod 的状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod nginx-6c75966567-r8h5r</span><br></pre></td></tr></table></figure><blockquote><p>此时 pod 的 Tolerations（容忍）默认对于具有相应 Taint 的 node 节点（即正在维护的 k8s-work1 节点）容忍时间为 300s（即 5 分钟），超过此时间 pod 将会被驱逐到其他可用 node 节点上。因此5分钟后 node 节点（即正在维护的 k8s-work1 节点）上所有的 pod 重新被调度，在此期间服务是中断的。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209153502626.png" alt="image-20230209153502626"></p></li></ul><p><mark>既然默认的 pod 迁移无法避免服务中断，那么我们在 node 节点停机前，我们手动迁移是否可以？</mark></p><h2 id="二、手动迁移"><a href="#二、手动迁移" class="headerlink" title="二、手动迁移"></a>二、手动迁移</h2><p>为避免等待默认的 5 分钟，我们还可以使用 cordon、drain、uncordor 三个命令实现节点的主动维护。此时需要用到以下三个命令：</p><ul><li>cordon：标记节点不可调度，后续新的 pod 不会被调度到此节点，但是该节点上的pod可以正常对外服务；</li><li>drain：驱逐节点上的pod至其他可调度节点；</li><li>uncordon：标记节点可调度。</li></ul><p><strong>1、环境准备</strong></p><p>为了方便实验，我先删除集群的 Pod，重新创建 Pod，使 k8s-work1 节点上也运行得有 Pod。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete -f nginx.yml</span><br></pre></td></tr></table></figure><blockquote><p>重新在创建 Pod</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx.yml</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209154702277.png" alt="image-20230209154702277"></p><p><strong>2、标记节点不可调度</strong></p><blockquote><p>同样来标记 k8s-work1。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl cordon k8s-work1</span><br></pre></td></tr></table></figure><p><strong>3、查看节点状态</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get node</span><br></pre></td></tr></table></figure><blockquote><p>此时 k8s-work1 被标记为不可调度状态。但是该节点上的 Pod 还是可正常对外服务的。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209155252769.png" alt="image-20230209155252769"></p><p><strong>4、驱逐 Pod</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl drain k8s-work1 --delete-local-data --ignore-daemonsets --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数解释：</span></span><br><span class="line"><span class="comment"># --delete-local-data  删除本地数据，即使emptyDir也将删除；</span></span><br><span class="line"><span class="comment"># --ignore-daemonsets  忽略DeamonSet，否则DeamonSet被删除后，仍会自动重建；</span></span><br><span class="line"><span class="comment"># --force  不加force参数只会删除该node节点上的ReplicationController, ReplicaSet, DaemonSet,StatefulSet or Job，加上后所有pod都将删除</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209155652903.png" alt="image-20230209155652903"></p><p><strong>5、查看驱逐结果</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -o wide</span><br></pre></td></tr></table></figure><blockquote><p>可见 k8s-work1 上的 Pod 已经被成功驱逐到其他可用的 work 节点（k8s-work2 节点）上了。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209155832846.png" alt="image-20230209155832846"></p><p>此时与默认迁移不同的是，pod 会<code>先重建再终止</code>，此时的<strong>服务中断时间&#x3D;重建时间+服务启动时间+readiness探针检测正常时间</strong>，必须等到<code>1/1 Running</code>服务才会正常。<strong>因此在单副本时迁移时，服务中断是不可避免的</strong>。</p><p><mark>如何能够做到在驱逐过程中仍然保证对外服务不中断呢？</mark> <strong>- - &gt; 平滑迁移</strong></p><h2 id="三、平滑迁移"><a href="#三、平滑迁移" class="headerlink" title="三、平滑迁移"></a>三、平滑迁移</h2><p>要做到平滑迁移就需要用的 pdb（PodDisruptionBudget），即主动驱逐保护。无论是默认迁移和手动迁移，都会导致服务中断，而 pdb 可以实现节点维护期间不低于一定数量的 pod 正常运行，从而保证服务的可用性。</p><p><strong>1、环境准备</strong></p><p>先恢复 k8s-work2 节点为可用（可调度）状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl uncordon k8s-work1</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209161023651.png" alt="image-20230209161023651"></p><p>为了方便实验，同样我先删除集群的 Pod，重新创建 Pod，使 k8s-work1 节点上也运行得有 Pod。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete -f nginx.yml</span><br></pre></td></tr></table></figure><blockquote><p>重新在创建 Pod</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx.yml</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209161155498.png" alt="image-20230209161155498"></p><p><strong>2、标记节点不可调度</strong></p><blockquote><p>同样来标记 k8s-work1。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl cordon k8s-work1</span><br></pre></td></tr></table></figure><p><strong>3、查看节点状态</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get node</span><br></pre></td></tr></table></figure><blockquote><p>此时 k8s-work1 被标记为不可调度状态。但是该节点上的 Pod 还是可正常对外服务的。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209155252769.png" alt="image-20230209155252769"></p><p><strong>4、新建 pdb</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim pdb-nginx.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可定义selector、最小可用（minAvailable）等，根据需求调整即可</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: policy/v1</span><br><span class="line">kind: PodDisruptionBudget</span><br><span class="line">metadata:</span><br><span class="line">  name: pdb-nginx</span><br><span class="line">spec:</span><br><span class="line">  minAvailable: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      web: web-server</span><br></pre></td></tr></table></figure><p><strong>5、创建资源并查看状态</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f pdb-nginx.yaml</span><br><span class="line">kubectl get poddisruptionbudget</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209162125197.png" alt="image-20230209162125197"></p><p><strong>6、驱逐 Pod</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl drain k8s-work1 --delete-local-data --ignore-daemonsets --force</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209162442555.png" alt="image-20230209162442555"></p><p><strong>7、查看驱逐结果</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -o wide</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209162526240.png" alt="image-20230209162526240"></p><p><strong>8、维护完毕，将 node 调整为可调度</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl uncordon k8s-work1</span><br></pre></td></tr></table></figure><p><mark>注意</mark>：使用 pdb 方式时，在 Pod 只有一个副本的情况下 pdb 方式是不会发生驱逐的。解决方法就是临时调整 Pod 副本数，实现驱逐后再调整回来，并将node节点调整为可调度，维护完毕。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过简单了解了 Taint（污点）和 Toleration（容忍）作用，我们既可以通过设置 tolerationSeconds 来缩短等待时间，也可以自行定义匹配规则实现符合实际情况的调度规则。另外还要注意<code>先重建再终止</code>和<code>先终止再重建</code>，在此过程中服务启动时间和探针检测时间决定你的服务中断时间。</p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> K8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deployment 的基础应用案例</title>
      <link href="/posts/articles/3f333f2d.html"/>
      <url>/posts/articles/3f333f2d.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/k8s-cert.png" alt="k8s-cert"></p><p>官方文档：<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/">https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/</a></p><hr><h2 id="一、编写-YAML-配置文件"><a href="#一、编写-YAML-配置文件" class="headerlink" title="一、编写 YAML 配置文件"></a>一、编写 YAML 配置文件</h2><p>我们要清楚，在 K8s 中有两种创建资源的方式：</p><p>（1）命令行方式：如 <code>kubectl create ...</code></p><p>（2）配置文件方式：如 <code>kubectl apply -f nginx.yml</code></p><p><strong>命令行方式：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建Deployment资源</span></span><br><span class="line">kubectl create deployment nginx --image=nginx:1.20.0 --replicas=2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Service将Pod暴露出去</span></span><br><span class="line">kubectl expose deployment nginx --port=8090 --target-port=80 --<span class="built_in">type</span>=NodePort</span><br></pre></td></tr></table></figure><p><strong>配置文件方式：</strong></p><blockquote><p>配置文件采用的是 YAML 格式。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim nginx.yml</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>        <span class="comment"># 指定deployment的api版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>           <span class="comment"># 指定创建资源的角色/类型 </span></span><br><span class="line"><span class="attr">metadata:</span>                  <span class="comment"># 指定Deployment的元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span>              <span class="comment"># 创建名为nginx的Deployment</span></span><br><span class="line">  <span class="attr">labels:</span>                  <span class="comment"># 指定Deployment的标签（可自定义多个），这里的标签不需要与任何地方的标签匹配，根据实际场景随意自定义即可</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">demo</span></span><br><span class="line"><span class="attr">spec:</span>                      <span class="comment"># Deployment的资源规格</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span>              <span class="comment"># Deployment将创建2个Pod副本（默认为 1）</span></span><br><span class="line">  <span class="attr">selector:</span>                <span class="comment"># 匹配标签选择器，定义Deployment如何查找要管理的Pod，因此这里必须与Pod的template模板中定义的标签保持一致</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">demo</span>            <span class="comment"># 仅需匹配（Pod 的 template）任一标签即可</span></span><br><span class="line">  <span class="attr">template:</span>                <span class="comment"># 指定Pod模板</span></span><br><span class="line">    <span class="attr">metadata:</span>              <span class="comment"># 指定Pod的元数据</span></span><br><span class="line">      <span class="attr">labels:</span>              <span class="comment"># 指定Pod的标签（可自定义多个）</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">demo</span></span><br><span class="line">        <span class="attr">env:</span> <span class="string">test</span>          <span class="comment"># 可指定多个标签</span></span><br><span class="line">    <span class="attr">spec:</span>                  <span class="comment"># Pod的资源规格</span></span><br><span class="line">      <span class="attr">containers:</span>          <span class="comment"># 指定Pod运行的容器信息</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span>        <span class="comment"># 指定Pod中运行的容器名</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.20.0</span>     <span class="comment"># 指定Pod中运行的容器镜像与版本（不指定镜像版本号则默认为latest）</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span>     <span class="comment"># 指定容器的端口（即Nginx默认端口）</span></span><br></pre></td></tr></table></figure><p><strong>说明</strong>：对应资源的apiVersion须在kubectl api-versions中，如下图所示。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221213144141447.png" alt="image-20221213144141447"></p><p>不同的资源类型 apiVersion 可能不同，那怎么确定某个资源的api，上图这么多，该选择哪一个呢？我们可以通过下面的命令来辅助查看：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl api-resources |grep replicaset</span><br><span class="line">kubectl api-resources |grep deployment</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下图中的方框部分就是对应的apiVersion</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221215182527559.png" alt="image-20221215182527559"></p><blockquote><p>注意：新版本 K8s 创建 deployment 资源时，如果使用 yaml 配置文件方式创建，必须有 selector，否则报错。老版本可以不用写，如下图：<br><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209101116675.png" alt="image-20230209101116675"><br>可见没有 selector 字段。</p></blockquote><h2 id="二、运行服务"><a href="#二、运行服务" class="headerlink" title="二、运行服务"></a>二、运行服务</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx.yml</span><br></pre></td></tr></table></figure><p>查看 Deployment 上线状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kubectl get deployment</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字段说明</span></span><br><span class="line"><span class="comment"># NAME：列出namespace中Deployment的名称（不指定namespace则默认为Default）</span></span><br><span class="line"><span class="comment"># READY：显示应用程序的可用的副本数。显示的模式是“就绪个数/期望个数”</span></span><br><span class="line"><span class="comment"># UP-TO-DATE：为了达到期望状态已经更新的副本数</span></span><br><span class="line"><span class="comment"># AVAILABLE：显示应用可供用户使用的副本数</span></span><br><span class="line"><span class="comment"># AGE：显示应用程序运行的总时间</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221215154541133.png" alt="image-20221215154541133"></p><p>查看 Deployment 创建的 ReplicaSet</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kubectl get rs</span><br><span class="line">kubectl get replicaset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字段说明</span></span><br><span class="line"><span class="comment"># NAME：列出namespace中ReplicaSet的名称（不指定namespace则默认为Default）</span></span><br><span class="line"><span class="comment"># DESIRED：表示期望状态，显示应用的期望副本个数，即在创建Deployment时所定义的值</span></span><br><span class="line"><span class="comment"># CURRENT：显示当前运行状态中的副本个数</span></span><br><span class="line"><span class="comment"># READY：显示应用中有多少副本可以为用户提供服务</span></span><br><span class="line"><span class="comment"># AGE：显示应用已经运行的总时间</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221215155221009.png" alt="image-20221215155221009"></p><p>注意：ReplicaSet 的名称始终被格式化为 [Deployment名称]-[哈希]。其中的哈希字符串与 ReplicaSet 上的 pod-template-hash 标签一致。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看ReplicaSet的标签</span></span><br><span class="line">kubectl get replicaset --show-labels</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221215160348797.png" alt="image-20221215160348797"></p><p>我们都知道 Pod 副本通过 ReplicaSet 管理，而 ReplicaSet 又是创建于 Deployment，那为什么不直接通过 Deployment 来直接管理，而是 ReplicaSet呢？</p><p>原因是每个控制器的标签或者选择算符不能与其他控制器（包括其他 Deployment 和 StatefulSet）重叠，那 K8s 是如何保证各控制器之间标签的唯一性呢？就是通过 ReplicaSet，因为 Pod 的 <code>PodTemplate</code>标签就是通过 ReplicaSet 进行哈希处理，如下图，可看到 Pod 的 PodTemplate 标签值，此标签可确保了 Deployment 的子 ReplicaSets 不发生重叠现象。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221215164012597.png" alt="image-20221215164012597"></p><p>多个同类型的控制器标签可以相同，如下图：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209121221261.png" alt="image-20230209121221261"></p><p>但多个不同类型的控制器就不可以相同（待验证）。</p><h2 id="三、更新-Deployment"><a href="#三、更新-Deployment" class="headerlink" title="三、更新 Deployment"></a>三、更新 Deployment</h2><h3 id="3-1-动态伸缩容"><a href="#3-1-动态伸缩容" class="headerlink" title="3.1 动态伸缩容"></a>3.1 动态伸缩容</h3><p>所谓的伸缩容就是在线增加或减少 Pod 的副本数（只须修改 replicas 的值即可，大于当前值为伸，小于当前值为缩）。</p><p>1、修改配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">  labels:</span><br><span class="line">    app: demo</span><br><span class="line">spec:</span><br><span class="line">  replicas: 5</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: demo</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: demo</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.20.0</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure><p>2、执行 <code>kubectl apply</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx.yml</span><br></pre></td></tr></table></figure><p>3、查看 Pod 运行状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -o wide</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221213163619736.png" alt="image-20221213163619736"></p><p>出于安全考虑，默认情况下 K8s 不会将 Pod 调度到 master 节点，如果希望将 <code>k8s-master</code> 节点也作为 work 节点，可执行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint node k8s-master node-role.kubernetes.io/master-</span><br></pre></td></tr></table></figure><blockquote><p>再新增一个副本，此时可看到新增的这个 Pod 已经被调度到 Master 节点上了</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221213164259241.png" alt="image-20221213164259241"></p><p>如果要恢复为原来的 Master Only，执行以下语句即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint node k8s-master node-role.kubernetes.io/master=<span class="string">&quot;&quot;</span>:NoSchedule</span><br></pre></td></tr></table></figure><h3 id="3-2-触发上线"><a href="#3-2-触发上线" class="headerlink" title="3.2 触发上线"></a>3.2 触发上线</h3><p>需要注意的是，动态伸缩容不会触发上线动作，仅当 Deployment Pod 模板（即 <code>.spec.template</code>）发生改变时，例如模板的标签或容器镜像被更新，才会触发 Deployment 上线，以下为一个更新镜像版本的触发上线案例。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">set</span> image deployment.v1.apps/nginx nginx=nginx:1.20.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或使用下面的命令：</span></span><br><span class="line">kubectl <span class="built_in">set</span> image deployment/nginx nginx=nginx:1.20.2</span><br><span class="line"><span class="comment"># 或使用下面的命令：直接编辑修改镜像版本即可</span></span><br><span class="line">kubectl edit deployment/nginx</span><br></pre></td></tr></table></figure><p>查看上线状态：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221215170337761.png" alt="image-20221215170337761"></p><p>看看 replicaset 状态：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221215170534723.png" alt="image-20221215170534723"></p><p>可看到  Deployment 通过创建新的 ReplicaSet 并将其扩容到 2 个副本并将旧 ReplicaSet 缩容到 0 个副本完成了 Pod 的更新操作。</p><p>Deployment 可确保在更新时仅关闭一定数量的 Pod。默认情况下，它确保至少所需 Pod 的 75% 处于运行状态（最大不可用比例为 25%）。 默认情况下，它可确保启动的 Pod 个数比期望个数最多多出 125%（最大峰值 25%）。</p><p>仔细查看下图的 Pod 变换情况 ，其流程是先创建一个新的 Pod，然后再删除旧的 Pod。但需要注意的是，更新时它不会立即杀死旧的  Pod，直到有足够数量的新 Pod 已经出现才会杀死旧的 Pod，因为它需要确保至少 2 个 Pod 可用， 同时最多总共 3 个 Pod 可用。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221215170122738.png" alt="image-20221215170122738"></p><p>也可以查看 Deployment 的详情来看到整体更新流程</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe deployments</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221215171801610.png" alt="image-20221215171801610"></p><h2 id="四、故障模拟"><a href="#四、故障模拟" class="headerlink" title="四、故障模拟"></a>四、故障模拟</h2><p>故障前 Pod 运行的节点（work1 节点运行1个、work2 节点运行2个节点）</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221213170334741.png" alt="image-20221213170334741"></p><p>模拟 k8s-work2 故障（关闭节点）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init 0    <span class="comment"># 直接关机</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221213165326214.png" alt="image-20221213165326214"></p><p>等待 5 分钟后会自动在其他可用 work 节点进行创建并运行，之所以要等待5分钟，这是因为 k8s 的 Taint（污点）与 Toleration（容忍）机制所造成。Taint和Toleration相互配合，可以避免pod被分配到不合适的节点上。每个节点上都可以应用一个或多个Taint，这表示对于那些不能容忍 Taint 的 pod，是不会被该节点接受的。如果将 Toleration 应用于 pod 上，则表示这些 pod 可以（但不要求）被调度到具有匹配 Taint 的节点上。</p><blockquote><p>此时可看到 work2 上原来的两个节点已经 Terminating（终止），并转移到了 work1 上。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221213171510077.png" alt="image-20221213171510077"></p><p>因此，<strong>此服务中断时间&#x3D;停机等待5分钟时间+重建时间+服务启动时间+readiness探针检测正常时间</strong></p><p>&#x3D;&#x3D;疑问&#x3D;&#x3D;？那当 K8s-work2 节点恢复后，其原来的 Pod 还会被重新调度回来吗？</p><p>&#x3D;&#x3D;答案是&#x3D;&#x3D;：不会</p><p>此时我恢复 k8s-work2 节点</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221213172602657.png" alt="image-20221213172602657"></p><p>再看看 Pod 的分布情况</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221213172532546.png" alt="image-20221213172532546"></p><h2 id="五、指定节点运行-Pod"><a href="#五、指定节点运行-Pod" class="headerlink" title="五、指定节点运行 Pod"></a>五、指定节点运行 Pod</h2><p>默认情况下，Scheduler 会将 Pod 调度到所有可用的 Work 节点，不过在某些情况下我们需要将 Pod 部署到指定的 Work 节点，比如将有大量磁盘 I&#x2F;O 的 Pod 部署到有 SSD 的 work 节点上来保证其 I&#x2F;O。</p><p>因此，在 K8s 中可通过 label 来实现这个功能，label 是一对 key-value，各种资源都可以设置 label。具体操作如下。</p><p>1、先标记 work 节点</p><blockquote><p>比如：我标记 work2 节点为配置有 SSD 的节点</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node k8s-work2 disktype=ssd</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221213174401273.png" alt="image-20221213174401273"></p><p>如何查看节点已设置的标签？</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get node --show-labels</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221213174625940.png" alt="image-20221213174625940"></p><p>2、修改配置文件</p><blockquote><p>此时就不需要标签选择器了，然后新增节点选择器并指定节点标签即可。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">  labels:</span><br><span class="line">    app: demo</span><br><span class="line">spec:</span><br><span class="line">  replicas: 4</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: demo</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.20.0</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">      nodeSelector:</span><br><span class="line">        disktype: ssd</span><br></pre></td></tr></table></figure><p>3、执行 <code>kubectl apply</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx.yml</span><br></pre></td></tr></table></figure><p>4、查看 这4个副本都只在 work2 节点运行</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221213180223675.png" alt="image-20221213180223675"></p><p>&#x3D;&#x3D;如何删除标签？&#x3D;&#x3D;</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node k8s-work2 disktype-</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221213180731696.png" alt="image-20221213180731696"></p><p>此时 k8s-work2 节点上的 Pod 并不会因为其标签的删除而删除，依然是正常运行的，除非删除 nginx.yml 配置文件中的 nodeSelect 字段，并再次执行 <code>kubectl apply</code> ，master 才会自动调度到其他可用节点（当然也可以包括 work2），如下图所示：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221213181237256.png" alt="image-20221213181237256"></p><h2 id="六、删除-deployment"><a href="#六、删除-deployment" class="headerlink" title="六、删除 deployment"></a>六、删除 deployment</h2><p>会创建当然也要会删除，K8s 中删除资源的方法有以下两种。</p><p>1、直接删除</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete deployment nginx</span><br></pre></td></tr></table></figure><p>2、或通过配置文件删除</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete -f nginx.yml</span><br></pre></td></tr></table></figure><hr><p>附件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1  <span class="comment"># 指定api版本，此值必须在kubectl api-versions中  </span></span><br><span class="line">kind: Deployment  <span class="comment"># 指定创建资源的角色/类型   </span></span><br><span class="line">metadata:  <span class="comment"># 资源的元数据/属性 </span></span><br><span class="line">  name: demo  <span class="comment"># 资源的名字，在同一个namespace中必须唯一</span></span><br><span class="line">  namespace: default <span class="comment"># 部署在哪个namespace中，不指定则默认部署在default中</span></span><br><span class="line">  labels:  <span class="comment"># 设定资源的标签</span></span><br><span class="line">    app: demo</span><br><span class="line">    version: stable</span><br><span class="line">spec: <span class="comment"># 资源规范字段</span></span><br><span class="line">  replicas: 1 <span class="comment"># 声明副本数目</span></span><br><span class="line">  revisionHistoryLimit: 3 <span class="comment"># 保留历史版本</span></span><br><span class="line">  selector: <span class="comment"># 选择器</span></span><br><span class="line">    matchLabels: <span class="comment"># 匹配标签</span></span><br><span class="line">      app: demo</span><br><span class="line">      version: stable</span><br><span class="line">  strategy: <span class="comment"># 策略</span></span><br><span class="line">    rollingUpdate: <span class="comment"># 滚动更新</span></span><br><span class="line">      maxSurge: 30% <span class="comment"># 最大额外可以存在的副本数，可以为百分比，也可以为整数</span></span><br><span class="line">      maxUnavailable: 30% <span class="comment"># 示在更新过程中能够进入不可用状态的 Pod 的最大值，可以为百分比，也可以为整数</span></span><br><span class="line">    <span class="built_in">type</span>: RollingUpdate <span class="comment"># 滚动更新策略</span></span><br><span class="line">  template: <span class="comment"># 模版</span></span><br><span class="line">    metadata: <span class="comment"># 资源的元数据/属性 </span></span><br><span class="line">      annotations: <span class="comment"># 自定义注解列表</span></span><br><span class="line">        sidecar.istio.io/inject: <span class="string">&quot;false&quot;</span> <span class="comment"># 自定义注解名字</span></span><br><span class="line">      labels: <span class="comment"># 设定资源的标签</span></span><br><span class="line">        app: demo</span><br><span class="line">        version: stable</span><br><span class="line">    spec: <span class="comment"># 资源规范字段</span></span><br><span class="line">      containers:</span><br><span class="line">      - name: demo <span class="comment"># 容器的名字   </span></span><br><span class="line">        image: demo:v1 <span class="comment"># 容器使用的镜像地址   </span></span><br><span class="line">        imagePullPolicy: IfNotPresent <span class="comment"># 每次Pod启动拉取镜像策略，三个选择 Always、Never、IfNotPresent</span></span><br><span class="line">                                      <span class="comment"># Always，每次都检查；Never，每次都不检查（不管本地是否有）；IfNotPresent，如果本地有就不检查，如果没有就拉取 </span></span><br><span class="line">        resources: <span class="comment"># 资源管理</span></span><br><span class="line">          limits: <span class="comment"># 最大使用</span></span><br><span class="line">            cpu: 300m <span class="comment"># CPU，1核心 = 1000m</span></span><br><span class="line">            memory: 500Mi <span class="comment"># 内存，1G = 1024Mi</span></span><br><span class="line">          requests:  <span class="comment"># 容器运行时，最低资源需求，也就是说最少需要多少资源容器才能正常运行</span></span><br><span class="line">            cpu: 100m</span><br><span class="line">            memory: 100Mi</span><br><span class="line">        livenessProbe: <span class="comment"># pod 内部健康检查的设置</span></span><br><span class="line">          httpGet: <span class="comment"># 通过httpget检查健康，返回200-399之间，则认为容器正常</span></span><br><span class="line">            path: /healthCheck <span class="comment"># URI地址</span></span><br><span class="line">            port: 8080 <span class="comment"># 端口</span></span><br><span class="line">            scheme: HTTP <span class="comment"># 协议</span></span><br><span class="line">            <span class="comment"># host: 127.0.0.1 # 主机地址</span></span><br><span class="line">          initialDelaySeconds: 30 <span class="comment"># 表明第一次检测在容器启动后多长时间后开始</span></span><br><span class="line">          timeoutSeconds: 5 <span class="comment"># 检测的超时时间</span></span><br><span class="line">          periodSeconds: 30 <span class="comment"># 检查间隔时间</span></span><br><span class="line">          successThreshold: 1 <span class="comment"># 成功门槛</span></span><br><span class="line">          failureThreshold: 5 <span class="comment"># 失败门槛，连接失败5次，pod杀掉，重启一个新的pod</span></span><br><span class="line">        readinessProbe: <span class="comment"># Pod 准备服务健康检查设置</span></span><br><span class="line">          httpGet:</span><br><span class="line">            path: /healthCheck</span><br><span class="line">            port: 8080</span><br><span class="line">            scheme: HTTP</span><br><span class="line">          initialDelaySeconds: 30</span><br><span class="line">          timeoutSeconds: 5</span><br><span class="line">          periodSeconds: 10</span><br><span class="line">          successThreshold: 1</span><br><span class="line">          failureThreshold: 5</span><br><span class="line">        <span class="comment">#也可以用这种方法   </span></span><br><span class="line">        <span class="comment">#exec: 执行命令的方法进行监测，如果其退出码不为0，则认为容器正常   </span></span><br><span class="line">        <span class="comment">#  command:   </span></span><br><span class="line">        <span class="comment">#    - cat   </span></span><br><span class="line">        <span class="comment">#    - /tmp/health   </span></span><br><span class="line">        <span class="comment">#也可以用这种方法   </span></span><br><span class="line">        <span class="comment">#tcpSocket: # 通过tcpSocket检查健康  </span></span><br><span class="line">        <span class="comment">#  port: number </span></span><br><span class="line">        ports:</span><br><span class="line">          - name: http <span class="comment"># 名称</span></span><br><span class="line">            containerPort: 8080 <span class="comment"># 容器开发对外的端口 </span></span><br><span class="line">            protocol: TCP <span class="comment"># 协议</span></span><br><span class="line">      imagePullSecrets: <span class="comment"># 镜像仓库拉取密钥</span></span><br><span class="line">        - name: harbor-certification</span><br><span class="line">      affinity: <span class="comment"># 亲和性调试</span></span><br><span class="line">        nodeAffinity: <span class="comment"># 节点亲和力</span></span><br><span class="line">          requiredDuringSchedulingIgnoredDuringExecution: <span class="comment"># pod 必须部署到满足条件的节点上</span></span><br><span class="line">            nodeSelectorTerms: <span class="comment"># 节点满足任何一个条件就可以</span></span><br><span class="line">            - matchExpressions: <span class="comment"># 有多个选项，则只有同时满足这些逻辑选项的节点才能运行 pod</span></span><br><span class="line">              - key: beta.kubernetes.io/arch</span><br><span class="line">                operator: In</span><br><span class="line">                values:</span><br><span class="line">                - amd64</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> K8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云原生时代下 K8s CGroup/CRI 的优劣势</title>
      <link href="/posts/articles/576697d0.html"/>
      <url>/posts/articles/576697d0.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/k8s-1.jpeg" alt="k8s-1"></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 v1.24 版本之前的 k8s 直接集成了 <code>Docker Engine</code> 组件，但从 v1.24 版本起，<code>Kubernetes</code> 项目正式移除了 <code>Dockershim</code>，也就是说 K8s 不再唯一支持以 Docker 作为 K8s 容器运行时。尽管移除了 Dockershim，但这并不代表 Docker 不可用，我们依然可通过<code>容器运行时接口（CRI）</code>来将 Docker 作为 K8s 的容器运行时。</p><p><mark>容器运行时部署于 K8s 集群的 work 节点上，以使得 Pod 可以正常运行。</mark></p><p><strong>常见容器运行时：</strong></p><ul><li>Containerd</li><li>CRI-O</li><li>Docker Engine</li><li>Mirantis Container Runtime</li></ul><h2 id="一、CGroup"><a href="#一、CGroup" class="headerlink" title="一、CGroup"></a>一、CGroup</h2><h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><p><code>CGroup</code> 相信大家并不陌生，只要接触过 Docker 容器技术的应该都用过。CGroup 是 Linux 的一个底层技术，用于限制分配给系统进程的资源。</p><p>在我前面的 K8s 集群部署文档中，我们知道 <code>kubelet</code> 和底层容器运行时需要对控制组实现 Pod 和容器资源管理和限制（如 CPU、内存等资源设置请求和限制）。<font color=IndianRed>因此，想要对接 K8s 控制组，关键点就在于 kubelet 和容器运行时需要使用同一个 <code>cgroup</code> 驱动。</font></p><p>CGroup 驱动有一下两种：</p><ul><li>cgroupfs</li><li>systemd</li></ul><h3 id="1-2-cgroupfs-驱动"><a href="#1-2-cgroupfs-驱动" class="headerlink" title="1.2 cgroupfs 驱动"></a>1.2 cgroupfs 驱动</h3><h4 id="1-2-1-基本概念"><a href="#1-2-1-基本概念" class="headerlink" title="1.2.1 基本概念"></a>1.2.1 基本概念</h4><p><code>cgroupfs 驱动</code> 是 kubelet 中默认的 cgroup 驱动，当使用 <code>cgroupfs</code> 驱动时， kubelet 和容器运行时将直接对接 cgroup 文件系统来配置 cgroup。</p><p>当你的系统是以 systemd 作为初始化时，不推荐使用 <code>cgroupfs</code> 驱动，因为 systemd 期望系统上只有一个 cgroup 管理器。 此外，如果你的系统使用的 <code>cgroup v2</code> 版本，则应用 <code>systemd</code> 驱动取代 <code>cgroupfs</code>。</p><h4 id="1-2-2-什么是-cgroup-v2"><a href="#1-2-2-什么是-cgroup-v2" class="headerlink" title="1.2.2 什么是 cgroup v2"></a>1.2.2 什么是 cgroup v2</h4><p>Linux 中有两个 cgroup 版本：cgroup v1 和 cgroup v2。cgroup v2 是新一代的 <code>cgroup</code> API，cgroup v2 提供了一个具有增强资源管理能力的统一控制系统。一些 Kubernetes 特性专门使用 cgroup v2 来增强资源管理和隔离，<font color=IndianRed>因此，推荐使用 systemd 来作为 cgroup 驱动，从而可提升更好的资源管理效果。</font></p><p><strong>如何查看 Linux 节点上的 cgroup 版本？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stat -fc %T /sys/fs/cgroup/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对于 cgroup v2，输出为 cgroup2fs</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对于 cgroup v1，输出为 tmpfs</span></span><br></pre></td></tr></table></figure><blockquote><p>下图的 cgroup 版本为 v1</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221026113557429.png" alt="image-20221026113557429"></p><h4 id="1-2-3-cgroup-v2-使用要求"><a href="#1-2-3-cgroup-v2-使用要求" class="headerlink" title="1.2.3 cgroup v2 使用要求"></a>1.2.3 cgroup v2 使用要求</h4><ul><li>操作系统发行版启用 cgroup v2</li><li>Linux 内核为 5.8 或更高版本</li><li>容器运行时支持 cgroup v2</li><li>kubelet 和容器运行时被配置为使用 systemd cgroup 驱动</li></ul><h3 id="1-3-systemd-cgroup-驱动"><a href="#1-3-systemd-cgroup-驱动" class="headerlink" title="1.3 systemd cgroup 驱动"></a>1.3 systemd cgroup 驱动</h3><h4 id="1-3-1-基本概念"><a href="#1-3-1-基本概念" class="headerlink" title="1.3.1 基本概念"></a>1.3.1 基本概念</h4><p>当某个 Linux 系统发行版使用 systemd 作为其初始化系统时，初始化进程会生成并使用一个 root 控制组（<code>cgroup</code>），并充当 cgroup 管理器。</p><p>systemd 与 cgroup 集成紧密，并将为每个 systemd 单元分配一个 cgroup。 因此，如果你 <code>systemd</code> 用作初始化系统，同时使用 <code>cgroupfs</code> 驱动，则系统中会存在两个不同的 cgroup 管理器。</p><p><font color=IndianRed>同时存在两个 cgroup 管理器将造成系统中针对可用的资源和使用中的资源出现两个视图。</font>某些情况下， 将 kubelet 和容器运行时配置为使用 <code>cgroupfs</code>、但为剩余的进程使用 <code>systemd</code> 的那些节点将在资源压力增大时变得不稳定。</p><p><font color=IndianRed>当 systemd 是选定的初始化系统时，缓解这个不稳定问题的方法是针对 kubelet 和容器运行时将 <code>systemd</code> 用作 cgroup 驱动。</font></p><h4 id="1-3-2-kubelet-设置-cgroup-驱动"><a href="#1-3-2-kubelet-设置-cgroup-驱动" class="headerlink" title="1.3.2 kubelet 设置 cgroup 驱动"></a>1.3.2 kubelet 设置 cgroup 驱动</h4><blockquote><p>如：将 <code>systemd</code> 设置为 cgroup 驱动</p><p>编辑 <code>KubeletConfiguration</code> 的 <code>cgroupDriver</code> 选项，并将其设置为 <code>systemd</code></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: kubelet.config.k8s.io/v1beta1</span><br><span class="line">kind: KubeletConfiguration</span><br><span class="line">...</span><br><span class="line">cgroupDriver: systemd</span><br></pre></td></tr></table></figure><blockquote><p>下图为我博客截图：</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221026120542791.png" alt="image-20221026120542791"></p><p><font color=IndianRed>注意：更改已加入集群的节点的 cgroup 驱动是一项敏感的操作。 如果 kubelet 已经使用某 cgroup 驱动的语义创建了 Pod，此时更改运行时以使用别的 cgroup 驱动，当为现有的 Pod 重新创建 PodSandbox 时会产生错误，该错误重启 kubelet 也可能无法解决此类问题，只能重新部署 K8s 集群，因此对于一个正在正常运行的 K8s 集群，我们就最好不要动其 cgroup 驱动了。</font></p><h2 id="二、CRI"><a href="#二、CRI" class="headerlink" title="二、CRI"></a>二、CRI</h2><blockquote><p>这里我以 Kubernetes 1.24 举例，因为我部署的就是该版本的 k8s 集群。</p><p>各位小伙伴也可以尝试以二进制方式部署一下 K8s 集群，会有很大收获。</p></blockquote><p>什么是 CRI？其实 CRI 就是我们的容器运行时接口，可以通过 CRI 来实现 K8s 来集成不同的容器组件。</p><p>首先，对于 Kubernetes 1.24 集群，你的容器运行时必须至少支持 <code>v1alpha2</code> 版本的容器运行时接口。因为 Kubernetes 1.24 默认使用 v1 版本的 CRI API。如果容器运行时不支持 v1 版本的 API， 则 kubelet 会回退到使用（已弃用的）<code>v1alpha2</code>  版本的 API。</p><h3 id="2-1-Containerd"><a href="#2-1-Containerd" class="headerlink" title="2.1 Containerd"></a>2.1 Containerd</h3><h4 id="2-1-1-基本概念"><a href="#2-1-1-基本概念" class="headerlink" title="2.1.1 基本概念"></a>2.1.1 基本概念</h4><p>什么是 Containerd ？这里不过多解释，简单的说：Containerd 不需要经过 dockershim，是一个工业级标准的容器运行时，它强调简单性、健壮性和可移植性。在 Linux 上，containerd 的默认 CRI 套接字是 <code>/run/containerd/containerd.sock</code>。</p><h4 id="2-1-2-配置-CGroup-驱动"><a href="#2-1-2-配置-CGroup-驱动" class="headerlink" title="2.1.2 配置 CGroup 驱动"></a>2.1.2 配置 CGroup 驱动</h4><blockquote><p>以 systemd 驱动为例</p></blockquote><p>1、安装 Containerd</p><p>2、生成配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/containerd &amp;&amp; containerd config default &gt; /etc/containerd/config.toml</span><br></pre></td></tr></table></figure><p>3、修改配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/containerd/config.toml</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">SystemdCgroup = true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 SystemdCgroup = <span class="literal">false</span> 改为 SystemdCgroup = <span class="literal">true</span></span></span><br><span class="line">...</span><br><span class="line">sandbox_image = &quot;registry.aliyuncs.com/google_containers/pause:3.7&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 sandbox_image = <span class="string">&quot;k8s.gcr.io/pause:3.6&quot;</span> 改为：sandbox_image = <span class="string">&quot;registry.aliyuncs.com/google_containers/pause:3.7&quot;</span></span></span><br></pre></td></tr></table></figure><p>4、启动 Containerd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable containerd &amp;&amp; systemctl start containerd</span><br></pre></td></tr></table></figure><h3 id="2-2-CRI-O"><a href="#2-2-CRI-O" class="headerlink" title="2.2 CRI-O"></a>2.2 CRI-O</h3><h4 id="2-2-1-基本概念"><a href="#2-2-1-基本概念" class="headerlink" title="2.2.1 基本概念"></a>2.2.1 基本概念</h4><p>对 CRI-O 没有过多的研究，CRI-O 是一个由 redhat 发起并开源且由社区驱动的 container-runtime，专为 K8s 而生。这里就不过多介绍，感兴趣的化可以深入研究。</p><p>CRI-O 默认使用 systemd cgroup 驱动程序，可编辑 <code>/etc/crio/crio.conf</code> 或在 <code>/etc/crio/crio.conf.d/02-cgroup-manager.conf</code> 中放置一个插入式配置，具体操作如下。</p><h4 id="2-2-2-配置-CGroup-驱动"><a href="#2-2-2-配置-CGroup-驱动" class="headerlink" title="2.2.2 配置 CGroup 驱动"></a>2.2.2 配置 CGroup 驱动</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[crio.runtime]</span><br><span class="line">conmon_cgroup = &quot;pod&quot;</span><br><span class="line">cgroup_manager = &quot;cgroupfs&quot;</span><br><span class="line">...</span><br><span class="line">[crio.image]</span><br><span class="line">pause_image=&quot;registry.aliyuncs.com/google_containers/pause:3.7&quot;</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 pause_image=<span class="string">&quot;registry.k8s.io/pause:3.6&quot;</span> 改为 pause_image=<span class="string">&quot;registry.aliyuncs.com/google_containers/pause:3.7&quot;</span></span></span><br></pre></td></tr></table></figure><p><font color=IndianRed>当使用 CRI-O 时，并且 CRI-O 的 cgroup 设置为 <code>cgroupfs</code> 时，必须将 <code>conmon_cgroup</code> 设置为值 <code>pod</code>。</font></p><h3 id="2-3-Docker-Engine"><a href="#2-3-Docker-Engine" class="headerlink" title="2.3 Docker Engine"></a>2.3 Docker Engine</h3><h4 id="2-3-1-基本概念"><a href="#2-3-1-基本概念" class="headerlink" title="2.3.1 基本概念"></a>2.3.1 基本概念</h4><p>Docker 就不用多说，各位想必再熟悉不过了。想要使用 docker 作为 k8s 的编排对象，那需要安装 cri-docker 来作为 dockershim。对于 <code>cri-dockerd</code>，默认情况下，CRI 套接字是 <code>/run/cri-dockerd.sock</code>。</p><p>cri-docker 源码安装地址：<a href="https://github.com/Mirantis/cri-dockerd">https://github.com/Mirantis/cri-dockerd</a></p><h4 id="2-3-2-配置-CGroup-驱动"><a href="#2-3-2-配置-CGroup-驱动" class="headerlink" title="2.3.2 配置 CGroup 驱动"></a>2.3.2 配置 CGroup 驱动</h4><p>修改 CGroup 为 systemd</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221026150427417.png" alt="image-20221026150427417"></p><p>修改沙箱镜像为国内源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">ExecStart=/usr/local/bin/cri-dockerd --container-runtime-endpoint fd:// --network-plugin=cni --pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.7</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">TimeoutSec=0</span><br><span class="line">RestartSec=2</span><br><span class="line">Restart=always</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 ExecStart= 部分添加即可</span></span><br></pre></td></tr></table></figure><p>修改完成后重启 Docker 即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure><h3 id="2-4-Mirantis"><a href="#2-4-Mirantis" class="headerlink" title="2.4 Mirantis"></a>2.4 Mirantis</h3><p><code>Mirantis Container Runtime (MCR)</code> 是一种商用容器运行时，以前称为 Docker 企业版，可以使用 MCR 中包含的开源 <code>cri-dockerd</code> 组件将 Mirantis Container Runtime 与 Kubernetes 一起使用。</p><p>更多 Mirantis 相关知识，可阅读其<a href="https://docs.mirantis.com/mcr/20.10/install.html">官方文档。</a></p><p><mark>看了这么多容器运行时，没有谁好谁坏，适合自己公司业务的就是最好的</mark></p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> K8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文彻底搞懂 Alertmanager 的告警抑制与静默</title>
      <link href="/posts/articles/57fa097e.html"/>
      <url>/posts/articles/57fa097e.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230403153709093.png" alt="image-20230403153709093"></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面提到了，<code>Prometheus 数据指标采集</code> + <code>Grafana 数据 Web 展示</code> + <code>钉钉告警消息通知</code>，但是仅仅是做了一个实验，并没有深究其触发告警问题，那 Prometheus 到底是如何触发告警的？我们接着往下看。</p><h2 id="一、Prometheus-架构"><a href="#一、Prometheus-架构" class="headerlink" title="一、Prometheus 架构"></a>一、Prometheus 架构</h2><p>在搞清楚 Prometheus 是如何触发告警前，首先我们要清楚 Prometheus 的一个整体架构，其他部分我们先不看，我们就来看 Alertmanager 部分，从架构图中可看到它作为一个整体独立存在，Prometheus 以 Push 消息的方式与其通信，Alertmanager 最后再将 Prometheus 推送过来的告警信息经过其模板渲染后路由给指定用户&amp;&amp;接收端（邮件&#x2F;钉钉&#x2F;企业微信等），从而实现告警通知。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230331164522715.png" alt="image-20230331164522715"></p><p>沿用前两篇博客案例来逐步解释。</p><blockquote><p><a href="https://blog.rabcnops.cn/posts/articles/2f967c8.html">Prometheus - SSL 证书过期监控 | Rabcnops</a></p><p><a href="https://blog.rabcnops.cn/posts/articles/462c3ed6.html">Prometheus - SSL 证书过期监控 - 钉钉告警 | Rabcnops</a></p></blockquote><h2 id="二、Prometheus-告警触发"><a href="#二、Prometheus-告警触发" class="headerlink" title="二、Prometheus 告警触发"></a>二、Prometheus 告警触发</h2><h3 id="2-1-Prometheus-规则文件与字段解释"><a href="#2-1-Prometheus-规则文件与字段解释" class="headerlink" title="2.1 Prometheus 规则文件与字段解释"></a>2.1 Prometheus 规则文件与字段解释</h3><p>首先，来看 Prometheus 的告警规则：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /home/data/prometheus/rules/ssl_cert_alerts.yml</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">groups</span>:                        <span class="comment"># 父分组</span></span><br><span class="line">- name: <span class="string">&quot;SSL证书过期提醒&quot;</span>        <span class="comment"># 子分组。该字段下可配置多个子分组（子分组名用name字段定义），也就是说Prometheus以组的形式进行告警配置。本案例中定义了名为“SSL证书过期提醒”的一个子分组。</span></span><br><span class="line">  rules:                       <span class="comment"># 定义子分组的告警规则。</span></span><br><span class="line">  - alert: <span class="string">&quot;证书过期时间&lt;30天&quot;</span>   <span class="comment"># 定义告警名。</span></span><br><span class="line">    <span class="built_in">expr</span>: probe_ssl_earliest_cert_expiry&#123;job=<span class="string">&quot;SSL证书时间&quot;</span>&#125; - time() &lt; 86400 * 30  <span class="comment"># 告警条件（只有满足这个表达式条件时才会触发告警）</span></span><br><span class="line">    <span class="keyword">for</span>: 0s                    <span class="comment"># 持续的时间（满足告警条件持续时间多久后，才会发送告警到Alertmanager）</span></span><br><span class="line">    labels:                    <span class="comment"># 标签（K/V的形式，如定义告警的级别 - - &gt; 提示、告警、严重。）</span></span><br><span class="line">      severity: <span class="string">&quot;提示&quot;</span></span><br><span class="line">    annotations:               <span class="comment"># 注释（summary -- 摘要、description -- 详情）</span></span><br><span class="line">      summary: <span class="string">&quot;SSL 证书即将过期！&quot;</span></span><br><span class="line">      description: <span class="string">&quot;&#123;&#123; <span class="variable">$labels</span>.instance &#125;&#125; SSL 证书将在30天后过期，请注意及时续费！&quot;</span></span><br><span class="line">  - alert: <span class="string">&quot;证书过期时间&lt;7天&quot;</span></span><br><span class="line">    <span class="built_in">expr</span>: probe_ssl_earliest_cert_expiry&#123;job=<span class="string">&quot;SSL证书时间&quot;</span>&#125; - time() &lt; 86400 * 7</span><br><span class="line">    <span class="keyword">for</span>: 0s</span><br><span class="line">    labels:</span><br><span class="line">      severity: <span class="string">&quot;告警&quot;</span></span><br><span class="line">    annotations:</span><br><span class="line">      summary: <span class="string">&quot;SSL 证书即将过期！&quot;</span></span><br><span class="line">      description: <span class="string">&quot;&#123;&#123; <span class="variable">$labels</span>.instance &#125;&#125; SSL 证书将在7天后过期，请注意及时续费！&quot;</span></span><br><span class="line">  - alert: <span class="string">&quot;证书过期时间&lt;1天&quot;</span></span><br><span class="line">    <span class="built_in">expr</span>: probe_ssl_earliest_cert_expiry&#123;job=<span class="string">&quot;SSL证书时间&quot;</span>&#125; - time() &lt; 86400 * 1</span><br><span class="line">    <span class="keyword">for</span>: 0s</span><br><span class="line">    labels:</span><br><span class="line">      severity: <span class="string">&quot;灾难&quot;</span></span><br><span class="line">    annotations:</span><br><span class="line">      summary: <span class="string">&quot;SSL 证书即将过期！&quot;</span></span><br><span class="line">      description: <span class="string">&quot;&#123;&#123; <span class="variable">$labels</span>.instance &#125;&#125; SSL 证书将在1天后过期，请注意及时续费！&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-规则文件检测"><a href="#2-2-规则文件检测" class="headerlink" title="2.2 规则文件检测"></a>2.2 规则文件检测</h3><blockquote><p>检测规则语法是否有误，SUCCESS 代表语法是没问题的。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> prometheus promtool check rules conf/rules/ssl_cert_alerts.yml</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Checking conf/rules/ssl_cert_alerts.yml</span><br><span class="line">  SUCCESS: 3 rules found</span><br></pre></td></tr></table></figure><h3 id="2-3-重启-x2F-热加载-Prometheus"><a href="#2-3-重启-x2F-热加载-Prometheus" class="headerlink" title="2.3 重启&#x2F;热加载 Prometheus"></a>2.3 重启&#x2F;热加载 Prometheus</h3><blockquote><p>重启 Prometheus 使配置文件生效。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart prometheus</span><br></pre></td></tr></table></figure><h2 id="三、Alertmanager-告警通知"><a href="#三、Alertmanager-告警通知" class="headerlink" title="三、Alertmanager 告警通知"></a>三、Alertmanager 告警通知</h2><h3 id="3-1-基础环境"><a href="#3-1-基础环境" class="headerlink" title="3.1 基础环境"></a>3.1 基础环境</h3><p>在 Prometheus 服务端有三个告警状态：</p><ul><li><strong>inactive</strong>：没有异常。</li><li><strong>pending</strong>：已触发阈值，但未满足告警的持续时间（即 rule 中的 for 字段）。</li><li><strong>firing</strong>：已触发阈值且满足告警的持续时间，然后将告警发送至 Alertmanager，Alertmanager 根据相关模板发送至Email&#x2F;钉钉等。</li></ul><p>在我的案例中有三个 SSL 证书的时间 &lt; 7 天了，如下图：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230403100434740.png" alt="image-20230403100434740"></p><h3 id="3-2-接收-Prometheus-告警"><a href="#3-2-接收-Prometheus-告警" class="headerlink" title="3.2 接收 Prometheus 告警"></a>3.2 接收 Prometheus 告警</h3><blockquote><p>钉钉告警配置在前面已经讲过了，这里来验证整个告警过程。</p></blockquote><p><strong>1、Prometheus 规则定义并重启服务生效</strong></p><p><strong>2、此时我们会看到 Prometheus 的三个告警状态的变化</strong></p><blockquote><p>为了不产生告警，我已经关闭了小于 30 天、7 天的告警规则了。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230403101011131.png" alt="image-20230403101011131"></p><blockquote><p>现在开启小于 7 天的告警，看看其状态变化情况。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230403101256286.png" alt="image-20230403101256286"></p><blockquote><p>没有经历 Pending，那是因为我的告警规则的 for 值是 0s，所以你会看到直接跳到 Firing 了。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230403101320253.png" alt="image-20230403101320253"></p><h3 id="3-3-Alertmanager-发送告警消息"><a href="#3-3-Alertmanager-发送告警消息" class="headerlink" title="3.3 Alertmanager 发送告警消息"></a>3.3 Alertmanager 发送告警消息</h3><blockquote><p>当 Firing 的时候，Prometheus 就会将告警推送到 Alertmanager</p></blockquote><p>Alertmanager 接收到来自 Prometheus 的告警时，会根据 Alertmanager 相关配置（如组等待时间、组发送间隔）将消息发送给 Email、钉钉等。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230403101500114.png" alt="image-20230403101500114"></p><h3 id="3-4-Alertmanager-配置文件与字段解释"><a href="#3-4-Alertmanager-配置文件与字段解释" class="headerlink" title="3.4 Alertmanager 配置文件与字段解释"></a>3.4 Alertmanager 配置文件与字段解释</h3><blockquote><p>先看看一份简单的配置文件与字段解释。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">global:</span><br><span class="line">  resolve_timeout: 1m                               <span class="comment"># 恢复等待（如果1m后没收到来自Prometheus的告警，则发送恢复告警通知）</span></span><br><span class="line">  smtp_smarthost: <span class="string">&#x27;smtp.163.com:465&#x27;</span>                <span class="comment"># 邮箱服务器</span></span><br><span class="line">  smtp_from: <span class="string">&#x27;zhurongsen_admin@163.com&#x27;</span>             <span class="comment"># 邮箱地址（发送用户）</span></span><br><span class="line">  smtp_auth_username: <span class="string">&#x27;zhurongsen_admin@163.com&#x27;</span>    <span class="comment"># 邮箱登录地址</span></span><br><span class="line">  smtp_auth_password: <span class="string">&#x27;DYKIFIZYKUOXRPFV&#x27;</span>            <span class="comment"># 邮箱授权码（注意是授权码，不是登录密码）</span></span><br><span class="line">  smtp_require_tls: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">templates:</span><br><span class="line">- <span class="string">&#x27;/etc/alertmanager/template/*.tmpl&#x27;</span>     <span class="comment"># alertmanager模板文件（用于定义告警通知时的模板，如HTML模板、邮件模板等，当然像钉钉有自己的模板则就不会使用该模板，而是使用钉钉自己的模板，也就是说这是缺省模板）</span></span><br><span class="line"></span><br><span class="line">route:                                    <span class="comment"># 根路由</span></span><br><span class="line">  group_by: [<span class="string">&#x27;alertname&#x27;</span>]                 <span class="comment"># 分组（通过alertname标签的值进行分组）</span></span><br><span class="line">  group_wait: 10s                         <span class="comment"># 第一次产生告警，等待10s，组内有告警就一起发出，没有则单独发出</span></span><br><span class="line">  group_interval: 1m                      <span class="comment"># 第二次产生告警，先等待1m，如果1m后还没恢复就进入repeat_interval。定义相同的Group之间发送告警通知的时间间隔</span></span><br><span class="line">  repeat_interval: 5m                     <span class="comment"># 在最终发送消息前再等待5m，5m后还没恢复就发送第二次告警</span></span><br><span class="line">  receiver: <span class="string">&#x27;ops&#x27;</span>                         <span class="comment"># 接收者（全局接收者）不管什么样的告警类型都会接收到告警信息</span></span><br><span class="line">  <span class="comment"># continue: false                       # 如果为false，则不进行后续匹配，为true则继续匹配子路由</span></span><br><span class="line">  routes:                                 <span class="comment"># 子路由</span></span><br><span class="line">  - match:                                <span class="comment"># 常规匹配</span></span><br><span class="line">      severity: critical                  <span class="comment"># 匹配critical值（这里主要是看你在没在你的Prometheus规则中定义）</span></span><br><span class="line">    receiver: <span class="string">&#x27;dev&#x27;</span>                       <span class="comment"># 只有匹配到critical时，才会发送告警消息给dev</span></span><br><span class="line">    <span class="comment"># continue: true                      # 同样是否继续匹配（看你的实际情况）</span></span><br><span class="line">  - match_re:                             <span class="comment"># 正则匹配</span></span><br><span class="line">      severity: ^(warning|critical)$      <span class="comment"># 匹配warning或critical</span></span><br><span class="line">    receiver: <span class="string">&#x27;webhook&#x27;</span>                   <span class="comment"># 只有匹配到warning或critical师，才会发送告警给webhook</span></span><br><span class="line"></span><br><span class="line">receivers:                            <span class="comment"># 接收者的具体信息</span></span><br><span class="line">- name: <span class="string">&#x27;ops&#x27;</span></span><br><span class="line">  email_configs:</span><br><span class="line">  - to: <span class="string">&#x27;2564395767@qq.com&#x27;</span></span><br><span class="line">    send_resolved: <span class="literal">true</span></span><br><span class="line">- name: <span class="string">&#x27;dev&#x27;</span></span><br><span class="line">  email_configs:</span><br><span class="line">  - to: <span class="string">&#x27;2318099451@qq.com&#x27;</span></span><br><span class="line">    send_resolved: <span class="literal">true</span></span><br><span class="line">- name: <span class="string">&#x27;test&#x27;</span></span><br><span class="line">  email_configs:</span><br><span class="line">  - to: <span class="string">&#x27;zhurongsen_admin@126.com&#x27;</span></span><br><span class="line">    send_resolved: <span class="literal">true</span></span><br><span class="line">- name: <span class="string">&#x27;webhook&#x27;</span></span><br><span class="line">  webhook_configs:</span><br><span class="line">  - url: http://192.168.56.142:8060/dingtalk/webhook1/send</span><br><span class="line">    send_resolved: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">inhibit_rules:                                  <span class="comment"># 抑制规则（当匹配到critical时抑制掉warning的告警，防止重复告警）</span></span><br><span class="line">  - source_match:</span><br><span class="line">      severity: <span class="string">&#x27;critical&#x27;</span>                      <span class="comment"># 此时，这个告警会被通知</span></span><br><span class="line">    target_match:</span><br><span class="line">      severity: <span class="string">&#x27;warning&#x27;</span>                       <span class="comment"># 此时，这个告警会被抑制</span></span><br><span class="line">    equal: [<span class="string">&#x27;alertname&#x27;</span>, <span class="string">&#x27;dev&#x27;</span>, <span class="string">&#x27;instance&#x27;</span>]     <span class="comment"># 匹配哪些对象的告警</span></span><br></pre></td></tr></table></figure><h3 id="3-5-重启-Alertmanager-服务"><a href="#3-5-重启-Alertmanager-服务" class="headerlink" title="3.5 重启 Alertmanager 服务"></a>3.5 重启 Alertmanager 服务</h3><blockquote><p>任何修改配置文件的动作都要重启&#x2F;热加载才会生效。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart alertmanager</span><br></pre></td></tr></table></figure><h2 id="四、案例"><a href="#四、案例" class="headerlink" title="四、案例"></a>四、案例</h2><h3 id="4-1-Prometheus-规则"><a href="#4-1-Prometheus-规则" class="headerlink" title="4.1 Prometheus 规则"></a>4.1 Prometheus 规则</h3><blockquote><p>上面提到有3个证书要过期了，但我已经续费了，为了体现效果，我将修改过期时间。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">groups</span>:</span><br><span class="line">- name: <span class="string">&quot;SSL证书过期提醒&quot;</span></span><br><span class="line">  rules:</span><br><span class="line">  - alert: <span class="string">&quot;证书过期时间&lt;200天&quot;</span></span><br><span class="line">    <span class="built_in">expr</span>: probe_ssl_earliest_cert_expiry&#123;job=<span class="string">&quot;SSL证书时间&quot;</span>&#125; - time() &lt; 86400 * 200</span><br><span class="line">    <span class="keyword">for</span>: 0s</span><br><span class="line">    labels:</span><br><span class="line">      severity: <span class="string">&quot;提示&quot;</span></span><br><span class="line">      <span class="built_in">type</span>: ssl</span><br><span class="line">    annotations:</span><br><span class="line">      summary: <span class="string">&quot;SSL 证书即将过期 - 提示&quot;</span></span><br><span class="line">      description: <span class="string">&quot;&#123;&#123; <span class="variable">$labels</span>.instance &#125;&#125; SSL 证书将在200天后过期，请注意及时续费！&quot;</span></span><br><span class="line">  - alert: <span class="string">&quot;证书过期时间&lt;100天&quot;</span></span><br><span class="line">    <span class="built_in">expr</span>: probe_ssl_earliest_cert_expiry&#123;job=<span class="string">&quot;SSL证书时间&quot;</span>&#125; - time() &lt; 86400 * 100</span><br><span class="line">    <span class="keyword">for</span>: 0s</span><br><span class="line">    labels:</span><br><span class="line">      severity: <span class="string">&quot;告警&quot;</span></span><br><span class="line">      <span class="built_in">type</span>: ssl</span><br><span class="line">    annotations:</span><br><span class="line">      summary: <span class="string">&quot;SSL 证书即将过期 - 告警&quot;</span></span><br><span class="line">      description: <span class="string">&quot;&#123;&#123; <span class="variable">$labels</span>.instance &#125;&#125; SSL 证书将在100天后过期，请注意及时续费！&quot;</span></span><br><span class="line">  - alert: <span class="string">&quot;证书过期时间&lt;1天&quot;</span></span><br><span class="line">    <span class="built_in">expr</span>: probe_ssl_earliest_cert_expiry&#123;job=<span class="string">&quot;SSL证书时间&quot;</span>&#125; - time() &lt; 86400 * 1</span><br><span class="line">    <span class="keyword">for</span>: 0s</span><br><span class="line">    labels:</span><br><span class="line">      severity: <span class="string">&quot;灾难&quot;</span></span><br><span class="line">      <span class="built_in">type</span>: ssl</span><br><span class="line">    annotations:</span><br><span class="line">      summary: <span class="string">&quot;SSL 证书即将过期 - 灾难&quot;</span></span><br><span class="line">      description: <span class="string">&quot;&#123;&#123; <span class="variable">$labels</span>.instance &#125;&#125; SSL 证书将在1天后过期，请注意及时续费！&quot;</span></span><br></pre></td></tr></table></figure><h3 id="4-2-Alertmanager-告警与抑制"><a href="#4-2-Alertmanager-告警与抑制" class="headerlink" title="4.2 Alertmanager 告警与抑制"></a>4.2 Alertmanager 告警与抑制</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">global:</span><br><span class="line">  resolve_timeout: 30s</span><br><span class="line">route:</span><br><span class="line">  group_wait: 10s</span><br><span class="line">  group_interval: 5s</span><br><span class="line">  repeat_interval: 1m</span><br><span class="line">  group_by: [<span class="string">&#x27;alertname&#x27;</span>]</span><br><span class="line">  receiver: <span class="string">&#x27;ops&#x27;</span></span><br><span class="line">  routes:</span><br><span class="line">  - match:</span><br><span class="line">      severity: <span class="string">&#x27;提示&#x27;</span></span><br><span class="line">    receiver: <span class="string">&#x27;web.hook.prometheusalert&#x27;</span></span><br><span class="line">  - match:</span><br><span class="line">      severity: <span class="string">&#x27;告警&#x27;</span></span><br><span class="line">    receiver: <span class="string">&#x27;web.hook.prometheusalert&#x27;</span></span><br><span class="line">  - match:</span><br><span class="line">      severity: <span class="string">&#x27;灾难&#x27;</span></span><br><span class="line">    receiver: <span class="string">&#x27;web.hook.prometheusalert&#x27;</span></span><br><span class="line"></span><br><span class="line">receivers:</span><br><span class="line">- name: <span class="string">&#x27;ops&#x27;</span></span><br><span class="line">  webhook_configs:</span><br><span class="line">  - url: <span class="string">&#x27;http://192.168.56.150:8060/dingtalk/webhook1/send&#x27;</span></span><br><span class="line">    send_resolved: <span class="literal">true</span></span><br><span class="line">- name: <span class="string">&#x27;web.hook.prometheusalert&#x27;</span></span><br><span class="line">  webhook_configs:</span><br><span class="line">  - url: <span class="string">&#x27;http://192.168.56.142:8060/dingtalk/webhook1/send&#x27;</span></span><br><span class="line">    send_resolved: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">inhibit_rules:</span><br><span class="line">  - source_match:</span><br><span class="line">      severity: <span class="string">&#x27;告警&#x27;</span></span><br><span class="line">    target_match:</span><br><span class="line">      severity: <span class="string">&#x27;提示&#x27;</span></span><br><span class="line">    equal: [<span class="string">&#x27;ssl&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>告警策略分析</strong>：当子路由匹配到不同的 <code>severity</code> 时就会将消息发往不同的 <code>receiver</code>，当子路由无法匹配到时，消息会默认发往根路由的 <code>receiver</code>，因此，无论是否匹配到子路由规则，消息都会发往根路由的 <code>receiver</code>。</p><p><strong>抑制策略分析</strong>：当匹配到<code>告警</code>标签值时会抑制<code>提示</code>标签值的告警（无论根路由或子路由），但是要注意的是，抑制策略必须来自同个标签类型（即 equal 标签的值必须相同才能起到抑制效果），否则抑制不生效。举个例子：之前我将 <code>equal</code> 设置为<code>alertname</code>是不生效的，原因是在 <code>Prometheus</code> 那端的 <code>alertname</code> 就不一样（除非你设置为一样的），因此解决方法就是将 <code>alertname</code> 设置为相同的值，或自定义额外标签（案例中我就添加的额外标签 - - &gt; type 且值都统一为 ssl），这样的话当匹配到 <code>告警</code> 时就会抑制<code>提示</code>的告警通知并检查他们是否来自于同个 ssl（即ssl标签的值相同抑制才会生效）。</p><blockquote><p>看看最终效果，可见只发送了<code>告警</code>相关的消息，<code>提示</code>相关的消息已经被抑制了。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230403144843933.png" alt="image-20230403144843933"></p><p><mark>除了通过 Alertmanager 配置文件配置实现抑制，那还有没其他方式实现类似抑制效果呢？是有的，就是 Alertmanager 自身的静默机制，接下来顺便看看如何设置静默。</mark></p><h3 id="4-3-Alertmanager-告警与静默"><a href="#4-3-Alertmanager-告警与静默" class="headerlink" title="4.3 Alertmanager 告警与静默"></a>4.3 Alertmanager 告警与静默</h3><h4 id="4-3-1-访问-Web-端"><a href="#4-3-1-访问-Web-端" class="headerlink" title="4.3.1 访问 Web 端"></a>4.3.1 访问 Web 端</h4><blockquote><p><a href="http://192.168.56.142:9093/">http://192.168.56.142:9093/</a></p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230403152031509.png" alt="image-20230403152031509"></p><h4 id="4-3-2-设置静默"><a href="#4-3-2-设置静默" class="headerlink" title="4.3.2 设置静默"></a>4.3.2 设置静默</h4><blockquote><p>两种方式：<code>根据现有的告警设置静默</code>和<code>新建告警静默</code>。</p></blockquote><p><strong>1、根据现有的告警设置静默</strong></p><ul><li><p>直接点击 Silence 静默</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230403152000217.png" alt="image-20230403152000217"></p></li><li><p>开始静默设置</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230403151633448.png" alt="image-20230403151633448"></p></li><li><p>最后再看看钉钉告警</p><blockquote><p>此时就只收到两条告警信息了（有一条）</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230403151547284.png" alt="image-20230403151547284"></p></li></ul><p><strong>2、新建告警静默</strong></p><ul><li><p>点击 <code>New Silence</code></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230403151922758.png" alt="image-20230403151922758"></p></li><li><p>剩下的配置都一样（不再重复演示）</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230403152106300.png" alt="image-20230403152106300"></p></li></ul><h4 id="4-3-3-解除静默"><a href="#4-3-3-解除静默" class="headerlink" title="4.3.3 解除静默"></a>4.3.3 解除静默</h4><p><strong>1、Silence - - &gt; Exprire</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230403152402199.png" alt="image-20230403152402199"></p><p><strong>2、最后点击 <code>Confirm</code></strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230403152432980.png" alt="image-20230403152432980"></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230403152611507.png" alt="image-20230403152611507"></p><p><strong>3、再看看告警通知</strong></p><blockquote><p>又恢复三条告警信息了。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230403152724051.png" alt="image-20230403152724051"></p><p><mark>注意：</mark>告警恢复（resolve）的时候，消息是正常通知的，没有受抑制的影响。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实配置都比较简单，我认为重点在于搞懂 Prometheus 是如何触发的，Alertmanager 又是如何告警的？简单总结一下：</p><ul><li>告警触发于 Prometheus（根据触发告警规则）；</li><li>Prometheus 触发告警经历三阶段（Inactive、Pending 和 Firing）；</li><li>Prometheus 在 Firing 阶段时，将告警 push 到 Alertmanager（符合架构）；</li><li>Alertmanager 根据路由、匹配和抑制进行告警通知，最终实现告警；</li><li>如果需对服务器维护或应用升级时，需进行静默设置（避免消息误报）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 监控系统 </category>
          
          <category> Alertmanager </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Alertmanager </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7 搭建 DHCP 服务</title>
      <link href="/posts/articles/7839211d.html"/>
      <url>/posts/articles/7839211d.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230314151216808.png" alt="image-20230314151216808"></p><hr><h2 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h2><p>采用 <code>VMware Workstation</code> 进行实验：</p><table><thead><tr><th>Host</th><th>Network</th><th>备注</th></tr></thead><tbody><tr><td>192.168.209.20</td><td>仅主机模式</td><td>DHCP 服务端 - IP 地址池划分与分配</td></tr><tr><td>192.168.209.x</td><td>仅主机模式</td><td>Client 客户端 - 测试 - 从 20 获取 IP 地址（实现动态&#x2F;静态获取）</td></tr></tbody></table><p><strong>整体思路：</strong></p><ol><li>先把 DHCP 服务端的网络模式改为 Net 或桥接模式（因为我们要事先安装 DHCP 服务，而仅主机模式下是上不了网的）；</li><li>DHCP 服务端与Client 客户端处于同一网络下；</li><li>启动 DHCP 服务端；</li><li>启动 Client 客户端，看是否获取到 IP（动态&#x2F;静态）；</li><li>验证 Client 客户端是否可连接外网（很显然我们这里是无法连接外网的 - 由于虚拟机环境且是仅主机网络模式下）。</li></ol><blockquote><p>我们使用仅主机模式，只是想向大家没有外部网络因素干扰的情况下展示DHCP服务。</p></blockquote><h2 id="二、DHCP-服务端部署"><a href="#二、DHCP-服务端部署" class="headerlink" title="二、DHCP 服务端部署"></a>二、DHCP 服务端部署</h2><h3 id="2-1-安装-DHCP-服务"><a href="#2-1-安装-DHCP-服务" class="headerlink" title="2.1 安装 DHCP 服务"></a>2.1 安装 DHCP 服务</h3><p><strong>1、安装 DHCP</strong></p><blockquote><p>此时的 DHCP 服务端主机的网络是 Net 模式的。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y dhcp</span><br></pre></td></tr></table></figure><p><strong>2、添加仅主机网络模式</strong></p><ul><li><p>操作：【编辑】- - &gt; 【虚拟网络编辑器】</p><blockquote><p>将本地 DHCP 分配去掉，目的是不受本地的 DHCP 影响</p><p>其子网 PI 为：92.168.209.0</p><p>其子网掩码为：255.255.255.0</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230314134008715.png" alt="image-20230314134008715"></p></li><li><p>点击确定后，宿主机同样也具备网关（实现与虚拟机通信）</p><blockquote><p>要保证宿主机（windows）与你的虚拟机的网关相同，且掩码也相同，否则宿主机无法与你创建的<code>仅主机模式</code>的虚拟机通信。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230314134420397.png" alt="image-20230314134420397"></p></li></ul><p><strong>3、将 DHCP 服务端虚拟主机的网络模式调整为<code>仅主机模式</code></strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230314134224976.png" alt="image-20230314134224976"></p><p><strong>4、将 DHCP 服务端虚拟主机的 IP 设置为静态 IP</strong></p><blockquote><p>这个静态 IP 可指定 <code>VMnet2</code> 网络下的子网 IP 中任意一个（只要没被占用）。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=<span class="built_in">yes</span></span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=<span class="built_in">yes</span></span><br><span class="line">IPV6_AUTOCONF=<span class="built_in">yes</span></span><br><span class="line">IPV6_DEFROUTE=<span class="built_in">yes</span></span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">UUID=c78f73a1-afac-4c14-ac95-8e0c0fa76db5</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=<span class="built_in">yes</span></span><br><span class="line">IPADDR=192.168.209.20</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.209.2</span><br><span class="line">DNS1=114.114.114.114</span><br><span class="line">DNS2=61.139.2.69</span><br></pre></td></tr></table></figure><blockquote><p>重启网络</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network.service</span><br></pre></td></tr></table></figure><h3 id="2-2-修改-DHCP-配置"><a href="#2-2-修改-DHCP-配置" class="headerlink" title="2.2 修改 DHCP 配置"></a>2.2 修改 DHCP 配置</h3><p><strong>1、编辑 <code>/etc/dhcp/dhcpd.conf</code> 文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/dhcp/dhcpd.conf</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230314140115337.png" alt="image-20230314140115337"></p><blockquote><p>提示可知：将配置文件复制到 <code>/etc/dhcp/</code> 下即可。</p></blockquote><p><strong>2、复制配置文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/share/doc/dhcp*/dhcpd.conf.example /etc/dhcp/dhcpd.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接替换即可</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230314140429941.png" alt="image-20230314140429941"></p><p><strong>3、再次编辑 <code>/etc/dhcp/dhcpd.conf</code> 文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/dhcp/dhcpd.conf</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局配置（若局部配置没设置则以全局配置为准）</span></span><br><span class="line">option domain-name <span class="string">&quot;example.org&quot;</span>;</span><br><span class="line">option domain-name-servers ns1.example.org, ns2.example.org;</span><br><span class="line"></span><br><span class="line">default-lease-time 600;</span><br><span class="line">max-lease-time 7200;</span><br><span class="line"></span><br><span class="line">ddns-update-style none;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment"># 局部配置（若局部配置已设置则以局部配置为准）</span></span><br><span class="line">subnet 192.168.209.0 netmask 255.255.255.0 &#123;   <span class="comment"># 定义网络地址和子网掩码</span></span><br><span class="line">  range 192.168.209.132 192.168.209.135;       <span class="comment"># 指定IP地址池的范围</span></span><br><span class="line">  option domain-name-servers 192.168.209.2;    <span class="comment"># DNS服务器（自建的DNS或所在地区的DNS）</span></span><br><span class="line">  option domain-name <span class="string">&quot;zrs.com&quot;</span>;                <span class="comment"># 域（比如访问www，就会自动补齐www.zrs.com）</span></span><br><span class="line">  option routers 192.168.209.2;                <span class="comment"># 网关IP</span></span><br><span class="line">  option broadcast-address 192.168.209.255;    <span class="comment"># 广播地址</span></span><br><span class="line">  default-lease-time 600;</span><br><span class="line">  max-lease-time 7200;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>4、启动 DHCP 服务</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start dhcpd</span><br><span class="line">systemctl <span class="built_in">enable</span> dhcpd</span><br><span class="line">systemctl status dhcpd</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230314143137609.png" alt="image-20230314143137609"></p><h2 id="三、Client-客户端验证"><a href="#三、Client-客户端验证" class="headerlink" title="三、Client 客户端验证"></a>三、Client 客户端验证</h2><h3 id="3-1-动态获取-IP"><a href="#3-1-动态获取-IP" class="headerlink" title="3.1 动态获取 IP"></a>3.1 动态获取 IP</h3><p><strong>1、将 Client 客户端主机的网络模式调整为<code>仅主机模式</code></strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230314134224976.png" alt="image-20230314134224976"></p><p><strong>2、修改 Client 客户端主机动态获取 IP 地址</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">DEFROUTE=<span class="built_in">yes</span></span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=<span class="built_in">yes</span></span><br><span class="line">IPV6_AUTOCONF=<span class="built_in">yes</span></span><br><span class="line">IPV6_DEFROUTE=<span class="built_in">yes</span></span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">UUID=b1684e7b-7e07-4a97-aab3-deaf26b8d82b</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=<span class="built_in">yes</span></span><br></pre></td></tr></table></figure><blockquote><p>重启网络</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network.service</span><br></pre></td></tr></table></figure><h3 id="3-2-配置静态-IP"><a href="#3-2-配置静态-IP" class="headerlink" title="3.2 配置静态 IP"></a>3.2 配置静态 IP</h3><blockquote><p>通过 Client 客户端虚拟主机的 MAC 地址来指定 IP 地址。</p></blockquote><p><strong>1、获取 Client 客户端虚拟主机的 MAC</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00:0c:29:5a:29:b0</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230314144459458.png" alt="image-20230314144459458"></p><p><strong>2、修改 DHCP 服务端配置</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">host fantasia &#123;</span><br><span class="line">  hardware ethernet 00:0c:29:5a:29:b0;   <span class="comment"># MAC地址</span></span><br><span class="line">  fixed-address 192.168.209.134;         <span class="comment"># 指定IP地址</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>3、重启 DHCP Server</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart dhcpd</span><br></pre></td></tr></table></figure><p><strong>4、重启 DHCP Client 端虚拟主机网络</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network.service</span><br></pre></td></tr></table></figure><p><strong>5、验证 DHCP Client 的 IP 是否为我们指定的 IP</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip a</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230314145043110.png" alt="image-20230314145043110"></p><p>也可以通过常规设置静态 IP 的方法获取 IP，<font color="Red">但实际上通过 MAC 的形式在 DHCP 服务端上指定是最可靠的。</font></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">NM_CONTROLL=no</span><br><span class="line">DEFROUTE=<span class="built_in">yes</span></span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=<span class="built_in">yes</span></span><br><span class="line">IPV6_AUTOCONF=<span class="built_in">yes</span></span><br><span class="line">IPV6_DEFROUTE=<span class="built_in">yes</span></span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">UUID=b1684e7b-7e07-4a97-aab3-deaf26b8d82b</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=<span class="built_in">yes</span></span><br><span class="line">IPADDR=192.168.209.133</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.209.2</span><br><span class="line">DNS1=114.114.114.114</span><br><span class="line">DNS2=61.139.2.69</span><br></pre></td></tr></table></figure><blockquote><p>重启网络即可</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network.service</span><br></pre></td></tr></table></figure><p><mark>—END—</mark></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
          <category> DHCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> DHCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + GitHub 个人博客部署</title>
      <link href="/posts/articles/2d762e62.html"/>
      <url>/posts/articles/2d762e62.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230330132102576.png" alt="image-20230330132102576"></p><p><strong>官网</strong>：<a href="https://hexo.io/">https://hexo.io/</a><br><strong>Auth</strong>：rab</p><hr><h2 id="一、Hexo-运行环境"><a href="#一、Hexo-运行环境" class="headerlink" title="一、Hexo 运行环境"></a>一、Hexo 运行环境</h2><p><strong>1、运行平台</strong></p><ul><li><strong>本地环境</strong>：Windows 10</li><li><strong>线上环境</strong>：Github</li></ul><p><strong>2、运行软件环境</strong></p><blockquote><p>本地环境：Windows 10</p></blockquote><ul><li><strong>NodeJS</strong>：18.15.0(包含 npm 9.5.0)</li><li><strong>Npm</strong>：9.05</li><li><strong>Git</strong>：2.36.1</li></ul><h2 id="二、Hexo-项目初始化"><a href="#二、Hexo-项目初始化" class="headerlink" title="二、Hexo 项目初始化"></a>二、Hexo 项目初始化</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h3><p>1、安装 Hexo</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230322164752092.png" alt="image-20230322164752092"></p><p>2、查看安装的 Hexo 版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230322164656592.png" alt="image-20230322164656592"></p><p>3、创建工程并初始化</p><blockquote><p><code>hexo-blog</code> 项目名可自定义</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init hexo-blog</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230322164432235.png" alt="image-20230322164432235"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo-blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230322164550392.png" alt="image-20230322164550392"></p><blockquote><p>初始化完成后的目录结构如下图所示</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230322170606051.png" alt="image-20230322170606051"></p><h3 id="2-2-启动"><a href="#2-2-启动" class="headerlink" title="2.2 启动"></a>2.2 启动</h3><p>1、启动 Hexo 项目</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo -g      <span class="comment"># 更新文件至pubulic</span></span><br><span class="line">hexo server  <span class="comment"># 启动hexo服务</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230322164341471.png" alt="image-20230322164341471"></p><p>2、本地浏览器访问</p><blockquote><p><a href="http://localhost:4000/">http://localhost:4000/</a></p><p>下图为 Hexo 的默认 Home</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230322170028665.png" alt="image-20230322170028665"></p><h3 id="2-3-主题"><a href="#2-3-主题" class="headerlink" title="2.3 主题"></a>2.3 主题</h3><blockquote><p>本次主题：<a href="https://butterfly.js.org/">Butterfly</a></p><p>更多官网主题：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p></blockquote><h4 id="2-3-1-主题下载"><a href="#2-3-1-主题下载" class="headerlink" title="2.3.1 主题下载"></a>2.3.1 主题下载</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo-blog</span><br><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><h4 id="2-3-2-主题应用"><a href="#2-3-2-主题应用" class="headerlink" title="2.3.2 主题应用"></a>2.3.2 主题应用</h4><blockquote><p>修改 Hexo 根目录下的 <code>_config.yml</code>，把主题改为 <code>butterfly</code></p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: butterfly</span><br></pre></td></tr></table></figure><ul><li><p>修改前</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230322173612968.png" alt="image-20230322173612968"></p></li><li><p>修改后</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230322173653676.png" alt="image-20230322173653676"></p></li></ul><h4 id="2-3-3-安装插件"><a href="#2-3-3-安装插件" class="headerlink" title="2.3.3 安装插件"></a>2.3.3 安装插件</h4><blockquote><p>如果你沒有 pug 以及 stylus 的渲染器，请下载安装</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo-blog</span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><h4 id="2-3-4-升级建议"><a href="#2-3-4-升级建议" class="headerlink" title="2.3.4 升级建议"></a>2.3.4 升级建议</h4><blockquote><p>摘至插件操作文档：<a href="https://butterfly.js.org/">Butterfly</a></p></blockquote><p>为了減少升级主题后带来的不便，请使用以下方法（建议，可以不做）。</p><p>在 hexo 的根目录创建一个文件 <code>_config.butterfly.yml</code>，并把主题目录的 <code>_config.yml</code> 内容复制到 <code>_config.butterfly.yml</code> 去。</p><blockquote><p>注意: 复制的是主题的 <code>_config.yml</code> ,而不是 hexo 的 <code>_config.yml</code>。</p><p>注意： 不要把主题目录的 <code>_config.yml</code> 刪掉。</p></blockquote><p>注意：以后只需要在 <code>_config.butterfly.yml</code> 进行配置就行。</p><p>如果使用了 <code>_config.butterfly.yml</code>， 配置主题的 <code>_config.yml</code> 将不会有效果。</p><p>Hexo 会自动合并主题中的 <code>_config.yml</code> 和 <code>_config.butterfly.yml</code> 里的配置，如果存在同名配置，会使用 <code>_config.butterfly.yml</code> 的配置，其优先级较高。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230322180036589.png" alt="image-20230322180036589"></p><h4 id="2-3-5-启动-Hexo"><a href="#2-3-5-启动-Hexo" class="headerlink" title="2.3.5 启动 Hexo"></a>2.3.5 启动 Hexo</h4><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230322180135166.png" alt="image-20230322180135166"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hxeo server</span><br></pre></td></tr></table></figure><p>本地浏览器访问</p><blockquote><p><a href="http://localhost:4000/">http://localhost:4000/</a></p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230323100500616.png" alt="image-20230323100500616"></p><h2 id="三、GitHub-部署-Hexo"><a href="#三、GitHub-部署-Hexo" class="headerlink" title="三、GitHub 部署 Hexo"></a>三、GitHub 部署 Hexo</h2><p>以上的操作是在我们的 Windows 环境下实现的，我们需要发布到 GitHub 上让任何人都可以访问。</p><h3 id="3-1-创建-Git-仓库"><a href="#3-1-创建-Git-仓库" class="headerlink" title="3.1 创建 Git 仓库"></a>3.1 创建 Git 仓库</h3><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230323093845546.png" alt="image-20230323093845546"></p><h3 id="3-2-Git-客户端配置"><a href="#3-2-Git-客户端配置" class="headerlink" title="3.2 Git 客户端配置"></a>3.2 Git 客户端配置</h3><p>1、windows 本地配置并推送</p><blockquote><p>create a new repository on the command line</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;# rabcnops.github.io&quot;</span> &gt;&gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">&quot;first commit&quot;</span></span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin https://github.com/rabcnops/rabcnops.github.io.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><blockquote><p>or push an existing repository from the command line</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/rabcnops/rabcnops.github.io.git</span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230323093941950.png" alt="image-20230323093941950"></p><p>2、推送后查看 GitHuab 详情</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230323095255306.png" alt="image-20230323095255306"></p><h3 id="3-3-发布项目至-GitHub"><a href="#3-3-发布项目至-GitHub" class="headerlink" title="3.3 发布项目至 GitHub"></a>3.3 发布项目至 GitHub</h3><p>1、下载 hexo-deployer-git</p><blockquote><p>目的是能在 Hexo 主配置中定义 GitHub 的远程仓库</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo-blog</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><blockquote><p>或者直接将 <code>public</code> 目录下的所有文件和目录推送至 <code>GitHub</code> 仓库中。</p></blockquote><p>2、修改 <code>_config.yml</code> 配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/rabcnops/rabcnops.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230323094703457.png" alt="image-20230323094703457"></p><p>3、将 Hexo 项目发布至 Git 仓库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  <span class="comment"># 清理缓存</span></span><br><span class="line">hexo g      <span class="comment"># 生成文件</span></span><br><span class="line">hexo d      <span class="comment"># 上传Git仓库</span></span><br></pre></td></tr></table></figure><p>4、最后看看推送结果</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230323101017404.png" alt="image-20230323101017404"></p><p>5、查看最终 Pages 地址</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230323101258269.png" alt="image-20230323101258269"></p><h3 id="3-4-访问-GitHub-Pages"><a href="#3-4-访问-GitHub-Pages" class="headerlink" title="3.4 访问 GitHub Pages"></a>3.4 访问 GitHub Pages</h3><p>在浏览器访问测试。</p><blockquote><p><a href="https://rabcnops.github.io/">https://rabcnops.github.io/</a></p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230323101508913.png" alt="image-20230323101508913"></p><p><mark>至此，我们的博客系统已经发布至我们的 GitHub 上了。</mark></p><h2 id="四、自定义域名"><a href="#四、自定义域名" class="headerlink" title="四、自定义域名"></a>四、自定义域名</h2><p><strong>注意</strong>：这一步看你的实际情况来，这是可选的。如果你需要拥有自己的个性化域名，那你可以去<a href="https://www.aliyun.com/">阿里云</a>、<a href="https://cloud.tencent.com/">腾讯云</a>等云厂商购买域名并做域名解析配置即可。</p><h3 id="4-1-购买域名"><a href="#4-1-购买域名" class="headerlink" title="4.1 购买域名"></a>4.1 购买域名</h3><p>1、购买域名</p><p><a href="https://wanwang.aliyun.com/domain/searchresult/#/?keyword=rabcnops&suffix=cn">域名查询结果_域名信息_域名交易-万网-阿里云旗下品牌 (aliyun.com)</a></p><p>2、进入域名控制台查看购买的域名</p><p><a href="https://dc.console.aliyun.com/?spm=a2c4g.11186623.0.0.34943d96sbKudn#/domain-list/all">进入域名控制台 (aliyun.com)</a></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230330122756957.png" alt="image-20230330122756957"></p><h3 id="4-2-域名解析"><a href="#4-2-域名解析" class="headerlink" title="4.2 域名解析"></a>4.2 域名解析</h3><p>1、对购买的域名进行 DNS 解析</p><p><a href="https://dns.console.aliyun.com/?spm=5176.100251.top-nav.4.307d4f15LtAcK7#/dns/domainList">云解析 DNS (aliyun.com)</a></p><p>2、操作步骤</p><ul><li><p>添加域名</p><blockquote><p>一般不用添加（会自动在列表中），除非你是在别的云平台购买的域名。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230330122950530.png" alt="image-20230330122950530"></p></li><li><p>添加解析记录</p><blockquote><p>记录类型：CNAME</p><p>主机记录：自定义。比如你想你的网站叫 <a href="http://www.rabcnops.cn,那就填写/">www.rabcnops.cn，那就填写</a> www</p><p>记录值：也就是 Github 的 Pages 地址（最好不要填IP，因为IP可能会改变，除非是你自己的云服务器）</p><p>TTL：默认 10 分钟即可</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230330123239185.png" alt="image-20230330123239185"></p></li><li><p>完成之后，你就会看到一条解析记录</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230330125651673.png" alt="image-20230330125651673"></p></li></ul><h3 id="4-3-SSL-证书"><a href="#4-3-SSL-证书" class="headerlink" title="4.3 SSL 证书"></a>4.3 SSL 证书</h3><p>如果你有强迫症，不想看到 URL <code>不安全</code> 标志，如下图，那你就需要配置 SSL 数字证书。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230330130031143.png" alt="image-20230330130031143"></p><p>1、进入数字证书控制台</p><p><a href="https://yundun.console.aliyun.com/?spm=5176.100251.top-nav.37.307d4f15LtAcK7&p=cas#/certExtend/free">数字证书管理服务管理控制台 - SSL 证书 (aliyun.com)</a></p><p>2、创建证书</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230330130235706.png" alt="image-20230330130235706"></p><p>3、申请证书</p><blockquote><p>点击<code>申请证书</code></p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230330130313125.png" alt="image-20230330130313125"></p><p>4、填写申请</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230330130609494.png" alt="image-20230330130609494"></p><p>5、等待下发证书即可</p><blockquote><p>查看状态：已签发</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230330130724457.png" alt="image-20230330130724457"></p><p><mark>到这里，你的域名+SSL数字证书的准备工作已经完成！</mark></p><h3 id="4-4-Github-配置自定义域名"><a href="#4-4-Github-配置自定义域名" class="headerlink" title="4.4 Github 配置自定义域名"></a>4.4 Github 配置自定义域名</h3><p>去到你项目的 <code>GitHub Pages</code> 去添加你的域名，并强制启用 HTTPS。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230330131357888.png"></p><h2 id="五、Hexo-主题"><a href="#五、Hexo-主题" class="headerlink" title="五、Hexo 主题"></a>五、Hexo 主题</h2><blockquote><p>本次主题：<a href="https://butterfly.js.org/">Butterfly</a></p><p>更多 Hexo 官网主题：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p></blockquote><p>剩下的主题配置就不一步步演示了（内容太多了），更多配置看<a href="https://butterfly.js.org/">主题插件文档</a>，根据文档一步步操作即可。</p><p><mark>—END—</mark></p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prometheus - SSL 证书过期监控 - 钉钉告警</title>
      <link href="/posts/articles/462c3ed6.html"/>
      <url>/posts/articles/462c3ed6.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上次博客《Prometheus - SSL 证书过期监控》已经配置了 Grafana 如何展示 SSL 过期监控面板，本次接着将<code>告警</code>功能加上，这才是我们的最终目的。</p><h2 id="一、配置-Prometheus-告警规则"><a href="#一、配置-Prometheus-告警规则" class="headerlink" title="一、配置 Prometheus 告警规则"></a>一、配置 Prometheus 告警规则</h2><p><strong>1、先确定好 Prometheus 的规则文件路径</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230330110201021.png" alt="image-20230330110201021"></p><p><strong>2、编写告警规则</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /home/data/prometheus/rules/ssl_cert_alerts.yml</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">groups</span>:</span><br><span class="line">- name: <span class="string">&quot;SSL证书过期提醒&quot;</span></span><br><span class="line">  rules:</span><br><span class="line">  - alert: <span class="string">&quot;证书过期时间&lt;30天&quot;</span></span><br><span class="line">    <span class="built_in">expr</span>: probe_ssl_earliest_cert_expiry&#123;job=<span class="string">&quot;SSL证书时间&quot;</span>&#125; - time() &lt; 86400 * 30</span><br><span class="line">    <span class="keyword">for</span>: 0s</span><br><span class="line">    labels:</span><br><span class="line">      severity: <span class="string">&quot;提示&quot;</span></span><br><span class="line">    annotations:</span><br><span class="line">      summary: <span class="string">&quot;&#123;&#123; <span class="variable">$labels</span>.instance &#125;&#125; SSL 证书将在30天后过期，请注意及时续费！&quot;</span></span><br><span class="line">      description: <span class="string">&quot;&#123;&#123; <span class="variable">$labels</span>.instance &#125;&#125; SSL 证书将在30天后过期，请注意及时续费！&quot;</span></span><br><span class="line">  - alert: <span class="string">&quot;证书过期时间&lt;7天&quot;</span></span><br><span class="line">    <span class="built_in">expr</span>: probe_ssl_earliest_cert_expiry&#123;job=<span class="string">&quot;SSL证书时间&quot;</span>&#125; - time() &lt; 86400 * 7</span><br><span class="line">    <span class="keyword">for</span>: 0s</span><br><span class="line">    labels:</span><br><span class="line">      severity: <span class="string">&quot;告警&quot;</span></span><br><span class="line">    annotations:</span><br><span class="line">      summary: <span class="string">&quot;&#123;&#123; <span class="variable">$labels</span>.instance &#125;&#125; SSL 证书将在7天后过期，请注意及时续费！&quot;</span></span><br><span class="line">      description: <span class="string">&quot;&#123;&#123; <span class="variable">$labels</span>.instance &#125;&#125; SSL 证书将在7天后过期，请注意及时续费！&quot;</span></span><br><span class="line">  - alert: <span class="string">&quot;证书过期时间&lt;1天&quot;</span></span><br><span class="line">    <span class="built_in">expr</span>: probe_ssl_earliest_cert_expiry&#123;job=<span class="string">&quot;SSL证书时间&quot;</span>&#125; - time() &lt; 86400 * 1</span><br><span class="line">    <span class="keyword">for</span>: 0s</span><br><span class="line">    labels:</span><br><span class="line">      severity: <span class="string">&quot;灾难&quot;</span></span><br><span class="line">    annotations:</span><br><span class="line">      summary: <span class="string">&quot;&#123;&#123; <span class="variable">$labels</span>.instance &#125;&#125; SSL 证书将在1天后过期，请注意及时续费！&quot;</span></span><br><span class="line">      description: <span class="string">&quot;&#123;&#123; <span class="variable">$labels</span>.instance &#125;&#125; SSL 证书将在1天后过期，请注意及时续费！&quot;</span></span><br></pre></td></tr></table></figure><p><strong>3、重启 Prometheus</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart prometheus</span><br></pre></td></tr></table></figure><h2 id="二、配置-Alertmanager"><a href="#二、配置-Alertmanager" class="headerlink" title="二、配置 Alertmanager"></a>二、配置 Alertmanager</h2><p><strong>1、修改配置文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /home/data/alertmanager/conf/config.yml</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">global:</span><br><span class="line">  resolve_timeout: 5m</span><br><span class="line">route:</span><br><span class="line">  group_wait: 0s</span><br><span class="line">  group_interval: 5s</span><br><span class="line">  repeat_interval: 1m</span><br><span class="line">  group_by: [<span class="string">&#x27;instance&#x27;</span>]</span><br><span class="line">  receiver: <span class="string">&#x27;web.hook.prometheusalert&#x27;</span></span><br><span class="line"></span><br><span class="line">receivers:</span><br><span class="line">- name: <span class="string">&#x27;web.hook.prometheusalert&#x27;</span></span><br><span class="line">  webhook_configs:</span><br><span class="line">  - url: <span class="string">&#x27;http://YourDingTalk_IP:8060/dingtalk/webhook1/send&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>2、重启 Alertmanager</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart alertmanager</span><br></pre></td></tr></table></figure><h2 id="三、配置-DingTalk"><a href="#三、配置-DingTalk" class="headerlink" title="三、配置 DingTalk"></a>三、配置 DingTalk</h2><p><strong>1、配置文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /home/data/dingtalk/conf/config.yml</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">templates:</span><br><span class="line">  - /etc/prometheus-webhook-dingtalk/templates/default.tmpl</span><br><span class="line">targets:</span><br><span class="line">  webhook1:</span><br><span class="line">    url: https://oapi.dingtalk.com/robot/send?access_token=8cf8d025f***a4537b22</span><br><span class="line">    secret: SECb***95fbab</span><br><span class="line">    mention:</span><br><span class="line">      all: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>2、模板文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /home/data/dingtalk/templates/default.tmpl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：这里的templates路径为什么与上面的templates路径不对应，那是因为我是用容器起的DingTalk，取的是容器内部路径</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">...</span><br><span class="line">&#123;&#123;/* Firing */&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; define <span class="string">&quot;default.__text_alert_list&quot;</span> &#125;&#125;&#123;&#123; range . &#125;&#125;</span><br><span class="line"></span><br><span class="line">**触发时间:** &#123;&#123; dateInZone <span class="string">&quot;2006.01.02 15:04:05&quot;</span> (.StartsAt) <span class="string">&quot;Asia/Shanghai&quot;</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line">**摘要:** &#123;&#123; .Annotations.summary &#125;&#125;</span><br><span class="line"></span><br><span class="line">**描述:** &#123;&#123; .Annotations.description &#125;&#125;</span><br><span class="line"></span><br><span class="line">**监控:** [grafana](http://grafana_ip:8000/grafana/d/GuJ5DHMnz/fu-wu-qi-jian-kong-tu-biao?orgId=1)</span><br><span class="line"></span><br><span class="line">**详情:**</span><br><span class="line">&#123;&#123; range .Labels.SortedPairs &#125;&#125;&#123;&#123; <span class="keyword">if</span> and (ne (.Name) <span class="string">&quot;severity&quot;</span>) (ne (.Name) <span class="string">&quot;summary&quot;</span>) &#125;&#125;&gt; - &#123;&#123; .Name &#125;&#125;: &#123;&#123; .Value | markdown | html &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;&#123;&#123; end &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;&#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;/* Resolved */&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; define <span class="string">&quot;default.__text_resolved_list&quot;</span> &#125;&#125;&#123;&#123; range . &#125;&#125;</span><br><span class="line"></span><br><span class="line">**触发时间:** &#123;&#123; dateInZone <span class="string">&quot;2006.01.02 15:04:05&quot;</span> (.StartsAt) <span class="string">&quot;Asia/Shanghai&quot;</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line">**解除时间:** &#123;&#123; dateInZone <span class="string">&quot;2006.01.02 15:04:05&quot;</span> (.EndsAt) <span class="string">&quot;Asia/Shanghai&quot;</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line">**摘要:** &#123;&#123; .Annotations.summary &#125;&#125;</span><br><span class="line"></span><br><span class="line">**监控:** [grafana](http://grafana_ip:8000/grafana/d/GuJ5DHMnz/fu-wu-qi-jian-kong-tu-biao?orgId=1)</span><br><span class="line"></span><br><span class="line">**详情:**</span><br><span class="line">&#123;&#123; range .Labels.SortedPairs &#125;&#125;&#123;&#123; <span class="keyword">if</span> and (ne (.Name) <span class="string">&quot;severity&quot;</span>) (ne (.Name) <span class="string">&quot;summary&quot;</span>) &#125;&#125;&gt; - &#123;&#123; .Name &#125;&#125;: &#123;&#123; .Value | markdown | html &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;&#123;&#123; end &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;&#123;&#123; end &#125;&#125;</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>3、重启 DingTalk</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart dingtalk</span><br></pre></td></tr></table></figure><h2 id="四、模拟告警与恢复"><a href="#四、模拟告警与恢复" class="headerlink" title="四、模拟告警与恢复"></a>四、模拟告警与恢复</h2><p><strong>1、钉钉告警通知</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230330111655592.png" alt="image-20230330111655592"></p><p><strong>2、钉钉解除告警通知</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230330112013249.png" alt="image-20230330112013249"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整体来说都比较简单，重点是要理清楚整个过程链，配置过程中仔细点即可，接下来会继续剖析告警的原理&#x2F;告警的时机。</p>]]></content>
      
      
      <categories>
          
          <category> 监控系统 </category>
          
          <category> Prometheus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Prometheus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ansible 部署 Wordpress</title>
      <link href="/posts/articles/1c8d3a9.html"/>
      <url>/posts/articles/1c8d3a9.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、规划"><a href="#一、规划" class="headerlink" title="一、规划"></a>一、规划</h2><ul><li>Linux 环境：CentOS 7.9</li><li>ansible 控制节点：192.168.56.152</li><li>ansible 被管理节点：192.168.56.153</li><li>Wordpress 版本：4.9.4</li></ul><h2 id="二、部署"><a href="#二、部署" class="headerlink" title="二、部署"></a>二、部署</h2><h3 id="2-1-定义-inventory"><a href="#2-1-定义-inventory" class="headerlink" title="2.1 定义 inventory"></a>2.1 定义 inventory</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim inventory.yaml</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mywebhost:</span><br><span class="line">  hosts:</span><br><span class="line">    vm01:</span><br><span class="line">      ansible_host: 192.168.56.153</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：mywebhost 为组名</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-2-定义-playbook"><a href="#2-2-定义-playbook" class="headerlink" title="2.2 定义 playbook"></a>2.2 定义 playbook</h3><p>1、下载 wordpress 安装包</p><p>下载地址<a href="https://cn.wordpress.org/download/releases/">https://cn.wordpress.org/download/releases/</a></p><p>2、上传安装包至 ansible 控制节点</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /home/data/ansible</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230328233159669.png" alt="image-20230328233159669"></p><p>3、ansible 控制节点编写 playbook</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim wordpress.yml</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: mywebhost</span><br><span class="line">  remote_user: root</span><br><span class="line">  vars:</span><br><span class="line">    db_pkgs:</span><br><span class="line">      - mariadb</span><br><span class="line">      - mariadb-server</span><br><span class="line">    web_pkgs:</span><br><span class="line">      - httpd</span><br><span class="line">      - php</span><br><span class="line">      - php-gd</span><br><span class="line">      - php-mysql</span><br><span class="line">      - gd</span><br><span class="line">  tasks:</span><br><span class="line">    - name: install mariadb</span><br><span class="line">      yum: name=&#123;&#123; db_pkgs &#125;&#125; state=latest</span><br><span class="line">      when: ansible_nodename == <span class="string">&#x27;wordpress&#x27;</span></span><br><span class="line">    - name: install webserver</span><br><span class="line">      yum: name=&#123;&#123; web_pkgs &#125;&#125; state=latest</span><br><span class="line">      when: ansible_nodename == <span class="string">&#x27;wordpress&#x27;</span></span><br><span class="line">    - name: start mariadb</span><br><span class="line">      service: name=mariadb state=started</span><br><span class="line">      notify: create_db</span><br><span class="line">      when: ansible_nodename == <span class="string">&#x27;wordpress&#x27;</span>      </span><br><span class="line">    - name: start webserver</span><br><span class="line">      service: name=httpd state=started</span><br><span class="line">      when: ansible_nodename == <span class="string">&#x27;wordpress&#x27;</span></span><br><span class="line">      </span><br><span class="line">    - name: to package</span><br><span class="line">      unarchive: src=/home/data/ansible/wordpress-4.9.4-zh_CN.tar.gz dest=/var/www/html</span><br><span class="line">      when: ansible_nodename == <span class="string">&#x27;wordpress&#x27;</span>   </span><br><span class="line">    - name: <span class="built_in">chown</span></span><br><span class="line">      file: owner=apache group=apache recurse=<span class="built_in">yes</span> path=/var/www/html</span><br><span class="line">      when: ansible_nodename == <span class="string">&#x27;wordpress&#x27;</span>     </span><br><span class="line">  handlers:</span><br><span class="line">    - name: create_db</span><br><span class="line">      shell: mysql -e <span class="string">&quot;create database wordpress;grant all on *.* to &#x27;remote&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;flush privileges;&quot;</span></span><br><span class="line">      when: ansible_nodename == <span class="string">&#x27;wordpress&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-运行-playbook"><a href="#2-3-运行-playbook" class="headerlink" title="2.3 运行 playbook"></a>2.3 运行 playbook</h3><p>1、运行前三部曲</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查错误</span></span><br><span class="line">ansible-playbook wordpress.yml -i inventory.yaml --syntax-check</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有任务</span></span><br><span class="line">ansible-playbook wordpress.yml -i inventory.yaml --list-task</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出在那些机器执行</span></span><br><span class="line">ansible-playbook wordpress.yml -i inventory.yaml --list-hosts</span><br></pre></td></tr></table></figure><p>2、运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook wordpress.yml -i inventory.yaml</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230329103140769.png" alt="image-20230329103140769"></p><h3 id="2-4-安装-wordpress"><a href="#2-4-安装-wordpress" class="headerlink" title="2.4 安装 wordpress"></a>2.4 安装 wordpress</h3><p>1、浏览器访问</p><blockquote><p><a href="http://192.168.56.153/wordpress">http://192.168.56.153/wordpress</a></p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230329095308748.png" alt="image-20230329095308748"></p><p>2、配置数据库</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230329095739451.png" alt="image-20230329095739451"></p><p>3、开始安装 wordpress</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230329110018596.png" alt="image-20230329110018596"></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230329110415294.png" alt="image-20230329110415294"></p><h3 id="2-5-登录-wordpress"><a href="#2-5-登录-wordpress" class="headerlink" title="2.5 登录 wordpress"></a>2.5 登录 wordpress</h3><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230329110544631.png" alt="image-20230329110544631"></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230329110715387.png" alt="image-20230329110715387"></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230329110829054.png" alt="image-20230329110829054"></p><p><mark>说明：我这里为了演示，就在一台服务器上进行安装 wordpress 了，如果你想把你的数据库&#x2F;nginx等分开在不同的服务器部署，那也是可以的，只需要指定 playbook 文件中的 <code>ansible_nodename</code> 为你对应的主机名即可，具体一份案例如下。</mark></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="comment"># 功能：ansible搭建LAMP环境及WordPress项目部署</span></span><br><span class="line"><span class="comment"># 对所有主机操作（即通过ansible机器向web:155和database:156机器进行批量操作）</span></span><br><span class="line"><span class="comment"># hosts: 后面可写主机组名或主机名</span></span><br><span class="line">- hosts: mywebhost</span><br><span class="line">  remote_user: root</span><br><span class="line">  <span class="comment"># 定义变量</span></span><br><span class="line">  vars:</span><br><span class="line">    db_pkgs:</span><br><span class="line">      <span class="comment"># 以下的-为变量“值”，也就是在引用db_pkgs变量时，可取变量中的值</span></span><br><span class="line">      - mariadb</span><br><span class="line">      - mariadb-server</span><br><span class="line">    web_pkgs:</span><br><span class="line">      - httpd</span><br><span class="line">      - php</span><br><span class="line">      - php-gd</span><br><span class="line">      - php-mysql</span><br><span class="line">      - gd</span><br><span class="line">  <span class="comment"># tasks：ansible机器要执行操作的任务列表（依次执行）</span></span><br><span class="line">  tasks:</span><br><span class="line">    <span class="comment"># 安装mariadb</span></span><br><span class="line">    - name: install mariadb</span><br><span class="line">    <span class="comment"># 引用变量时使用&#123;&#123;&#125;&#125;</span></span><br><span class="line">      yum: name=&#123;&#123; db_pkgs &#125;&#125; state=latest</span><br><span class="line">      when: ansible_nodename == <span class="string">&#x27;database&#x27;</span></span><br><span class="line">    <span class="comment"># 安装webserver相关服务（httpd、php）</span></span><br><span class="line">    - name: install webserver</span><br><span class="line">      yum: name=&#123;&#123; web_pkgs &#125;&#125; state=latest</span><br><span class="line">      when: ansible_nodename == <span class="string">&#x27;web&#x27;</span></span><br><span class="line">    <span class="comment"># 启动mariadb</span></span><br><span class="line">    - name: start mariadb</span><br><span class="line">      service: name=mariadb state=started</span><br><span class="line">      <span class="comment"># 触发（类似c语言的中断信号），触发后会去handlers执行相关操作</span></span><br><span class="line">      notify: create_db</span><br><span class="line">      <span class="comment"># when判断，用来针对某主机执行的操作，比如这里是指定对database组里的机器进行操作</span></span><br><span class="line">      when: ansible_nodename == <span class="string">&#x27;database&#x27;</span></span><br><span class="line">    <span class="comment"># 启动webserver相关服务</span></span><br><span class="line">    - name: start webserver</span><br><span class="line">      service: name=httpd state=started</span><br><span class="line">      when: ansible_nodename == <span class="string">&#x27;web&#x27;</span></span><br><span class="line">    <span class="comment"># 将项目包发送到指定机器（及解包）  </span></span><br><span class="line">    - name: to package</span><br><span class="line">      unarchive: src=/home/data/ansible/wordpress-4.9.4-zh_CN.tar.gz dest=/var/www/html</span><br><span class="line">      when: ansible_nodename == <span class="string">&#x27;web&#x27;</span></span><br><span class="line">    <span class="comment"># 修改指定机器网站发布目录属组/主</span></span><br><span class="line">    - name: <span class="built_in">chown</span></span><br><span class="line">      file: owner=apache group=apache recurse=<span class="built_in">yes</span> path=var/www/html</span><br><span class="line">      when: ansible_nodename == <span class="string">&#x27;web&#x27;</span></span><br><span class="line">      </span><br><span class="line">  handlers:</span><br><span class="line">    <span class="comment"># 注意：这里的name名字必须和notify的触发名称保持一致</span></span><br><span class="line">    - name: create_db</span><br><span class="line">      <span class="comment"># 调用shell解释器执行相关命令</span></span><br><span class="line">      shell: mysql -e <span class="string">&quot;create database wordpress;grant all on *.* to &#x27;remote&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;flush privileges;&quot;</span></span><br><span class="line">      <span class="comment"># 同样这里是针对database这个主机组里的机器</span></span><br><span class="line">      when: ansible_nodename == <span class="string">&#x27;database&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="三、FAQ"><a href="#三、FAQ" class="headerlink" title="三、FAQ"></a>三、FAQ</h2><p>1、普通用户连接失败</p><p><code>ERROR 1045 (28000): Access denied for user &#39;remote&#39;@&#39;localhost</code></p><p>2、原因分析与解决方案</p><p>这里注意数据库 MariaDB 的匿名用户问题，匿名用户会导致我们普通用户无法登录（连接）数据库，如下这些红框部分就是匿名用户：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230329111136989.png" alt="image-20230329111136989"></p><p>因此我们需要删除这些匿名用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user &#x27;&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">user &#x27;&#x27;@&#x27;wordpress&#x27;;</span><br><span class="line">flush privileges</span><br></pre></td></tr></table></figure><blockquote><p>如下图，确保数据库中不存在匿名用户</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230329111747894.png" alt="image-20230329111747894"></p><p><mark>至此，问题已经解决。</mark></p>]]></content>
      
      
      <categories>
          
          <category> 自动化运维 </category>
          
          <category> Ansible </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ansible </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 Docker 的 Prometheus 监控方案</title>
      <link href="/posts/articles/e36de20c.html"/>
      <url>/posts/articles/e36de20c.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/prometheus.jpeg" alt="prometheus"></p><p><font color=Brown><strong>Author</strong>：rab</font><br><font color=Brown><strong>Date</strong>：2022&#x2F;07&#x2F;18</font><br><font color=Brown><strong>Blog</strong>：<a href="https://blog.csdn.net/IT_ZRS?type=blog"><font color=Brown>https://blog.csdn.net/IT_ZRS?type&#x3D;blog</font></a></font></p><hr><h2 id="一、规划"><a href="#一、规划" class="headerlink" title="一、规划"></a>一、规划</h2><h3 id="1-1-架构图"><a href="#1-1-架构图" class="headerlink" title="1.1 架构图"></a>1.1 架构图</h3><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/architecture.png" alt="architecture"></p><p>我们将按照架构图来实现。</p><h3 id="1-2-主机规划"><a href="#1-2-主机规划" class="headerlink" title="1.2 主机规划"></a>1.2 主机规划</h3><blockquote><p>由于主机资源问题，暂且以两台服务器进行演示。</p></blockquote><table><thead><tr><th>Host</th><th>server</th><th>备注</th></tr></thead><tbody><tr><td>192.168.56.141</td><td>Prometheus、Node_exporter</td><td>Prometheus 服务、采集插件</td></tr><tr><td>192.168.56.142</td><td>Grafana、Alertmanager、Node_exporter、DingTalk</td><td>监控展示、告警服务、采集插件</td></tr></tbody></table><p>版本：</p><ul><li><p>CentOS：7.9</p></li><li><p>Prometheus：2.37.0</p></li><li><p>Grafana：9.0.3</p></li><li><p>Alertmanager：0.20.0</p></li><li><p>node-exporter：1.4.0</p></li><li><p>Dingding：1.4.0</p></li></ul><p>下载：</p><ul><li>Prometheus：<a href="https://prometheus.io/docs/prometheus/latest/installation/">https://prometheus.io/docs/prometheus/latest/installation/</a></li><li>Grafana：<a href="https://grafana.com/grafana/download">https://grafana.com/grafana/download</a></li><li>Alertmanager：</li><li>node-exporter：</li></ul><h2 id="二、部署"><a href="#二、部署" class="headerlink" title="二、部署"></a>二、部署</h2><blockquote><p>相关组件下载地址：<a href="https://prometheus.io/download/">https://prometheus.io/download/</a></p><p>前提：已经对服务器做了相关初始化，且安装了 docker 容器引擎。</p></blockquote><h3 id="2-1-Prometheus"><a href="#2-1-Prometheus" class="headerlink" title="2.1 Prometheus"></a>2.1 Prometheus</h3><blockquote><p>官方文档：<a href="https://prometheus.io/docs/introduction/overview/">https://prometheus.io/docs/introduction/overview/</a></p></blockquote><p>1、pull 镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull bitnami/prometheus:2.37.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本次采用最新稳定版</span></span><br></pre></td></tr></table></figure><p>2、创建监控用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd -g 2000 monitor</span><br><span class="line">useradd -u 2000 -g monitor monitor</span><br></pre></td></tr></table></figure><p>3、创建相关目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /home/data/prometheus/&#123;etc,data,rules&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">etc：配置文件目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">data：数据目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rules：规则目录</span></span><br></pre></td></tr></table></figure><p>4、创建配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /home/data/prometheus/etc/prometheus.yml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或先启动临时容器再copy也是可以的</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">my global config</span></span><br><span class="line">global:</span><br><span class="line">  scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.</span><br><span class="line">  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">scrape_timeout is <span class="built_in">set</span> to the global default (10s).</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Alertmanager configuration</span></span><br><span class="line">alerting:</span><br><span class="line">  alertmanagers:</span><br><span class="line">  - static_configs:</span><br><span class="line">    - targets:</span><br><span class="line">      # - alertmanager:9093</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Load rules once and periodically evaluate them according to the global <span class="string">&#x27;evaluation_interval&#x27;</span>.</span></span><br><span class="line">rule_files:</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">- <span class="string">&quot;first_rules.yml&quot;</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">- <span class="string">&quot;second_rules.yml&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">A scrape configuration containing exactly one endpoint to scrape:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Here it<span class="string">&#x27;s Prometheus itself.</span></span></span><br><span class="line">scrape_configs:</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span></span></span><br><span class="line">  - job_name: &#x27;prometheus&#x27;</span><br><span class="line"></span><br><span class="line">    # metrics_path defaults to &#x27;/metrics&#x27;</span><br><span class="line">    # scheme defaults to &#x27;http&#x27;.</span><br><span class="line"></span><br><span class="line">    static_configs:</span><br><span class="line">    - targets: [&#x27;localhost:9090&#x27;]</span><br></pre></td></tr></table></figure><p>5、目录授权</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown monitor. -R /home/data/prometheus</span><br></pre></td></tr></table></figure><p>6、启动容器</p><blockquote><p>运行容器前，先看看这个镜像容器启动后会执行什么命令</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f &#x27;&#123;&#123;.Config.Cmd&#125;&#125;&#x27; bitnami/prometheus:2.37.0</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220924181619392.png" alt="image-20220924181619392"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --user root \</span><br><span class="line">    --name=prometheus \</span><br><span class="line">    --privileged=true \</span><br><span class="line">    --restart=always \</span><br><span class="line">    -p 9090:9090 \</span><br><span class="line">    -v /home/data/prometheus/etc/prometheus.yml:/etc/prometheus/prometheus.yml \</span><br><span class="line">    -v /home/data/prometheus/rules:/etc/prometheus/rules \</span><br><span class="line">    -v /home/data/prometheus/data:/data/prometheus \</span><br><span class="line">    -v /etc/localtime:/etc/localtime \</span><br><span class="line">    bitnami/prometheus:2.37.0 \</span><br><span class="line">    --config.file=&quot;/etc/prometheus/prometheus.yml&quot; \</span><br><span class="line">    --storage.tsdb.path=&quot;/data/prometheus&quot; \</span><br><span class="line">    --web.console.libraries=/opt/bitnami/prometheus/conf/console_libraries \</span><br><span class="line">    --web.console.templates=/opt/bitnami/prometheus/conf/consoles \</span><br><span class="line">    --web.enable-lifecycle \</span><br><span class="line">    --web.enable-admin-api</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">至于为什么跟什么--参数，在我前面 docker 原理中有讲到</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker inspect &lt;image&gt;   <span class="comment"># 查看CMD参数</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">想要使用热加载，需指定--web.enable-lifecycle参数</span></span><br></pre></td></tr></table></figure><p>7、访问验证</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220718122145247.png" alt="image-20220718122145247">8、热更新</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://192.168.56.141:9090/-/reload</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我docker方式部署的热加载无效，正在找原因</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">原因已经找到，我自己大意，没看镜像的相关信息，已解决</span></span><br></pre></td></tr></table></figure><p>9、语法检测</p><blockquote><p>这一点的好处在于检测你更新配置后是否有语法错误</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec prometheus promtool check config /etc/prometheus/prometheus.yml</span><br></pre></td></tr></table></figure><p>确保无误后即可重启或热更新 Prometheus。 </p><h3 id="2-2-Grafana"><a href="#2-2-Grafana" class="headerlink" title="2.2 Grafana"></a>2.2 Grafana</h3><blockquote><p>官方文档：<a href="https://grafana.com/docs/">https://grafana.com/docs/</a></p></blockquote><p>1、pull 镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull grafana/grafana:9.0.3</span><br></pre></td></tr></table></figure><p>2、创建监控用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd -g 2000 monitor</span><br><span class="line">useradd -u 2000 -g monitor monitor</span><br></pre></td></tr></table></figure><p>3、创建相关目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /home/data/grafana/data</span><br><span class="line">mkdir -p /home/data/grafana/logs</span><br></pre></td></tr></table></figure><p>4、启动临时容器（copy相关配置文件）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3000:3000 --name=tmp grafana/grafana:9.0.3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制配置文件</span></span><br><span class="line">docker cp tmp:/etc/grafana/ /home/data/grafana/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出临时容器</span></span><br><span class="line">exit</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改文件名</span></span><br><span class="line">mv /home/data/grafana/grafana /home/data/grafana/etc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除临时容器</span></span><br><span class="line">docker stop tmp</span><br><span class="line">docker rm tmp</span><br></pre></td></tr></table></figure><p>5、目录授权</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown -R monitor. /home/data/grafana</span><br><span class="line">chmod 777 -R /home/data/grafana</span><br></pre></td></tr></table></figure><p>6、启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --user root \</span><br><span class="line">    --name=grafana \</span><br><span class="line">    --privileged=true \</span><br><span class="line">    --restart=always \</span><br><span class="line">    -p 3000:3000 \</span><br><span class="line">    -v /home/data/grafana/etc:/etc/grafana \</span><br><span class="line">    -v /home/data/grafana/data:/var/lib/grafana \</span><br><span class="line">    -v /home/data/grafana/logs:/var/log/grafana \</span><br><span class="line">    -v /etc/localtime:/etc/localtime \</span><br><span class="line">    grafana/grafana:9.0.3</span><br></pre></td></tr></table></figure><p>7、登录验证</p><blockquote><p>默认用户：admin</p><p>默认密码：admin</p><p>输入完成之后，会提示你再次输入新的登录密码。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220718134653471.png" alt="image-20220718134653471"></p><p>功能界面</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220718134806098.png" alt="image-20220718134806098"></p><p>8、忘记密码</p><blockquote><p>如果忘记密码，如何重置？</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">语法：grafana-cli &lt;登录用户&gt; reset-admin-password &lt;新密码&gt;</span></span><br><span class="line"></span><br><span class="line">docker exec grafana grafana-cli admin reset-admin-password admin@123</span><br></pre></td></tr></table></figure><p>9、插件安装</p><ul><li><p>在线安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker exec grafana grafana-cli plugins list-remote | more   # 查看远程可用插件</span><br><span class="line">id: abhisant-druid-datasource version: 0.0.6</span><br><span class="line">id: aceiot-svg-panel version: 0.0.11</span><br><span class="line">id: ae3e-plotly-panel version: 0.5.0</span><br><span class="line">id: agenty-flowcharting-panel version: 0.9.1</span><br><span class="line">id: aidanmountford-html-panel version: 0.0.2</span><br><span class="line">id: akumuli-datasource version: 1.3.12</span><br><span class="line">id: alexanderzobnin-zabbix-app version: 4.2.10</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>根据这些远程可用插件即可进行安装</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">案例：grafana-cli plugins install &lt;插件名&gt; &lt;插件版本号&gt;</span></span><br><span class="line">grafana-cli plugins install alexanderzobnin-zabbix-app 4.2.10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定安装路径</span></span><br><span class="line">grafana-cli --pluginsDir=/data/grafana/plugins plugins install alexanderzobnin-zabbix-app 4.1.5</span><br></pre></td></tr></table></figure><blockquote><p>安装语法</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">COMMANDS:</span><br><span class="line">   install                  install &lt;plugin id&gt; &lt;plugin version (optional)&gt;</span><br><span class="line">   list-remote              list remote available plugins</span><br><span class="line">   list-versions            list-versions &lt;plugin id&gt;</span><br><span class="line">   update, upgrade          update &lt;plugin id&gt;</span><br><span class="line">   update-all, upgrade-all  update all your installed plugins</span><br><span class="line">   ls                       list all installed plugins</span><br><span class="line">   uninstall, remove        uninstall &lt;plugin id&gt;</span><br><span class="line">   help, h                  Shows a list of commands or help for one command</span><br></pre></td></tr></table></figure></li><li><p>手动安装</p><blockquote><p>如果在线安装失败，可进行手动安装</p></blockquote><p>第一步：访问grafana官网 <a href="https://grafana.com/grafana/plugins?orderBy=weight&direction=asc">https://grafana.com/grafana/plugins?orderBy=weight&direction=asc</a></p><p>第二步：查找要下载的插件，如：Pie Chart</p><p>第三步：根据安官网提供的装步骤下载即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在线下载zip包</span></span><br><span class="line">wget -nv https://grafana.com/api/plugins/grafana-piechart-panel/versions/latest/download -O /tmp/grafana-piechart-panel.zip</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或上传</span></span><br><span class="line">unzip -q /tmp/grafana-piechart-panel.zip -d /tmp</span><br><span class="line">mv /tmp/grafana-piechart-panel-* /var/lib/grafana/plugins/grafana-piechart-panel</span><br><span class="line">sudo service grafana-server restar</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-Node-Exporter"><a href="#2-3-Node-Exporter" class="headerlink" title="2.3 Node_Exporter"></a>2.3 Node_Exporter</h3><p><code>node_exporter</code> 作为 Prometheus 的 agent 端，部署在被采集数据的 Host 上，其负责采集数据供 Prometheus 进行抓取。这里采用二进制方式部署即可。</p><p>1、下载二进制包</p><p><a href="https://github.com/prometheus/node_exporter">https://github.com/prometheus/node_exporter</a></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220924165651183.png" alt="image-20220924165651183"></p><p>2、配置 systemd 管理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/node_exporter.service</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Node Exporter</span><br><span class="line">Wants=network-online.target</span><br><span class="line">After=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=prometheus</span><br><span class="line">ExecStart=/home/data/prometheus/exporters/node_exporter/node_exporter --collector.textfile.directory /home/data/node_texfile --collector.systemd --collector.systemd.unit-include=&quot;(docker|sshd).service&quot;</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=default.target</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">具体参数参考我有道云笔记《Exporter+Promethue+Grafana监控平台》部分</span></span><br></pre></td></tr></table></figure><p>3、启动并设置开机自启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start node_exporter.service</span><br><span class="line">systemctl enable node_exporter.service</span><br></pre></td></tr></table></figure><p>5、验证</p><blockquote><p>这里以 141 服务器演示</p><p>浏览器访问：<a href="http://192.168.56.141:9100/metrics">http://192.168.56.141:9100/metrics</a></p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220924170321058.png" alt="image-20220924170321058"></p><p>&#x3D;&#x3D;这里用 Host 的方式部署即可，当然你也可以通过 Docker 的防暑部署。&#x3D;&#x3D;</p><p>pull 镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull prom/node-exporter:latest</span><br></pre></td></tr></table></figure><p>运行容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name=node-exporter \</span><br><span class="line">  --restart=always \</span><br><span class="line">  --privileged=true \</span><br><span class="line">  --hostname=harbor-nexus \</span><br><span class="line">  -p 9100:9100 \</span><br><span class="line">  -v /proc:/host/proc:ro \</span><br><span class="line">  -v /sys:/host/sys:ro \</span><br><span class="line">  -v /:/rootfs:ro \</span><br><span class="line">  prom/node-exporter:latest</span><br></pre></td></tr></table></figure><p>Prometheus 添加配置即可（这里不再演示）</p><h3 id="2-4-Alertmanager"><a href="#2-4-Alertmanager" class="headerlink" title="2.4 Alertmanager"></a>2.4 Alertmanager</h3><blockquote><p>官方文档：<a href="https://prometheus.io/docs/alerting/latest/alertmanager/">https://prometheus.io/docs/alerting/latest/alertmanager/</a></p></blockquote><p>告警采用 Alertmanager 进行管理，其告警原理可简单概括为：当采集数据值达到告警阈值时（在prometheus设定的告警规则），就会触发 Alertmanager 进行告警（经过分组、删除重复等处理），告警通过可邮件等方式发送给相应的运维人员。主要配置步骤：</p><ul><li>设置和配置 Alertmanager；</li><li>配置 Prometheus 与 Alertmanager 之间的对话；</li><li>在 Prometheus 中创建警报规则。</li></ul><p><code>prometheus---&gt;触发阈值---&gt;超出持续时间---&gt;alertmanager---&gt;分组|抑制|静默---&gt;媒体类型---&gt;邮件|钉钉|微信等。</code></p><p>&#x3D;&#x3D;这里我采用单节点部署，一般我们生产环境中 Alertmanager 采用集群部署。&#x3D;&#x3D;</p><h4 id="2-4-1-部署与配置"><a href="#2-4-1-部署与配置" class="headerlink" title="2.4.1 部署与配置"></a>2.4.1 部署与配置</h4><p>1、先看容器启动时会加载哪些参数</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220924193728233.png" alt="image-20220924193728233"></p><p>2、创建本地持久化目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /home/data/alertmanager/&#123;conf,data,template&#125;</span><br></pre></td></tr></table></figure><p>3、创建配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /home/data/alertmanager/conf/config.yml</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">global:</span><br><span class="line">  resolve_timeout: 5m</span><br><span class="line">  smtp_smarthost: &#x27;smtp.163.com:465&#x27;                # 邮箱服务器</span><br><span class="line">  smtp_from: &#x27;zhurongsen_admin@163.com&#x27;             # 邮箱地址（发送用户）</span><br><span class="line">  smtp_auth_username: &#x27;zhurongsen_admin@163.com&#x27;    # 邮箱登录地址</span><br><span class="line">  smtp_auth_password: &#x27;DYKIFIZYKUOXRPFV&#x27;            # 邮箱授权码（注意是授权码，不是登录密码）</span><br><span class="line">  smtp_require_tls: false</span><br><span class="line"></span><br><span class="line">templates:</span><br><span class="line">- &#x27;/etc/alertmanager/template/*.tmpl&#x27;</span><br><span class="line"></span><br><span class="line">route:</span><br><span class="line">  group_by: [&#x27;alertname&#x27;]</span><br><span class="line">  group_wait: 20s</span><br><span class="line">  group_interval: 5m</span><br><span class="line">  repeat_interval: 3h</span><br><span class="line">  receiver: &#x27;ops&#x27;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="built_in">continue</span>: <span class="literal">false</span></span></span><br><span class="line">  routes:</span><br><span class="line">  - match:</span><br><span class="line">      severity: critical</span><br><span class="line">    receiver: &#x27;dev&#x27;</span><br><span class="line">    # continue: true</span><br><span class="line">  - match_re:</span><br><span class="line">      severity: ^(warning|critical)$</span><br><span class="line">    receiver: &#x27;test&#x27;</span><br><span class="line"></span><br><span class="line">receivers:</span><br><span class="line">- name: &#x27;ops&#x27;</span><br><span class="line">  email_configs:</span><br><span class="line">  - to: &#x27;2564395767@qq.com&#x27;</span><br><span class="line">    send_resolved: true</span><br><span class="line"></span><br><span class="line">- name: &#x27;dev&#x27;</span><br><span class="line">  email_configs:</span><br><span class="line">  - to: &#x27;2318099451@qq.com&#x27;</span><br><span class="line">    send_resolved: true</span><br><span class="line">    </span><br><span class="line">- name: &#x27;test&#x27;</span><br><span class="line">  email_configs:</span><br><span class="line">  - to: &#x27;zhurongsen_admin@126.com&#x27;</span><br><span class="line">    send_resolved: true</span><br><span class="line"></span><br><span class="line">inhibit_rules:</span><br><span class="line">  - source_match:</span><br><span class="line">      severity: &#x27;critical&#x27;</span><br><span class="line">    target_match:</span><br><span class="line">      severity: &#x27;warning&#x27;</span><br><span class="line">    equal: [&#x27;alertname&#x27;, &#x27;dev&#x27;, &#x27;instance&#x27;]</span><br></pre></td></tr></table></figure><p>4、运行容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --restart=always \</span><br><span class="line">  --name=alertmanager \</span><br><span class="line">  --privileged=true \</span><br><span class="line">  -p 9093:9093 \</span><br><span class="line">  -v /home/data/alertmanager/conf/config.yml:/etc/alertmanager/alertmanager.yml \</span><br><span class="line">  -v /home/data/alertmanager/template:/etc/alertmanager/template \</span><br><span class="line">  -v /etc/localtime:/etc/localtime \</span><br><span class="line">  docker.io/prom/alertmanager:latest</span><br></pre></td></tr></table></figure><p>5、web 验证</p><blockquote><p>浏览器访问：<a href="http://192.168.56.142:9093/">http://192.168.56.142:9093/</a></p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220924201055281.png" alt="image-20220924201055281"></p><p>6、Prometheus 配置</p><blockquote><p>配置与 Alertmanager 通信</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Alertmanager configuration</span></span><br><span class="line">alerting:</span><br><span class="line">  alertmanagers:</span><br><span class="line">  - static_configs:</span><br><span class="line">    - targets:</span><br><span class="line">      - 192.168.56.142:9093</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>Alertmanager 自身也进行了数据采集，自然也可以进行状态监控</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220924204227389.png" alt="image-20220924204227389"></p><h4 id="2-4-2-告警规则"><a href="#2-4-2-告警规则" class="headerlink" title="2.4.2 告警规则"></a>2.4.2 告警规则</h4><p>Alertmanager 配置完成后，还需要在 prometheus 配置文件中进行告警配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rule_files:</span><br><span class="line">  - &quot;first_rules.yml&quot;      # 记录规则</span><br><span class="line">  - &quot;second_rules.yml&quot;     # 告警规则</span><br></pre></td></tr></table></figure><blockquote><p>修改 Prometheus 配置文件，定义这两个文件得路径</p><p>docker 目录映射规则：&#x2F;home&#x2F;data&#x2F;prometheus&#x2F;rules:&#x2F;etc&#x2F;prometheus&#x2F;rules</p><p>所以我只需要在 &#x2F;home&#x2F;data&#x2F;prometheus&#x2F;rules 目录下创建规则即可</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">rule_files:</span><br><span class="line">  - &#x27;/etc/prometheus/rules/*_rules.yml&#x27;</span><br><span class="line">  - &#x27;/etc/prometheus/rules/*_alerts.yml&#x27;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="2-4-2-1-记录规则"><a href="#2-4-2-1-记录规则" class="headerlink" title="2.4.2.1 记录规则"></a>2.4.2.1 记录规则</h5><blockquote><p>新建记录规则文件：简单测试被采集服务器得健康状况</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /home/data/prometheus/rules</span><br><span class="line">vim host_rules.yml</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">groups:</span><br><span class="line">- name: host.rules</span><br><span class="line">  rules:</span><br><span class="line">    - record: instance:node_stat:up</span><br><span class="line">      expr: up&#123;job=&quot;linux&quot;&#125; == 0</span><br></pre></td></tr></table></figure><h5 id="2-4-2-2-告警规则"><a href="#2-4-2-2-告警规则" class="headerlink" title="2.4.2.2 告警规则"></a>2.4.2.2 告警规则</h5><blockquote><p>主机节点基础告警</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /home/data/prometheus/rules</span><br><span class="line">vim host_alerts.yml</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">groups:</span><br><span class="line">- name: host.alter</span><br><span class="line">  rules:</span><br><span class="line">    - alert: host_up</span><br><span class="line">      expr: instance:node_stat:up == 0</span><br><span class="line">      for: 20s</span><br><span class="line">      labels:</span><br><span class="line">        severity: warning</span><br><span class="line">      annotations:</span><br><span class="line">        summary: &quot;&#123;&#123; $labels.instance &#125;&#125; 已停止运行超过20s！请手动检查服务健康状态&quot;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;在 Prometheus 服务上可看见定义的告警规则&#x3D;&#x3D;</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220924232204472.png" alt="image-20220924232204472"></p><h4 id="2-4-3-告警验证"><a href="#2-4-3-告警验证" class="headerlink" title="2.4.3 告警验证"></a>2.4.3 告警验证</h4><p>以上记录规则和告警规则都完成后，现在就模拟服务器故障，看是否发送告警。</p><p>1、先看看健康状态</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220924231451970.png" alt="image-20220924231451970"></p><p>2、停掉 141 服务器的 node_exporter 插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">141</span></span><br><span class="line">systemctl stop node_exporter.service</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">142</span></span><br><span class="line">systemctl stop node_exporter.service</span><br></pre></td></tr></table></figure><p>下图是我 126 邮箱收到的信息，原因是根据 Alertmanager 的路由策略来分发的，即当收到 wornning 告警时会匹配到该邮件并发送邮件。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220924233102780.png" alt="image-20220924233102780"></p><h2 id="三、应用案例"><a href="#三、应用案例" class="headerlink" title="三、应用案例"></a>三、应用案例</h2><h3 id="3-1-主机发现"><a href="#3-1-主机发现" class="headerlink" title="3.1 主机发现"></a>3.1 主机发现</h3><h4 id="3-1-1-静态配置"><a href="#3-1-1-静态配置" class="headerlink" title="3.1.1 静态配置"></a>3.1.1 静态配置</h4><p><code>node_exporter</code> 部署完成后，还需要在 Prometheus 服务配置文件中进行配置，以此来 pull node_exporter 采集的数据。</p><p>什么是静态配置？所谓的静态配置就是在 Prometheus 配置文件中直接指定目标 Host。</p><p>1、修改 Prometheus 配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">...</span><br><span class="line">scrape_configs:</span><br><span class="line">  - job_name: &#x27;prometheus&#x27;</span><br><span class="line">    static_configs:</span><br><span class="line">    # - targets: [&#x27;localhost:9090&#x27;]</span><br><span class="line"></span><br><span class="line">  - job_name: &#x27;linux&#x27;</span><br><span class="line">    static_configs:</span><br><span class="line">    - targets: [&#x27;192.168.56.141:9100&#x27;, &#x27;192.168.56.142:9100&#x27;]</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>2、Prometheus 服务热更新或重启</p><blockquote><p>先检测语法是否错误再重启或热加载，否则你也是启动不了的。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart prometheus</span><br></pre></td></tr></table></figure><h4 id="3-1-2-动态配置"><a href="#3-1-2-动态配置" class="headerlink" title="3.1.2 动态配置"></a>3.1.2 动态配置</h4><h5 id="3-1-2-1-基于本地文件"><a href="#3-1-2-1-基于本地文件" class="headerlink" title="3.1.2.1 基于本地文件"></a>3.1.2.1 基于本地文件</h5><p>动态配置是将被采集的目标 Host 写入一个 json 文件中，Prometheus 服务会定期去扫描其中的目标主机，如果有新的主机添加，则 Prometheus 自动获取无需热更或重启 Prometheus 服务。</p><p>1、修改 Prometheus 配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">...</span><br><span class="line">  - job_name: &#x27;linux&#x27;</span><br><span class="line">    file_sd_configs:</span><br><span class="line">      - files:</span><br><span class="line">        - /data/prometheus/target/nodes/*.json</span><br><span class="line">        refresh_interval: 1m</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这个 json 文件可以是一个泛文件：<code>/data/prometheus/target/nodes/*.json</code> 表示 Prometheus 或每隔 1 分钟查找 <code>/data/prometheus/target/nodes/</code> 目录下的所有以 <code>.json</code> 结尾的文件。</p><p>2、编写 json 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建存放json目录（对于docker部署的Prometheus，该目录在容器内部必须能读取得到）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上面得配置文件中/data/prometheus/目录已经被映射到/home/data/prometheus/data/目录下了</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所以直接在/home/data/prometheus/data/目录下创建相关文件即可</span></span><br><span class="line">mkdir -p /home/data/prometheus/data/target/nodes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在*.json文件中添加目标主机IP</span></span><br><span class="line">vim host.json</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">  &quot;targets&quot;: [</span><br><span class="line">    &quot;192.168.56.141:9100&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先写一台Host IP进行测试，成功再添加另一台</span></span><br></pre></td></tr></table></figure><p>3、Prometheus 语法检测</p><p>4、等 1 分钟时间后再去验证一下</p><blockquote><p>可看到 141 服务器已经被添加上来了</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220924173134729.png" alt="image-20220924173134729"></p><p>我再次添加 142 主机 IP，再次验证是否自动添加，同样修改配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">  &quot;targets&quot;: [</span><br><span class="line">    &quot;192.168.56.141:9100&quot;,</span><br><span class="line">    &quot;192.168.56.142:9100&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>再次验证：可看到在 1 分钟后 142 服务器被自动添加</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220924173427913.png" alt="image-20220924173427913"></p><p><mark>如何给主机节点添加标签？</mark></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">  &quot;targets&quot;: [&quot;192.168.56.141:9100&quot;],</span><br><span class="line">  &quot;labels&quot;: &#123;</span><br><span class="line">    &quot;instance&quot;: &quot;192.168.56.141&quot;,</span><br><span class="line">    &quot;Hostname&quot;: &quot;prometheus&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  &quot;targets&quot;: [&quot;192.168.56.142:9100&quot;],</span><br><span class="line">  &quot;labels&quot;: &#123;</span><br><span class="line">    &quot;instance&quot;: &quot;192.168.56.142&quot;,</span><br><span class="line">    &quot;Hostname&quot;: &quot;grafana&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><h5 id="3-1-2-2-基于-DNS"><a href="#3-1-2-2-基于-DNS" class="headerlink" title="3.1.2.2 基于 DNS"></a>3.1.2.2 基于 DNS</h5><p>1、Prometheus 配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;webapp&#x27;</span><br><span class="line">  dns_sd_configs:</span><br><span class="line">    - names: [&#x27;app.scedutek.com&#x27;]  # 域名，保证该域名需做了解析</span><br><span class="line">      refresh_interval: 5m         # 5每分钟执行（刷新）一次</span><br><span class="line">      type: A</span><br><span class="line">      port: 80</span><br></pre></td></tr></table></figure><p>2、热更或重启 prometheus</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart prometheus</span><br></pre></td></tr></table></figure><h3 id="3-2-钉钉集成"><a href="#3-2-钉钉集成" class="headerlink" title="3.2 钉钉集成"></a>3.2 钉钉集成</h3><h4 id="3-2-1-钉钉机器人配置"><a href="#3-2-1-钉钉机器人配置" class="headerlink" title="3.2.1 钉钉机器人配置"></a>3.2.1 钉钉机器人配置</h4><blockquote><p>进入钉钉应用进行相关配置</p></blockquote><p>1、创建项目群</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221007102952619.png" alt="image-20221007102952619"></p><p>2、群聊添加告警机器人</p><ul><li><p>项目群中点击设置</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221007103334618.png" alt="image-20221007103334618"></p></li><li><p>点击群智能助手</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221007103440941.png" alt="image-20221007103440941"></p></li><li><p>添加机器人</p><blockquote><p>点击添加机器人</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221007103654901.png" alt="image-20221007103654901"></p><blockquote><p>进一步点击设置进行添加</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221007103802892.png" alt="image-20221007103802892"></p></li><li><p>添加自定义机器人</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221007104024684.png" alt="image-20221007104024684"></p></li></ul><p>3、配置认证（加签）</p><blockquote><ol><li>自定义机器人名字；</li><li>将机器人添加到群组；</li><li>安全设置处加签，并记录加签值（钉钉插件配置文件会用到）</li></ol></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221007104211324.png" alt="image-20221007104211324"></p><p>4、获取机器人 <code>webhook</code></p><blockquote><p>钉钉插件配置文件会用到</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221007104600830.png" alt="image-20221007104600830"></p><h4 id="3-2-2-部署钉钉插件"><a href="#3-2-2-部署钉钉插件" class="headerlink" title="3.2.2 部署钉钉插件"></a>3.2.2 部署钉钉插件</h4><p>1、准备配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建</span></span><br><span class="line">mkdir -p /home/data/dingtalk/conf/&#123;conf,templates&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动临时容器</span></span><br><span class="line">docker run --rm --name=tmp timonwong/prometheus-webhook-dingtalk:latest</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制相关配置文件至Host</span></span><br><span class="line">cd /home/data/dingtalk/conf &amp;&amp; docker cp tmp:/etc/prometheus-webhook-dingtalk/config.yml .</span><br><span class="line">cd /home/data/dingtalk/templates &amp;&amp; docker cp dingtalk:/etc/prometheus-webhook-dingtalk/templates/default.tmpl .</span><br></pre></td></tr></table></figure><p>2、准备告警模板</p><blockquote><p>可以先简单测试一下</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /home/data/dingtalk/templates/default.tmpl</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; define &quot;ding.link.content&quot; &#125;&#125;</span><br><span class="line">&#123;&#123; if gt (len .Alerts.Firing) 0 -&#125;&#125;</span><br><span class="line">告警列表:</span><br><span class="line">&#123;&#123; template &quot;__text_alert_list&quot; .Alerts.Firing &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line">&#123;&#123; if gt (len .Alerts.Resolved) 0 -&#125;&#125;</span><br><span class="line">恢复列表:</span><br><span class="line">&#123;&#123; template &quot;__text_resolve_list&quot; .Alerts.Resolved &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上测试无误后，以下为最终模板</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /home/data/dingtalk/templates/default.tmpl</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; template &quot;ding.link.content&quot; . &#125;&#125;&#123;&#123; define &quot;__subject&quot; &#125;&#125;[&#123;&#123; .Status | toUpper &#125;&#125;&#123;&#123; if eq .Status &quot;firing&quot; &#125;&#125;:&#123;&#123; .Alerts.Firing | len &#125;&#125;&#123;&#123; end &#125;&#125;] &#123;&#123; .GroupLabels.SortedPairs.Values | join &quot; &quot; &#125;&#125; &#123;&#123; if gt (len .CommonLabels) (len .GroupLabels) &#125;&#125;(&#123;&#123; with .CommonLabels.Remove .GroupLabels.Names &#125;&#125;&#123;&#123; .Values | join &quot; &quot; &#125;&#125;&#123;&#123; end &#125;&#125;)&#123;&#123; end &#125;&#125;&#123;&#123; end &#125;&#125;</span><br><span class="line">&#123;&#123; define &quot;__alertmanagerURL&quot; &#125;&#125;&#123;&#123; $alertURL := &quot;http://192.168.56.142:9093&quot; &#125;&#125; &#123;&#123;- $alertURL -&#125;&#125;/#/alerts?receiver=&#123;&#123; .Receiver &#125;&#125;&amp;tmp=&#123;&#123; .ExternalURL &#125;&#125;&#123;&#123; end &#125;&#125;</span><br><span class="line"> </span><br><span class="line">&#123;&#123; define &quot;__text_alert_list&quot; &#125;&#125;&#123;&#123; range . &#125;&#125;</span><br><span class="line">**Labels**</span><br><span class="line">&#123;&#123; range .Labels.SortedPairs &#125;&#125;&gt; - &#123;&#123; .Name &#125;&#125;: &#123;&#123; .Value | markdown | html &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">**Annotations**</span><br><span class="line">&#123;&#123; range .Annotations.SortedPairs &#125;&#125;&gt; - &#123;&#123; .Name &#125;&#125;: &#123;&#123; .Value | markdown | html &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">**Source:** [&#123;&#123; .GeneratorURL &#125;&#125;](&#123;&#123; .GeneratorURL &#125;&#125;)</span><br><span class="line">&#123;&#123; end &#125;&#125;&#123;&#123; end &#125;&#125;</span><br><span class="line"> </span><br><span class="line">&#123;&#123;/* Firing */&#125;&#125;</span><br><span class="line"> </span><br><span class="line">&#123;&#123; define &quot;default.__text_alert_list&quot; &#125;&#125;&#123;&#123; range . &#125;&#125;</span><br><span class="line"> </span><br><span class="line">**触发时间:** &#123;&#123; dateInZone &quot;2006.01.02 15:04:05&quot; (.StartsAt) &quot;Asia/Shanghai&quot; &#125;&#125;</span><br><span class="line"></span><br><span class="line">**摘要:** &#123;&#123; .Annotations.summary &#125;&#125;</span><br><span class="line"></span><br><span class="line">**描述:** &#123;&#123; .Annotations.description &#125;&#125;</span><br><span class="line"></span><br><span class="line">**监控:** [grafana](http://192.168.25.10:3000/grafana/d/GuJ5DHMnz/fu-wu-qi-jian-kong-tu-biao?orgId=1)</span><br><span class="line"></span><br><span class="line">**详情:**</span><br><span class="line">&#123;&#123; range .Labels.SortedPairs &#125;&#125;&#123;&#123; if and (ne (.Name) &quot;severity&quot;) (ne (.Name) &quot;summary&quot;) &#125;&#125;&gt; - &#123;&#123; .Name &#125;&#125;: &#123;&#123; .Value | markdown | html &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;&#123;&#123; end &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;&#123;&#123; end &#125;&#125;</span><br><span class="line"> </span><br><span class="line">&#123;&#123;/* Resolved */&#125;&#125;</span><br><span class="line"> </span><br><span class="line">&#123;&#123; define &quot;default.__text_resolved_list&quot; &#125;&#125;&#123;&#123; range . &#125;&#125;</span><br><span class="line"> </span><br><span class="line">**触发时间:** &#123;&#123; dateInZone &quot;2006.01.02 15:04:05&quot; (.StartsAt) &quot;Asia/Shanghai&quot; &#125;&#125;</span><br><span class="line"></span><br><span class="line">**解除时间:** &#123;&#123; dateInZone &quot;2006.01.02 15:04:05&quot; (.EndsAt) &quot;Asia/Shanghai&quot; &#125;&#125;</span><br><span class="line"> </span><br><span class="line">**摘要:** &#123;&#123; .Annotations.summary &#125;&#125;</span><br><span class="line">**监控:** [grafana](http://192.168.25.10:8000/grafana/d/GuJ5DHMnz/fu-wu-qi-jian-kong-tu-biao?orgId=1)</span><br><span class="line">**详情:**</span><br><span class="line">&#123;&#123; range .Labels.SortedPairs &#125;&#125;&#123;&#123; if and (ne (.Name) &quot;severity&quot;) (ne (.Name) &quot;summary&quot;) &#125;&#125;&gt; - &#123;&#123; .Name &#125;&#125;: &#123;&#123; .Value | markdown | html &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;&#123;&#123; end &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;&#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;/* Default */&#125;&#125;</span><br><span class="line">&#123;&#123; define &quot;default.title&quot; &#125;&#125;&#123;&#123; template &quot;__subject&quot; . &#125;&#125;&#123;&#123; end &#125;&#125;</span><br><span class="line">&#123;&#123; define &quot;default.content&quot; &#125;&#125;#### \[&#123;&#123; .Status | toUpper &#125;&#125;&#123;&#123; if eq .Status &quot;firing&quot; &#125;&#125;:&#123;&#123; .Alerts.Firing | len &#125;&#125;&#123;&#123; end &#125;&#125;\] **[&#123;&#123; index .GroupLabels &quot;alertname&quot; &#125;&#125;](&#123;&#123; template &quot;__alertmanagerURL&quot; . &#125;&#125;)**</span><br><span class="line">&#123;&#123; if gt (len .Alerts.Firing) 0 -&#125;&#125;</span><br><span class="line"></span><br><span class="line">![Firing-img](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.zhimg.com%2F50%2Fv2-6cf86cca04090c375720cd5a90cb9156_720w.jpg%3Fsource%3D1940ef5c&amp;refer=http%3A%2F%2Fpic1.zhimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1658461957&amp;t=25a208eae036691050ea197ccfbb3a7b)</span><br><span class="line"></span><br><span class="line">**告警通知**</span><br><span class="line">&#123;&#123; template &quot;default.__text_alert_list&quot; .Alerts.Firing &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line">&#123;&#123; if gt (len .Alerts.Resolved) 0 -&#125;&#125;</span><br><span class="line"></span><br><span class="line">![Resolved-img](https://t10.baidu.com/it/u=3212103844,163082301&amp;fm=30&amp;app=106&amp;f=JPEG?w=640&amp;h=480&amp;s=03801B6418732B8E0C9D2DDA030010A2)</span><br><span class="line"></span><br><span class="line">**告警解除**</span><br><span class="line">&#123;&#123; template &quot;default.__text_resolved_list&quot; .Alerts.Resolved &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;/* Legacy */&#125;&#125;</span><br><span class="line">&#123;&#123; define &quot;legacy.title&quot; &#125;&#125;&#123;&#123; template &quot;__subject&quot; . &#125;&#125;&#123;&#123; end &#125;&#125;</span><br><span class="line">&#123;&#123; define &quot;legacy.content&quot; &#125;&#125;#### \[&#123;&#123; .Status | toUpper &#125;&#125;&#123;&#123; if eq .Status &quot;firing&quot; &#125;&#125;:&#123;&#123; .Alerts.Firing | len &#125;&#125;&#123;&#123; end &#125;&#125;\] **[&#123;&#123; index .GroupLabels &quot;alertname&quot; &#125;&#125;](&#123;&#123; template &quot;__alertmanagerURL&quot; . &#125;&#125;)**</span><br><span class="line">&#123;&#123; template &quot;__text_alert_list&quot; .Alerts.Firing &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;/* Following names for compatibility */&#125;&#125;</span><br><span class="line">&#123;&#123; define &quot;ding.link.title&quot; &#125;&#125;&#123;&#123; template &quot;default.title&quot; . &#125;&#125;&#123;&#123; end &#125;&#125;</span><br><span class="line">&#123;&#123; define &quot;ding.link.content&quot; &#125;&#125;&#123;&#123; template &quot;default.content&quot; . &#125;&#125;&#123;&#123; end &#125;&#125;</span><br><span class="line">                                                                          </span><br></pre></td></tr></table></figure><p>3、修改配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /home/data/dingtalk/conf/config.yml</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">templates:</span><br><span class="line">  - /etc/prometheus-webhook-dingtalk/templates/default.tmpl</span><br><span class="line">targets:</span><br><span class="line">  webhook1:</span><br><span class="line">    url: https://oapi.dingtalk.com/robot/send?access_token=8cf8d025f4cffb1c140129360bd373c6fa64a74dc29d6a41fcd07bb5a4537b22 </span><br><span class="line">    secret: SECb7e604e38d9d58456f4811c29daaa8953f39f3bfc5b98cccb664325a1d95fbab</span><br><span class="line">    mention:                            </span><br><span class="line">      all: true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">templates：指定模板位置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">webhook1：指定钉钉的Token</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">securet：机器人加签的值</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mention：告警时提醒对象</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   all：提醒所有人</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   mobiles: [<span class="string">&#x27;152***&#x27;</span>, <span class="string">&#x27;134***&#x27;</span>]  提醒指定钉钉用户</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221012134825735.png" alt="image-20221012134825735"></p><p>3、运行钉钉插件容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name=dingtalk \</span><br><span class="line">  --restart always \</span><br><span class="line">  -p 8060:8060 \</span><br><span class="line">  -v /home/data/dingtalk/conf/config.yml:/etc/prometheus-webhook-dingtalk/config.yml \</span><br><span class="line">  -v /home/data/dingtalk/templates/default.tmpl:/etc/prometheus-webhook-dingtalk/templates/default.tmpl \</span><br><span class="line">  timonwong/prometheus-webhook-dingtalk:latest --web.enable-ui --config.file=/etc/prometheus-webhook-dingtalk/config.yml</span><br></pre></td></tr></table></figure><p><mark>以上钉钉是通过加签的方式进行认证，接下来介绍通过 IP 的方式进行认证</mark></p><p>同样在钉钉告警机器人处设置，添加 IP，下图解释很清楚，只有同个网络下的请求才能被处理，有一定的局限性，加签的方式却没有这些局限。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221012133219719.png" alt="image-20221012133219719"></p><p><mark>此时钉钉的配置文件如下：</mark></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /home/data/dingtalk/conf/config.yml</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">templates:</span><br><span class="line">  - /etc/prometheus-webhook-dingtalk/templates/default.tmpl</span><br><span class="line">targets:</span><br><span class="line">  webhook1:</span><br><span class="line">    url: https://oapi.dingtalk.com/robot/send?access_token=8cf8d025f4cffb1c140129360bd373c6fa64a74dc29d6a41fcd07bb5a4537b22</span><br><span class="line">    mention:</span><br><span class="line">      all: true</span><br><span class="line">      </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">templates：指定模板位置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">webhook1：指定钉钉的Token</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mention：告警时提醒对象</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   all：提醒所有人</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   mobiles: [<span class="string">&#x27;152***&#x27;</span>, <span class="string">&#x27;134***&#x27;</span>]  提醒指定钉钉用户</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221012133818087.png" alt="image-20221012133818087"></p><p>修改完配置重启即可！</p><h4 id="3-2-3-Alertmanager-配置"><a href="#3-2-3-Alertmanager-配置" class="headerlink" title="3.2.3 Alertmanager 配置"></a>3.2.3 Alertmanager 配置</h4><blockquote><p>设置<code>alertmanager</code> 的yml的<code>route</code>与<code>receivers</code></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">global:</span><br><span class="line">  resolve_timeout: 5m</span><br><span class="line">route:</span><br><span class="line">  group_wait: 25s</span><br><span class="line">  group_interval: 30s</span><br><span class="line">  repeat_interval: 1m</span><br><span class="line">  group_by: [&#x27;instance&#x27;]</span><br><span class="line">  receiver: &#x27;web.hook.prometheusalert&#x27;</span><br><span class="line"></span><br><span class="line">receivers:</span><br><span class="line">- name: &#x27;web.hook.prometheusalert&#x27;</span><br><span class="line">  webhook_configs:</span><br><span class="line">  - url: &#x27;http://192.168.56.142:8060/dingtalk/webhook1/send&#x27;</span><br><span class="line">    send_resolved: true</span><br></pre></td></tr></table></figure><blockquote><p>上面的配置是，无论什么的告警级别，都会向钉钉发送告警。而下面的配置则会根据告警级别选择性发送告警</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">route:</span><br><span class="line">  group_by: [&#x27;alertname&#x27;]</span><br><span class="line">  group_wait: 20s</span><br><span class="line">  group_interval: 30s</span><br><span class="line">  repeat_interval: 1m</span><br><span class="line">  receiver: &#x27;ops&#x27;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="built_in">continue</span>: <span class="literal">false</span></span></span><br><span class="line">  routes:</span><br><span class="line">  - match:</span><br><span class="line">      severity: critical</span><br><span class="line">    receiver: &#x27;dev&#x27;</span><br><span class="line">    # continue: true</span><br><span class="line">  - match_re:</span><br><span class="line">      severity: ^(warning|critical)$</span><br><span class="line">    receiver: &#x27;webhook&#x27;</span><br><span class="line"></span><br><span class="line">receivers:</span><br><span class="line">- name: &#x27;dev&#x27;</span><br><span class="line">  email_configs:</span><br><span class="line">  - to: &#x27;2222222@qq.com&#x27;</span><br><span class="line">    send_resolved: true</span><br><span class="line">- name: &#x27;webhook&#x27;</span><br><span class="line">  webhook_configs:</span><br><span class="line">  - url: http://192.168.56.142:8060/dingtalk/webhook1/send</span><br><span class="line">    send_resolved: true</span><br></pre></td></tr></table></figure><p>比如：一般信息告警 ——&gt; 普通告警 ——&gt; 灾难告警，不同的告警分别发送给不同的用户。为了快速测试，我选择了无论什么告警我都发送告警。</p><h4 id="3-2-4-告警测试验证"><a href="#3-2-4-告警测试验证" class="headerlink" title="3.2.4 告警测试验证"></a>3.2.4 告警测试验证</h4><h5 id="3-2-4-1-默认告警模板"><a href="#3-2-4-1-默认告警模板" class="headerlink" title="3.2.4.1 默认告警模板"></a>3.2.4.1 默认告警模板</h5><p>如果钉钉配置文件不指定 templates 的位置，则使用默认告警模板。</p><p>1、告警</p><blockquote><p>故意停掉 node_exporter 进程</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221004231759335.png" alt="image-20221004231759335"></p><p>2、恢复</p><blockquote><p>恢复 node_exporter 进程</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221004232000604.png" alt="image-20221004232000604"></p><h5 id="3-2-4-2-自定义告警模板"><a href="#3-2-4-2-自定义告警模板" class="headerlink" title="3.2.4.2 自定义告警模板"></a>3.2.4.2 自定义告警模板</h5><p>1、告警</p><blockquote><p>故意停掉 node_exporter 进程</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221012134640168.png" alt="image-20221012134640168"></p><p>2、恢复</p><blockquote><p>恢复 node_exporter 进程</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221012134722471.png" alt="image-20221012134722471"></p><h3 id="3-3-企业微信集成"><a href="#3-3-企业微信集成" class="headerlink" title="3.3 企业微信集成"></a>3.3 企业微信集成</h3><h4 id="3-3-1-应用告警"><a href="#3-3-1-应用告警" class="headerlink" title="3.3.1 应用告警"></a>3.3.1 应用告警</h4><h5 id="3-3-1-1-创建应用"><a href="#3-3-1-1-创建应用" class="headerlink" title="3.3.1.1 创建应用"></a>3.3.1.1 创建应用</h5><p>1、windows 登录企业微信后台创建应用</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221007095158587.png" alt="image-20221007095158587"></p><blockquote><ol><li>上传 logo；</li><li>填写应用名；</li><li>应用介绍（可选）；</li><li>选择可见范围（即哪些部门&#x2F;成员可使用）。</li></ol></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221007095324360.png" alt="image-20221007095324360"></p><p>2、记录应用的 <code>AgentId</code>、<code>Secret</code></p><blockquote><p><strong>AgentId</strong>：<code>1000002</code></p><p><strong>Secret</strong>：<code>EKmMR_DieISGXZDallbdnFb1OGaV2kADrrjN_UCj56Y</code></p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221007095829708.png" alt="image-20221007095829708"></p><p>3、记录企业 ID</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221007100654570.png" alt="image-20221007100654570"></p><p>4、记录部门 ID</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221007114732172.png" alt="image-20221007114732172"></p><h5 id="3-3-1-2-Alertmanager-配置"><a href="#3-3-1-2-Alertmanager-配置" class="headerlink" title="3.3.1.2 Alertmanager 配置"></a>3.3.1.2 Alertmanager 配置</h5><p>看官方配置：<a href="https://prometheus.io/docs/alerting/latest/configuration/#wechat_config">https://prometheus.io/docs/alerting/latest/configuration/#wechat_config</a></p><p>1、配置说明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Whether to notify about resolved alerts.</span></span><br><span class="line">[ send_resolved: &lt;boolean&gt; | default = false ]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The API key to use when talking to the WeChat API.</span></span><br><span class="line">[ api_secret: &lt;secret&gt; | default = global.wechat_api_secret ]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The WeChat API URL.</span></span><br><span class="line">[ api_url: &lt;string&gt; | default = global.wechat_api_url ]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The corp <span class="built_in">id</span> <span class="keyword">for</span> authentication.</span></span><br><span class="line">[ corp_id: &lt;string&gt; | default = global.wechat_api_corp_id ]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">API request data as defined by the WeChat API.</span></span><br><span class="line">[ message: &lt;tmpl_string&gt; | default = &#x27;&#123;&#123; template &quot;wechat.default.message&quot; . &#125;&#125;&#x27; ]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Type of the message <span class="built_in">type</span>, supported values are `text` and `markdown`.</span></span><br><span class="line">[ message_type: &lt;string&gt; | default = &#x27;text&#x27; ]</span><br><span class="line">[ agent_id: &lt;string&gt; | default = &#x27;&#123;&#123; template &quot;wechat.default.agent_id&quot; . &#125;&#125;&#x27; ]</span><br><span class="line">[ to_user: &lt;string&gt; | default = &#x27;&#123;&#123; template &quot;wechat.default.to_user&quot; . &#125;&#125;&#x27; ]</span><br><span class="line">[ to_party: &lt;string&gt; | default = &#x27;&#123;&#123; template &quot;wechat.default.to_party&quot; . &#125;&#125;&#x27; ]</span><br><span class="line">[ to_tag: &lt;string&gt; | default = &#x27;&#123;&#123; template &quot;wechat.default.to_tag&quot; . &#125;&#125;&#x27; ]</span><br></pre></td></tr></table></figure><p>2、消息模板定义，用于格式化消息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /home/data/alertmanager/conf &amp;&amp; vim wechat.tmpl</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; define &quot;wechat.default.message&quot; &#125;&#125;</span><br><span class="line">&#123;&#123;- if gt (len .Alerts.Firing) 0 -&#125;&#125;</span><br><span class="line">&#123;&#123;- range $index, $alert := .Alerts -&#125;&#125;</span><br><span class="line">&#123;&#123;- if eq $index 0 -&#125;&#125;</span><br><span class="line">告警类型: &#123;&#123; $alert.Labels.alertname &#125;&#125;</span><br><span class="line">告警级别: &#123;&#123; $alert.Labels.severity &#125;&#125;</span><br><span class="line">=====================</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line">===告警详情===</span><br><span class="line">告警详情: &#123;&#123; $alert.Annotations.message &#125;&#125;</span><br><span class="line">故障时间: &#123;&#123; $alert.StartsAt.Format &quot;2006-01-02 15:04:05&quot; &#125;&#125;</span><br><span class="line">===参考信息===</span><br><span class="line">&#123;&#123; if gt (len $alert.Labels.instance) 0 -&#125;&#125;故障实例ip: &#123;&#123; $alert.Labels.instance &#125;&#125;;&#123;&#123;- end -&#125;&#125;</span><br><span class="line">&#123;&#123;- if gt (len $alert.Labels.namespace) 0 -&#125;&#125;故障实例所在namespace: &#123;&#123; $alert.Labels.namespace &#125;&#125;;&#123;&#123;- end -&#125;&#125;</span><br><span class="line">&#123;&#123;- if gt (len $alert.Labels.node) 0 -&#125;&#125;故障物理机ip: &#123;&#123; $alert.Labels.node &#125;&#125;;&#123;&#123;- end -&#125;&#125;</span><br><span class="line">&#123;&#123;- if gt (len $alert.Labels.pod_name) 0 -&#125;&#125;故障pod名称: &#123;&#123; $alert.Labels.pod_name &#125;&#125;&#123;&#123;- end &#125;&#125;</span><br><span class="line">=====================</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line">&#123;&#123;- if gt (len .Alerts.Resolved) 0 -&#125;&#125;</span><br><span class="line">&#123;&#123;- range $index, $alert := .Alerts -&#125;&#125;</span><br><span class="line">&#123;&#123;- if eq $index 0 -&#125;&#125;</span><br><span class="line">告警类型: &#123;&#123; $alert.Labels.alertname &#125;&#125;</span><br><span class="line">告警级别: &#123;&#123; $alert.Labels.severity &#125;&#125;</span><br><span class="line">=====================</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line">===告警详情===</span><br><span class="line">告警详情: &#123;&#123; $alert.Annotations.message &#125;&#125;</span><br><span class="line">故障时间: &#123;&#123; $alert.StartsAt.Format &quot;2006-01-02 15:04:05&quot; &#125;&#125;</span><br><span class="line">恢复时间: &#123;&#123; $alert.EndsAt.Format &quot;2006-01-02 15:04:05&quot; &#125;&#125;</span><br><span class="line">===参考信息===</span><br><span class="line">&#123;&#123; if gt (len $alert.Labels.instance) 0 -&#125;&#125;故障实例ip: &#123;&#123; $alert.Labels.instance &#125;&#125;;&#123;&#123;- end -&#125;&#125;</span><br><span class="line">&#123;&#123;- if gt (len $alert.Labels.namespace) 0 -&#125;&#125;故障实例所在namespace: &#123;&#123; $alert.Labels.namespace &#125;&#125;;&#123;&#123;- end -&#125;&#125;</span><br><span class="line">&#123;&#123;- if gt (len $alert.Labels.node) 0 -&#125;&#125;故障物理机ip: &#123;&#123; $alert.Labels.node &#125;&#125;;&#123;&#123;- end -&#125;&#125;</span><br><span class="line">&#123;&#123;- if gt (len $alert.Labels.pod_name) 0 -&#125;&#125;故障pod名称: &#123;&#123; $alert.Labels.pod_name &#125;&#125;;&#123;&#123;- end &#125;&#125;</span><br><span class="line">=====================</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure><p>3、修改 Alertmanager 配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /home/data/alertmanager/template &amp;&amp; vim config.yml</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">global:</span><br><span class="line">  resolve_timeout: 5m</span><br><span class="line">  smtp_smarthost: &#x27;smtp.163.com:465&#x27;                # 邮箱服务器</span><br><span class="line">  smtp_from: &#x27;zhurongsen_admin@163.com&#x27;             # 邮箱地址（发送用户）</span><br><span class="line">  smtp_auth_username: &#x27;zhurongsen_admin@163.com&#x27;    # 邮箱登录地址</span><br><span class="line">  smtp_auth_password: &#x27;DYKIFIZYKUOXRPFV&#x27;            # 邮箱授权码（注意是授权码，不是登录密码）</span><br><span class="line">  smtp_require_tls: false</span><br><span class="line">  wechat_api_url: &#x27;https://qyapi.weixin.qq.com/cgi-bin/&#x27;   # 企业微信URL</span><br><span class="line">  wechat_api_corp_id: &#x27;wwb5ef1460edf62593&#x27;                 # 企业ID</span><br><span class="line"></span><br><span class="line">templates:</span><br><span class="line">- &#x27;/etc/alertmanager/template/*.tmpl&#x27;                  # 消息模板的位置</span><br><span class="line"></span><br><span class="line">route:</span><br><span class="line">  group_by: [&#x27;alertname&#x27;]</span><br><span class="line">  group_wait: 25s</span><br><span class="line">  group_interval: 30s</span><br><span class="line">  repeat_interval: 1m</span><br><span class="line">  receiver: &#x27;ops&#x27;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="built_in">continue</span>: <span class="literal">false</span></span></span><br><span class="line">  routes:</span><br><span class="line">  - match:</span><br><span class="line">      severity: critical</span><br><span class="line">    receiver: &#x27;dev&#x27;</span><br><span class="line">    # continue: truea</span><br><span class="line">  - match:</span><br><span class="line">      severity: warning</span><br><span class="line">    receiver: &#x27;wechat&#x27;</span><br><span class="line">  - match_re:</span><br><span class="line">      severity: ^(warning|critical)$</span><br><span class="line">    receiver: &#x27;dingtalk&#x27;</span><br><span class="line">    </span><br><span class="line">receivers:</span><br><span class="line">- name: &#x27;ops&#x27;</span><br><span class="line">  email_configs:</span><br><span class="line">  - to: &#x27;2564395767@qq.com&#x27;</span><br><span class="line">    send_resolved: true</span><br><span class="line">- name: &#x27;dev&#x27;</span><br><span class="line">  email_configs:</span><br><span class="line">  - to: &#x27;2318099451@qq.com&#x27;</span><br><span class="line">    send_resolved: true</span><br><span class="line">- name: &#x27;test&#x27;</span><br><span class="line">  email_configs:</span><br><span class="line">  - to: &#x27;zhurongsen_admin@126.com&#x27;</span><br><span class="line">    send_resolved: true</span><br><span class="line">- name: &#x27;dingtalk&#x27;</span><br><span class="line">  webhook_configs:</span><br><span class="line">  - url: http://192.168.56.142:8060/dingtalk/webhook1/send</span><br><span class="line">    send_resolved: true</span><br><span class="line">- name: &#x27;wechat&#x27;</span><br><span class="line">  wechat_configs:</span><br><span class="line">  - send_resolved: true</span><br><span class="line">    to_user: &#x27;@all&#x27;    # 所有用户</span><br><span class="line">    message: &#x27;&#123;&#123; template &quot;wechat.default.message&quot; . &#125;&#125;&#x27;</span><br><span class="line">    agent_id: &#x27;1000002&#x27;                                           # 应用的 AgentId</span><br><span class="line">    api_secret: &#x27;EKmMR_DieISGXZDallbdnFb1OGaV2kADrrjN_UCj56Y&#x27;     # 应用的 Secret</span><br><span class="line"></span><br><span class="line">inhibit_rules:</span><br><span class="line">  - source_match:</span><br><span class="line">      severity: &#x27;critical&#x27;</span><br><span class="line">    target_match:</span><br><span class="line">      severity: &#x27;warning&#x27;</span><br><span class="line">    equal: [&#x27;alertname&#x27;, &#x27;dev&#x27;, &#x27;instance&#x27;]</span><br></pre></td></tr></table></figure><p>4、重启 Alertmanager</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart alertmanager</span><br></pre></td></tr></table></figure><p><mark>我这里的企业微信无法完成认证（企业认证），先暂时搁置。</mark>其实完全可以用机器人来实现。</p><h4 id="3-3-2-机器人告警"><a href="#3-3-2-机器人告警" class="headerlink" title="3.3.2 机器人告警"></a>3.3.2 机器人告警</h4><h5 id="3-3-2-1-添加机企业微信器人"><a href="#3-3-2-1-添加机企业微信器人" class="headerlink" title="3.3.2.1 添加机企业微信器人"></a>3.3.2.1 添加机企业微信器人</h5><p>1、登录企业微信管理后台启用机器人</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221017163651760.png" alt="image-20221017163651760"></p><p>2、启用机器人</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221017163732481.png" alt="image-20221017163732481"></p><p>3、在客户端对应的群聊中添加机器人</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221017153756504.png" alt="image-20221017153756504"></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221017153928431.png" alt="image-20221017153928431"></p><p>4、复制生成的 webhook 地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=6bce5460-be7e-4f33-8de9-8b5f0b1c9b9a</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221017154037011.png" alt="image-20221017154037011"></p><p>至此机器人添加完成！</p><h5 id="3-3-2-2-安装企业微信报警插件"><a href="#3-3-2-2-安装企业微信报警插件" class="headerlink" title="3.3.2.2 安装企业微信报警插件"></a>3.3.2.2 安装企业微信报警插件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name wechat \</span><br><span class="line">  --restart always \</span><br><span class="line">  -p 8880:80 \</span><br><span class="line">  guyongquan/webhook-adapter:latest \</span><br><span class="line">  --adapter=/app/prometheusalert/wx.js=/wx=&lt;你的webhook地址&gt;</span><br></pre></td></tr></table></figure><h5 id="3-3-2-3-Alertmanager-配置"><a href="#3-3-2-3-Alertmanager-配置" class="headerlink" title="3.3.2.3 Alertmanager 配置"></a>3.3.2.3 Alertmanager 配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">global:</span><br><span class="line">  resolve_timeout: 5m</span><br><span class="line">route:</span><br><span class="line">  group_wait: 0s</span><br><span class="line">  group_interval: 5s</span><br><span class="line">  repeat_interval: 1m</span><br><span class="line">  group_by: [&#x27;instance&#x27;]</span><br><span class="line">  receiver: &#x27;web.hook.prometheusalert&#x27;</span><br><span class="line">...</span><br><span class="line">- name: &#x27;web.hook.prometheusalert&#x27;</span><br><span class="line">  webhook_configs:</span><br><span class="line">  - url: &#x27;http://192.168.56.142:8880/adapter/wx&#x27;</span><br><span class="line">    send_resolved: true</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221017155618326.png" alt="image-20221017155618326"></p><h5 id="3-3-2-4-机器人告警验证"><a href="#3-3-2-4-机器人告警验证" class="headerlink" title="3.3.2.4 机器人告警验证"></a>3.3.2.4 机器人告警验证</h5><p>1、触发告警</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221017161205328.png" alt="image-20221017161205328"></p><p>2、解除告警</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221017161311414.png" alt="image-20221017161311414"></p><h3 id="3-4-Grafana-模板导入"><a href="#3-4-Grafana-模板导入" class="headerlink" title="3.4 Grafana 模板导入"></a>3.4 Grafana 模板导入</h3><blockquote><p>官方参考模板：<a href="https://grafana.com/grafana/dashboards/">https://grafana.com/grafana/dashboards/</a></p></blockquote><p>1、添加数据源为 Prometheus</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221005203521799.png" alt="image-20221005203521799"></p><p>2、导入模板</p><blockquote><p>我此处的模板是官方模板：11074</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221005203718190.png" alt="image-20221005203718190"></p><p>3、数据展示</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221005203029392.png" alt="image-20221005203029392"></p><p>&#x3D;&#x3D;该模板展示了 node 节点的基本情况，在大多数情况下已经够用了，当然你也可以根据自己公司的实际情况进行自定义配置。&#x3D;&#x3D;</p><h3 id="3-5-容器监控"><a href="#3-5-容器监控" class="headerlink" title="3.5 容器监控"></a>3.5 容器监控</h3><p>为了解决 <code>docker stats</code> 的问题(存储、展示)，谷歌开源的 <code>cadvisor</code> 诞生了，&#96;&#96;cadvisor<code>不仅可以搜集一台机器上所有运行的容器信息，还提供基础查询界面和</code>http<code>接口，方便其他组件如</code>Prometheus<code>进行数据抓取，或者</code>cadvisor + influxdb + grafna&#96; 搭配使用。</p><h4 id="3-5-1-Cadvisor-部署"><a href="#3-5-1-Cadvisor-部署" class="headerlink" title="3.5.1 Cadvisor 部署"></a>3.5.1 Cadvisor 部署</h4><p>1、pull 镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull google/cadvisor:latest</span><br></pre></td></tr></table></figure><p>2、启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  -itd -u root \</span><br><span class="line">  --privileged=true \</span><br><span class="line">  --detach=true \</span><br><span class="line">  --name=cadvisor \</span><br><span class="line">  --restart always \</span><br><span class="line">  -v /:/rootfs:ro \</span><br><span class="line">  -v /var/run:/var/run:rw \</span><br><span class="line">  -v /sys:/sys:ro \</span><br><span class="line">  -v /var/lib/docker/:/var/lib/docker:ro \</span><br><span class="line">  -v /dev/disk/:/dev/disk:ro \</span><br><span class="line">  -p 8080:8080 \</span><br><span class="line">  google/cadvisor:latest</span><br></pre></td></tr></table></figure><p>3、验证</p><blockquote><p><a href="http://192.168.56.142:8080/containers/">http://192.168.56.142:8080/containers/</a></p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221005210013965.png" alt="image-20221005210013965"></p><p>4、监控指标展示（TXT）</p><blockquote><p><a href="http://192.168.56.142:8080/metrics">http://192.168.56.142:8080/metrics</a></p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221005215249368.png" alt="image-20221005215249368"></p><h4 id="3-5-2-Prometheus-配置"><a href="#3-5-2-Prometheus-配置" class="headerlink" title="3.5.2 Prometheus 配置"></a>3.5.2 Prometheus 配置</h4><p>通过监控指标展示（TXT），类似于 <code>noed_export</code> 我们可以在 Prometheus 进行配置。</p><p>1、配置JOB</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">my global config</span></span><br><span class="line">global:</span><br><span class="line">  scrape_interval:     15s</span><br><span class="line">  evaluation_interval: 15s</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">scrape_timeout is <span class="built_in">set</span> to the global default (10s).</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Alertmanager configuration</span></span><br><span class="line">alerting:</span><br><span class="line">  alertmanagers:</span><br><span class="line">  - static_configs:</span><br><span class="line">    - targets:</span><br><span class="line">      - 192.168.56.142:9093</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Load rules once and periodically evaluate them according to the global <span class="string">&#x27;evaluation_interval&#x27;</span>.</span></span><br><span class="line">rule_files:</span><br><span class="line">  - &#x27;/etc/prometheus/rules/*.yml&#x27;</span><br><span class="line"></span><br><span class="line">scrape_configs:</span><br><span class="line">  - job_name: &#x27;prometheus&#x27;</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&#x27;192.168.56.141:9090&#x27;]</span><br><span class="line">  - job_name: &#x27;Alertmanager&#x27;</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&#x27;192.168.56.142:9093&#x27;]</span><br><span class="line">  - job_name: &#x27;Linux节点监控&#x27;</span><br><span class="line">    file_sd_configs:</span><br><span class="line">      - files:</span><br><span class="line">        - /data/prometheus/target/nodes/*.json</span><br><span class="line">        refresh_interval: 1m</span><br><span class="line">  - job_name: &#x27;容器监控&#x27;</span><br><span class="line">    file_sd_configs:</span><br><span class="line">      - files:</span><br><span class="line">        - /data/prometheus/target/container/*.json</span><br><span class="line">        refresh_interval: 1m</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、添加主机发现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /home/data/prometheus/data/target/container/Cadvisor.json</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">        &quot;targets&quot;: [&quot;192.168.56.141:8080&quot;],</span><br><span class="line">        &quot;labels&quot;: &#123;</span><br><span class="line">                &quot;instance&quot;: &quot;192.168.56.141&quot;,</span><br><span class="line">                &quot;Hostname&quot;: &quot;prometheus&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;container&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">        &quot;targets&quot;: [&quot;192.168.56.142:8080&quot;],</span><br><span class="line">        &quot;labels&quot;: &#123;</span><br><span class="line">                &quot;instance&quot;: &quot;192.168.56.142&quot;,</span><br><span class="line">                &quot;Hostname&quot;: &quot;grafana&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;container&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">        &quot;targets&quot;: [&quot;192.168.56.180:8080&quot;],</span><br><span class="line">        &quot;labels&quot;: &#123;</span><br><span class="line">                &quot;instance&quot;: &quot;192.168.56.180&quot;,</span><br><span class="line">                &quot;Hostname&quot;: &quot;habor-nexus&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;container&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221012145115351.png" alt="image-20221012145115351"></p><p>3、验证</p><blockquote><p>Prometheus 服务上查看健康状态</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221012144650621.png" alt="image-20221012144650621"></p><p>4、容器的 grafana 模板</p><blockquote><p>导入模板ID：14282</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221012145310021.png" alt="image-20221012145310021"></p><p>&#x3D;&#x3D;Prometheus 数据持久化存储方案会在后续介绍，本次就简单介绍到这里，欢迎大家进行补充。&#x3D;&#x3D;</p><h2 id="四、FAQ"><a href="#四、FAQ" class="headerlink" title="四、FAQ"></a>四、FAQ</h2><h3 id="4-1-钉钉配置"><a href="#4-1-钉钉配置" class="headerlink" title="4.1 钉钉配置"></a>4.1 钉钉配置</h3><p>1、错误描述</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">level=error ts=2022-10-04T14:08:53.510Z caller=dingtalk.go:103 component=web target=webhook1 msg=&quot;Failed to send notification to DingTalk&quot; respCode=310000 respMsg=description:关键词不匹配;solution:请联系群管理员查看此机器人的关键词，并在发送的信息中包含此关键词;</span><br></pre></td></tr></table></figure><p>2、解决方案</p><p>在钉钉机器人配置处加签，如下图：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221004222615046.png" alt="image-20221004222615046"></p><h3 id="4-2-其他"><a href="#4-2-其他" class="headerlink" title="4.2 其他"></a>4.2 其他</h3><p>暂时没遇到其他问题，欢迎大家进行补充。</p>]]></content>
      
      
      <categories>
          
          <category> 监控系统 </category>
          
          <category> Prometheus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Prometheus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prometheus - SSL 证书过期监控</title>
      <link href="/posts/articles/2f967c8.html"/>
      <url>/posts/articles/2f967c8.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230328101307841.png" alt="image-20230328101307841"></p><hr><h2 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h2><ol><li><p>数据采集：</p><blockquote><p>Exporter：blackbox_exporter</p><p>Version：0.22.0</p><p>Exporter 下载：<a href="https://prometheus.io/download/#blackbox_exporter">https://prometheus.io/download/#blackbox_exporter</a></p></blockquote></li><li><p>数据存储：</p><blockquote><p>Aplica：Prometheus</p><p>Version：2.37.0</p></blockquote></li><li><p>数据展示：</p><blockquote><p>Aplica：Grafana</p><p>Version：9.0.3</p><p>Dashboards：<a href="https://grafana.com/grafana/dashboards/">https://grafana.com/grafana/dashboards/</a></p><p>Dashboard ID（SSL 证书监控）：13230</p><p>Dashboard ID（HTTP 状态监控）：13659</p><p>Dashboard ID（SSL TCP HTTP 监控）：9965</p></blockquote></li></ol><h2 id="二、部署-Exporter"><a href="#二、部署-Exporter" class="headerlink" title="二、部署 Exporter"></a>二、部署 Exporter</h2><h3 id="2-1-配置-blackbox-exporter"><a href="#2-1-配置-blackbox-exporter" class="headerlink" title="2.1 配置 blackbox_exporter"></a>2.1 配置 blackbox_exporter</h3><p>1、下载 blackbox_exporter 并上传至服务器</p><p>2、解压 blackbox_exporter</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar xzf blackbox_exporter-0.22.0.linux-amd64.tar.gz -C /home/data/prometheus/exporters/</span><br><span class="line"><span class="built_in">cd</span> /home/data/prometheus/exporters/</span><br><span class="line"><span class="built_in">mv</span> blackbox_exporter-0.22.0.linux-amd64 blackbox_exporter</span><br></pre></td></tr></table></figure><p>3、修改配置文件</p><blockquote><p>blackbox_exporter 以模块的方式工作，如果你仅仅是获取 SSL 证书过期时间，那部署在任意节点即可。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/data/prometheus/exporters/blackbox_exporter</span><br><span class="line">vim blackbox.yml  <span class="comment"># 启用http_2xx模块</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">modules:</span><br><span class="line">  http_2xx:</span><br><span class="line">    prober: http</span><br><span class="line">    <span class="built_in">timeout</span>: 30s</span><br><span class="line">    http:</span><br><span class="line">      valid_http_versions: [<span class="string">&quot;HTTP/1.1&quot;</span>, <span class="string">&quot;HTTP/2&quot;</span>]</span><br><span class="line">      valid_status_codes: [200]</span><br><span class="line">      method: GET</span><br><span class="line">      preferred_ip_protocol: <span class="string">&quot;ip4&quot;</span></span><br></pre></td></tr></table></figure><p>4、配置 systemd 管理</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/blackbox_exporter.service</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=blackbox_exporter</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=prometheus</span><br><span class="line">Group=prometheus</span><br><span class="line">WorkingDirectory=/home/data/prometheus/exporters/blackbox_exporter</span><br><span class="line">ExecStart=/home/data/prometheus/exporters/blackbox_exporter/blackbox_exporter</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>5、启动 blackbox_exporter</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start blackbox_exporter.service</span><br><span class="line">systemctl <span class="built_in">enable</span> blackbox_exporter.service</span><br><span class="line">systemctl status blackbox_exporter.service</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230328102210764.png" alt="image-20230328102210764"></p><h3 id="2-2-配置-Prometheus"><a href="#2-2-配置-Prometheus" class="headerlink" title="2.2 配置 Prometheus"></a>2.2 配置 Prometheus</h3><p>1、修改配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /home/data/prometheus/etc/prometheus.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加JOB</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">...</span><br><span class="line">  - job_name: <span class="string">&#x27;blackbox_http_2xx&#x27;</span></span><br><span class="line">    metrics_path: /probe</span><br><span class="line">    params:</span><br><span class="line">      module: [http_2xx]</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets:</span><br><span class="line">        - https://blog.rabcnops.cn</span><br><span class="line">        - https://www.baidu.com</span><br><span class="line">        ...</span><br><span class="line">    relabel_configs:</span><br><span class="line">      - source_labels: [__address__]</span><br><span class="line">        target_label: __param_target</span><br><span class="line">      - source_labels: [__param_target]</span><br><span class="line">        target_label: instance</span><br><span class="line">      - target_label: __address__</span><br><span class="line">        replacement: 192.168.56.141:9115</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>2、重启（或热加载）Prometheus</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart prometheus</span><br></pre></td></tr></table></figure><h3 id="2-3-Grafana-监控面板"><a href="#2-3-Grafana-监控面板" class="headerlink" title="2.3 Grafana 监控面板"></a>2.3 Grafana 监控面板</h3><p>1、导入模板（在文章开头已经给出模板 ID）</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230328104918498.png" alt="image-20230328104918498"></p><p>2、查看最终效果</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230328101307841.png" alt="image-20230328101307841"></p><p><mark>SSL 证书过期告警部分后面在进行配置！</mark></p>]]></content>
      
      
      <categories>
          
          <category> 监控系统 </category>
          
          <category> Prometheus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Prometheus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 容器文件（数据）共享</title>
      <link href="/posts/articles/7dd3df1e.html"/>
      <url>/posts/articles/7dd3df1e.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220908134844265.png" alt="image-20220908134844265"></p><p><font color=Brown><strong>Author</strong>：rab</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有这样一个场景，当我们的服务都是通过容器化方式时，不仅要考虑数据持久化的问题，在 web 集群的时候也要考虑到数据共享的问题，如我需要负载均衡多个 web 服务（这些 web 主要是作为前端展示），且这些 web 服务的功能完全一致，那这时就可用到我们的文件共享技术了。而文件共享又分为两种情况：<code>容器与 Host 共享</code>、<code>容器间数据共享</code>，接下来分别介绍以下这两种文件（数据）共享方式。</p><h2 id="一、共享"><a href="#一、共享" class="headerlink" title="一、共享"></a>一、共享</h2><h3 id="1-1-容器与-Host-共享"><a href="#1-1-容器与-Host-共享" class="headerlink" title="1.1 容器与 Host 共享"></a>1.1 容器与 Host 共享</h3><p>对于容器与 Host 共享间进行数据共享也是比较常用的，比如，当我们运行某个容器的时候，我们需要获取到该容器的配置文件（实现动态配置和持久化），我们一般的做法就是去该服务的官网去下载配置文件或 copy 容器中的配置文件到 Host（其实这就实现了文档的共享了）。</p><p>以 Nginx 为例，看看容器的文件如何共享到 Host 上。</p><p>1、先运行一个 nginx 容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name=my-web nginx:1.20.2</span><br></pre></td></tr></table></figure><p>2、将容器数据复制到 Host</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker cp my-web:/etc/nginx/nginx.conf .</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这样就将nginx容器的配置文件复制到Host的当前目录下</span></span><br></pre></td></tr></table></figure><p>3、将 Host 的数据复制到容器内部</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在Host上创建一个测试文件</span></span><br><span class="line">touch web.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将创建的文件copy到容器内部</span></span><br><span class="line">docker cp web.conf my-web:/etc/nginx/conf.d/</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;这样就实现了容器与 Host 间的数据共享了，准确说不叫共享，应该叫做容器和 Host 之间可以互相传输文件或实现 Docker 容器的持久化存储。&#x3D;&#x3D;</p><h3 id="1-2-容器间共享"><a href="#1-2-容器间共享" class="headerlink" title="1.2 容器间共享"></a>1.2 容器间共享</h3><h4 id="1-2-1-bind-mount"><a href="#1-2-1-bind-mount" class="headerlink" title="1.2.1 bind mount"></a>1.2.1 bind mount</h4><p>这种共享方式是多个容器共享 Host 上的数据，即将共享数据放在 bind mount 中，然后将其 mount 到多个容器中，我们以 nginx 容器为例进行演示。</p><p>1、创建共享数据（目录或文件）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/web/conf.d</span><br><span class="line">touch /data/web/conf.d/web.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我就以一个目录为共享数据</span></span><br></pre></td></tr></table></figure><p>2、运行 nginx 容器（并将共享数据 mount 到容器中）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name=web-1 -v /data/web/conf.d:/etc/nginx/conf.d nginx:1.20.2</span><br><span class="line">docker run -itd --name=web-2 -v /data/web/conf.d:/etc/nginx/conf.d nginx:1.20.2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行两个容器，且这两个容器共享同一个Host数据（目录或文件）</span></span><br></pre></td></tr></table></figure><p>3、验证数据是否 mount 到容器中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@shop ~]# docker exec -it web-1 bash</span><br><span class="line">root@5d3c487a409a:/# ls /etc/nginx/conf.d/</span><br><span class="line">web.conf</span><br><span class="line">root@5d3c487a409a:/# exit</span><br><span class="line">exit</span><br><span class="line">[root@shop ~]# docker exec -it web-2 bash</span><br><span class="line">root@fdbb7e98d971:/# ls /etc/nginx/conf.d/</span><br><span class="line">web.conf</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220908115951256.png" alt="image-20220908115951256"></p><p>&#x3D;&#x3D;这样就实现了多个容器共享同个数据。&#x3D;&#x3D;</p><h4 id="1-2-2-volume-container"><a href="#1-2-2-volume-container" class="headerlink" title="1.2.2 volume container"></a>1.2.2 volume container</h4><p>上面是多个容器共享 Host 里面的数据（目录或文件），而这个方式共享则是多个容器共享同个容器中的数据卷（该数据卷类型可以是 bind mount，也可以是 managed volume）。</p><p>1、创建共享容器的数据卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /root/conf.d</span><br><span class="line">touch /root/conf.d/web.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我就以一个目录为共享数据</span></span><br></pre></td></tr></table></figure><p>2、运行共享容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker create --name=share_data -v /root/conf.d:/etc/nginx/conf.d busybox</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意：提供数据共享的这个容器是可以不需要运行的，因此只需创建即可</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220908124543366.png" alt="image-20220908124543366"></p><p>3、其他容器共享刚创建的容器数据卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name=web-1 --volumes-from share_data nginx:1.20.2</span><br><span class="line">docker run -itd --name=web-2 --volumes-from share_data nginx:1.20.2</span><br></pre></td></tr></table></figure><p>4、验证数据是否被共享</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@shop ~]# docker exec -it web-1 bash</span><br><span class="line">root@5daf7ba565cd:/# ls /etc/nginx/conf.d/</span><br><span class="line">web.conf</span><br><span class="line">root@5daf7ba565cd:/# exit</span><br><span class="line">exit</span><br><span class="line">[root@shop ~]# docker exec -it web-2 bash</span><br><span class="line">root@5510e1b6b4cb:/# ls /etc/nginx/conf.d/</span><br><span class="line">web.conf</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220908124816867.png" alt="image-20220908124816867"></p><p>&#x3D;&#x3D;这有什么好处？其实对于多个容器共享数据（或数据持久化时），在运行容器时不需要指定 Host 的共享目录，而只需指定提供共享数据的容器的容器名即可，这样的话更便于管理。&#x3D;&#x3D;</p><p>还有这样一种场景，如果我需要做容器应用数据迁移（如将容器 web-1 从主机 A 迁移至主机 B），对于以上的数据共享策略来说，还没真正实现数据随容器的迁移而迁移，于是我们可以将数据直接持久化到某个镜像中，这样在做数据迁移的时候就会随镜像的迁移而迁移，而这类方法只适用于数据存储较小或数据改动不是很大容器服务（如配置文件、静态文件等）。要实现这样的功能，就需要我们制作自定义镜像（如 Dockerfile），将数据 copy 到镜像中。</p><p>5、创建 Dockerfile </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /root/dockerfile &amp;&amp; cd /root/dockerfile</span><br><span class="line">touch web.conf</span><br><span class="line">vim Dockerfile</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220908131305346.png" alt="image-20220908131305346"></p><p>6、构建镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t share:v1 .</span><br></pre></td></tr></table></figure><p>7、创建共享容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create --name=share_data-1 share:v1</span><br></pre></td></tr></table></figure><p>8、运行 web 容器并进行数据共享</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name=web-1 --volumes-from share_data-1 nginx:1.20.2</span><br><span class="line">docker run -itd --name=web-2 --volumes-from share_data-1 nginx:1.20.2</span><br></pre></td></tr></table></figure><p>9、验证数据是否被共享</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@shop dockerfile]# docker exec -it web-1 bash</span><br><span class="line">root@34a7c0d48078:/# ls /etc/nginx/conf.d/</span><br><span class="line">web.conf</span><br><span class="line">root@34a7c0d48078:/# exit</span><br><span class="line">exit</span><br><span class="line">[root@shop dockerfile]# docker exec -it web-2 bash</span><br><span class="line">root@d3a5bcf6b10b:/# ls /etc/nginx/conf.d/</span><br><span class="line">web.conf</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220908131129793.png" alt="image-20220908131129793"></p><p>&#x3D;&#x3D;运行的 web 容器能正确读取 共享容器 volume 中数据，我们可看到，创建的共享容器不依赖于 Host 提供的数据，真正实现了 docker 容器服务的迁移即应用，只需要迁移目标提供 docker 环境即可。&#x3D;&#x3D;</p><h2 id="二、小结"><a href="#二、小结" class="headerlink" title="二、小结"></a>二、小结</h2><p>Docker 容器共享可实现容器与 Host 间共享、容器与容器间共享，其中共享 Host 数据的情况用的比较多，容器间共享也有在使用，如一些数据变动较小的容器服务，就可以采用容器间数据共享。</p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 容器间通信</title>
      <link href="/posts/articles/ffa06faa.html"/>
      <url>/posts/articles/ffa06faa.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/docker.png" alt="docker"></p><hr><p>这里分两个部分来讲解，分别为：<code>容器间通信</code>和<code>外部（宿主机外的网络）与容器的通信</code>。</p><h2 id="一、容器间通信"><a href="#一、容器间通信" class="headerlink" title="一、容器间通信"></a>一、容器间通信</h2><h3 id="1-1-IP"><a href="#1-1-IP" class="headerlink" title="1.1 IP"></a>1.1 IP</h3><p>通过 IP 的形式来通信。试想一下，两个容器之间是相互隔离的，因此是无法互相 ping 通的，那如果运行的这两个容器使用的是同一个<code>自定义的网络模式</code>，那是否可以连接呢？答案是可以的。我们来实际测试一下。</p><p>前提条件：</p><ul><li>自定义网络名：net_b</li><li>自定义网络IP段：192.168.4.0&#x2F;244</li></ul><p><strong>创建 A 容器：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@qcloud ~]# docker run -it --name test_a --network=net_b busybox</span><br><span class="line">/ # ifconfig </span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:C0:A8:04:05  </span><br><span class="line">          inet addr:192.168.4.5  Bcast:192.168.4.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:9 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:726 (726.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br></pre></td></tr></table></figure><p><strong>创建 B 容器：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@qcloud ~]# docker run -it --name test_b --network=net_b busybox</span><br><span class="line">/ # ifconfig </span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:C0:A8:04:06  </span><br><span class="line">          inet addr:192.168.4.6  Bcast:192.168.4.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:6 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:516 (516.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br></pre></td></tr></table></figure><p>B 容器 ping A 容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/ # ping 192.168.4.5</span><br><span class="line">PING 192.168.4.5 (192.168.4.5): 56 data bytes</span><br><span class="line">64 bytes from 192.168.4.5: seq=0 ttl=64 time=0.117 ms</span><br><span class="line">64 bytes from 192.168.4.5: seq=1 ttl=64 time=0.126 ms</span><br><span class="line">64 bytes from 192.168.4.5: seq=2 ttl=64 time=0.125 ms</span><br></pre></td></tr></table></figure><p>A 容器 ping B 容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/ # ping 192.168.4.6</span><br><span class="line">PING 192.168.4.6 (192.168.4.6): 56 data bytes</span><br><span class="line">64 bytes from 192.168.4.6: seq=0 ttl=64 time=0.177 ms</span><br><span class="line">64 bytes from 192.168.4.6: seq=1 ttl=64 time=0.132 ms</span><br><span class="line">64 bytes from 192.168.4.6: seq=2 ttl=64 time=0.116 ms</span><br></pre></td></tr></table></figure><p>从结果看，A、B 容器可互相 通信。</p><p><strong>创建 C 容器：</strong></p><p>如果该容器为<code>普通 Bridge 网络模式</code>的容器（如：Nginx），那么容器 A 或容器 B 是否能访问 Nginx 容器呢？<code>答案是不能访问</code>。如何解决不可访问的问题？</p><p>如果 Host 上对每个网络都有一条路由，且 Host 打开了路由转发（net.ipv4.ip_forward &#x3D; 1），那不同网桥上的网络就可互相通信。此时，我在 C 容器上加入一块 A、B 容器的虚拟网卡设备，来实现与 A、B 容器的通信。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@qcloud ~]# docker network connect net_b nginx</span><br></pre></td></tr></table></figure><p>Nginx 容器里没有查看 IP 地址的命令，可通过 <code>docker inspect nginx</code> 来查看，如下图，Nginx 容器已经分配了 net_b 网络的一个 IP 地址。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214182720975.png" alt="image-20221214182720975"></p><p>Nginx 容器的 index.html 我已经提前更改为：hello zhurs 111</p><p>A 容器 ping 一下 C 容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/ # ping 192.168.4.4</span><br><span class="line">PING 192.168.4.4 (192.168.4.4): 56 data bytes</span><br><span class="line">64 bytes from 192.168.4.4: seq=0 ttl=64 time=0.214 ms</span><br><span class="line">64 bytes from 192.168.4.4: seq=1 ttl=64 time=0.129 ms</span><br><span class="line">64 bytes from 192.168.4.4: seq=2 ttl=64 time=0.225 ms</span><br></pre></td></tr></table></figure><p>A 容器访问 C 容器的 Nginx 内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/ # wget 192.168.4.4</span><br><span class="line">Connecting to 192.168.4.4 (192.168.4.4:80)</span><br><span class="line">saving to &#x27;index.html&#x27;</span><br><span class="line">index.html           100% |**************************************************************************************************************************|    16  0:00:00 ETA</span><br><span class="line">&#x27;index.html&#x27; saved</span><br><span class="line">/ # cat index.html </span><br><span class="line">hello zhurs 111</span><br></pre></td></tr></table></figure><p>从结果看，A 容器可正常访问 C 容器的资源。</p><p><strong>小结：</strong></p><ul><li>结论1：同一个<code>自定义网络（&quot;Driver&quot;: &quot;bridge&quot;）</code>下的所有容器可互相通信。</li><li>结论2：<code>自定义网络（&quot;Driver&quot;: &quot;bridge&quot;）</code> 想与<code>普通 Bridge 网络模式</code>进行通信，可在双方任意一方加入对方的网络模式即可。</li></ul><h3 id="1-2-Docker-DNS-Server"><a href="#1-2-Docker-DNS-Server" class="headerlink" title="1.2 Docker DNS Server"></a>1.2 Docker DNS Server</h3><p>上面提到网络驱动 Driver 为 bridge 的自定义网络模式下的容器可通过 IP 进行通信，但在实际应用场景中，IP 可能并不稳定（除非你自定义 IP），因此，我们可以通过<code>容器名</code>的方式进行通信。</p><p>创建容器名为 dns1：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@qcloud ~]# docker run -it --network=net_b --name=dns1 busybox</span><br></pre></td></tr></table></figure><p>创建容器名为 dns2：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@qcloud ~]# docker run -it --network=net_b --name=dns2 busybox</span><br><span class="line">/ # ping dns1</span><br><span class="line">PING dns1 (192.168.4.5): 56 data bytes</span><br><span class="line">64 bytes from 192.168.4.5: seq=0 ttl=64 time=0.107 ms</span><br><span class="line">64 bytes from 192.168.4.5: seq=1 ttl=64 time=0.121 ms</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可见，通过域名可正常通信，该通信方式等效于 IP 通信方式，无非就是一个通过 IP 方式，另一个通过容器名的方式。</p><p>但是需要注意，通过容器名通信的前提是：网络模式必须为<code>自定义网络（&quot;Driver&quot;: &quot;bridge&quot;）</code>模式</p><h3 id="1-3-Joined"><a href="#1-3-Joined" class="headerlink" title="1.3 Joined"></a>1.3 Joined</h3><p>这种模式类似 k8s 中 pod 的多容器情况，在 k8s 中，一个 pod 可有一个或多个容器，一般我们多出的那些容器主要起辅助作用，比如一些日志监控等。Docker 的 Joined 通信类型也类似，该模式的作用是：它可使两个或多个容器共享一个网络栈（网卡、配置信息等），因此 Joined 模式下的所有容器可通过 <code>127.0.0.1</code> 直接通信，你可以将他们想象为是一个整体。</p><p><strong>如何实现？</strong></p><blockquote><p>在运行容器时指定要 joined 的目标容器，成功后将共享目标容器的网络栈。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@qcloud ~]# docker run -it --name=join-test --network=container:nginx busybox</span><br><span class="line">/ # ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">388: eth1@if389: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue </span><br><span class="line">    link/ether 02:42:c0:a8:04:04 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.4.4/24 brd 192.168.4.255 scope global eth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">216: eth0@if217: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue </span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>查看 IP 信息，完全共享被 joined 目标容器的网络。</p><h2 id="二、容器与外部通信"><a href="#二、容器与外部通信" class="headerlink" title="二、容器与外部通信"></a>二、容器与外部通信</h2><p>其实这是通过 Host 的 iptables 机制来实现的，如下标红的几个示例，当收到 172.19.0.0&#x2F;16 网段的外出包，就把它交给 MASQUERADE 处理，MASQUERADE 则将外出包的源地址转换为 Host 的地址发送出去，实现了网络的 NAT 转换。这也是容器可以与外部通信的原因。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214182740504.png" alt="image-20221214182740504"></p><p>容器能与外界通信，那外部是如何与容器内部通信呢？其实道理是一样的，也是通过 NAT 技术，在结合端口映射的方式实现外部与 Host 下的容器通信。</p><h3 id="2-1-动态端口映射"><a href="#2-1-动态端口映射" class="headerlink" title="2.1 动态端口映射"></a>2.1 动态端口映射</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@qcloud ~]# docker run -itd --name=httpd -p 80 httpd</span><br><span class="line">[root@qcloud ~]# docker port httpd</span><br><span class="line">80/tcp -&gt; 0.0.0.0:1024</span><br></pre></td></tr></table></figure><p>该方式会随机生成一个动态端口，且是用于浏览器访问的端口号。</p><h3 id="2-2-静态端口映射"><a href="#2-2-静态端口映射" class="headerlink" title="2.2 静态端口映射"></a>2.2 静态端口映射</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@qcloud ~]# docker run -itd --name=httpd-1 -p 8686:80 httpd</span><br><span class="line">[root@qcloud ~]# docker port httpd-1</span><br><span class="line">80/tcp -&gt; 0.0.0.0:8686</span><br></pre></td></tr></table></figure><p>该方式会指定一个静态端口，且是用于浏览器访问的端口号。静态端口映射用的居多。</p><p><strong>小结：</strong></p><p>没映射一个端口，Host 都会启动一个 docker-proxy 进程来处理访问容器的流量。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214182755401.png" alt="image-20221214182755401"></p><hr><p>附件：容器内&#x2F;外通信图解</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/Docker-network.jpg" alt="Docker-network"></p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 环境下 Docker 容器的 PID 变化情况</title>
      <link href="/posts/articles/377c1d95.html"/>
      <url>/posts/articles/377c1d95.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/docker-docs.webp" alt="docker-docs"></p><p>参考1：<a href="https://www.modb.pro/db/100271">https://www.modb.pro/db/100271</a></p><p>参考2：<a href="http://www.asznl.com/post/31">http://www.asznl.com/post/31</a></p><hr><p>有时候你使用 Docker 部署服务，在你的 Linux 系统上你会发现多出来一些进程，那我们如何通过这些进程 ID 来查看是由谁产生的呢？其实很简单，找到它父进程即可。</p><p>首先查看 Docker 服务本身进程 ID：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef |grep dockerd</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221221155349700.png" alt="image-20221221155349700"></p><p>可看到其 Dockerd 服务的子进程 ID 为 31803，父进程 ID 为 1。我们知道，Linux 中有<code>pid 0、pid 1 和 pid 2</code> 三个特殊的进程。</p><ul><li>pid 0：即 <code>“swapper”</code> 进程，是 pid 1 和 pid 2 的父进程；</li><li>pid 1：即 <code>“init”</code> 进程，是用户空间所有进程的父进程；</li><li>pid 2，即 <code>“kthreadd”</code> 进程，是内核空间所有进程的父进程。</li></ul><p>继续查看 <code>31803</code> 的进程信息：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef |grep 31803</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221221155615309.png" alt="image-20221221155615309"></p><p>可以看到作为 <code>31803</code> 的父进程产生了很多子进程，其中就包括所有已经创建的容器进程 ID，可看到我们 Jenkins 容器监听的两个端口进程也是来源于 <code>31803</code>，如下图所示：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221221152518700.png" alt="image-20221221152518700"></p><p>这里就出现一个问题，不同容器之间是相互隔离的，实际就是对进程的隔离，那这些容器运行的进程又在哪找呢？</p><p>我们先看看 <code>containerd-shim</code> </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef |grep containerd-shim</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221221161405255.png" alt="image-20221221161405255"></p><p>继续看看 949 的 PPID 是多少？</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221221174525177.png" alt="image-20221221174525177"></p><p>这个时候，我们可以来看看 Docker 的基本架构图。从 Docker 1.11 版本开始，Docker 容器运行就不是简单通过 Docker Daemon 来启动了，而是通过集成 containerd、runc 等多个组件来完成的。虽然 Docker Daemon 守护进程模块在不停的重构，但是基本功能和定位没有太大的变化，一直都是 CS 架构，守护进程负责和 Docker Client 端交互，并管理 Docker 镜像和容器。现在的架构中组件 containerd 就会负责集群节点上容器的生命周期管理，并向上为 Docker Daemon 提供 gRPC 接口。</p><p>参考图1：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221221161634949.png" alt="image-20221221161634949"></p><p>参考图2：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221221163546886.png" alt="image-20221221163546886"></p><p>可以根据以下概念截图进程树查看：</p><ul><li><code>docker CLI</code> 命令行工具，是给用户和 docker daemon 建立通信的客户端</li><li><code>dockerd</code>: 是 docker 架构中一个常驻在后台的系统进程，称为 docker daemon，dockerd 实际调用的还是 containerd 的 api 接口。有了 containerd 之后，dockerd 可以独立升级，以此避免之前 dockerd 升级会导致所有容器不可用的问题。</li><li><code>containerd</code> 是 dockerd 和 runc 之间的一个中间交流组件，docker 对容器的管理和操作基本都是通过 containerd 完成的。containerd 的主要功能有：容器生命周期管理、日志管理、镜像管理、存储管理、容器网络接口及网络管理</li><li><code>containerd-shim</code> 是一个真实运行容器的载体，每启动一个容器都会起一个新的containerd-shim的一个进程， 它直接通过指定的三个参数：容器id，boundle目录（containerd 对应某个容器生成的目录，一般位于：&#x2F;var&#x2F;run&#x2F;docker&#x2F;libcontainerd&#x2F;containerID，其中包括了容器配置和标准输入、标准输出、标准错误三个管道文件），运行时二进制（默认为runC）来调用 runc 的 api 创建一个容器，上面的 docker 进程图中可以直观的显示。其主要作用是：<ul><li>它允许容器运行时(即 runC)在启动容器之后退出，简单说就是不必为每个容器一直运行一个容器运行时(runC)；</li><li>即使在 containerd 和 dockerd 都挂掉的情况下，容器的标准 IO 和其它的文件描述符也都是可用的；</li><li>向 containerd 报告容器的退出状态；</li><li>有了它就可以在不中断容器运行的情况下升级或重启 dockerd，对于生产环境来说意义重大。</li><li><code>runC</code> 是 Docker 公司按照 OCI 标准规范编写的一个操作容器的命令行工具，其前身是 libcontainer 项目演化而来，runC 实际上就是 libcontainer 配上了一个轻型的客户端，是一个命令行工具端，根据 OCI（开放容器组织）的标准来创建和运行容器，实现了容器启停、资源隔离等功能。</li></ul></li><li><code>docker-proxy</code>: 用来做端口映射的，其底层是默认使用iptables实现。</li></ul><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221221181247275.png" alt="image-20221221181247275"></p><p>以上是 docker 19 的架构，但是到了 docker 20 时，结构就有变化了，貌似不再经过 containerd 了。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221221173702572.png" alt="image-20221221173702572"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree -p</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221221180909732.png" alt="image-20221221180909732"></p><p>和上图对比可看到少了 <code>containerd</code></p><p>通过 <code>docker inspect</code> 查看容器本身的 PID，如下图：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect &lt;容器名&gt;</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221221181913969.png" alt="image-20221221181913969"></p><p>通过该 PID 就可以查看容器在 Host 中产生的 PID</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221221182051790.png" alt="image-20221221182051790"></p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Swarm NFS 数据持久化存储</title>
      <link href="/posts/articles/2499c9dc.html"/>
      <url>/posts/articles/2499c9dc.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/mydockerswarm.png" alt="mydockerswarm"></p><hr><h2 id="一、Swarm-集群部署"><a href="#一、Swarm-集群部署" class="headerlink" title="一、Swarm 集群部署"></a>一、Swarm 集群部署</h2><p>可参考我前面的博客<a href="https://blog.csdn.net/IT_ZRS/article/details/126106608?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167341759716800222849511%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=167341759716800222849511&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-126106608-null-null.blog_rank_default&utm_term=swarm&spm=1018.2226.3001.4450">《基于 Linux 的 Docker Swarm 集群部署及应用》</a>。</p><p><strong>本次实验：</strong></p><ul><li><strong>master</strong>：192.168.56.142</li><li><strong>work1</strong>：192.168.56.132</li><li><strong>work2</strong>：192.168.56.180</li></ul><h2 id="二、NFS-服务部署"><a href="#二、NFS-服务部署" class="headerlink" title="二、NFS 服务部署"></a>二、NFS 服务部署</h2><p>可参考我前面的博客<a href="https://blog.csdn.net/IT_ZRS/article/details/109248320?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167341767316800182198924%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=167341767316800182198924&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-109248320-null-null.blog_rank_default&utm_term=NFS&spm=1018.2226.3001.4450">《构建NFS-FTP文件共享存储》</a>。</p><p><strong>本次实验：</strong></p><ul><li><strong>NFS IP</strong>：192.168.56.141</li><li><strong>Shared Dir</strong>：&#x2F;data&#x2F;sharedir</li></ul><h2 id="三、Swarm-使用-NFS"><a href="#三、Swarm-使用-NFS" class="headerlink" title="三、Swarm 使用 NFS"></a>三、Swarm 使用 NFS</h2><blockquote><p>参考1：<a href="https://blog.dahanne.net/2017/11/20/docker-swarm-and-nfs-volumes/">https://blog.dahanne.net/2017/11/20/docker-swarm-and-nfs-volumes/</a></p><p>参考2：<a href="https://blog.csdn.net/lms99251/article/details/108702547">https://blog.csdn.net/lms99251/article/details/108702547</a></p><p>参考3：<a href="https://www.jianshu.com/p/38e1c81af9bd">https://www.jianshu.com/p/38e1c81af9bd</a></p></blockquote><h3 id="3-1-通过-Volume"><a href="#3-1-通过-Volume" class="headerlink" title="3.1 通过 Volume"></a>3.1 通过 Volume</h3><h4 id="3-1-1-创建-Volume"><a href="#3-1-1-创建-Volume" class="headerlink" title="3.1.1 创建 Volume"></a>3.1.1 创建 Volume</h4><p><strong>1、创建 Docker Volume</strong></p><blockquote><p>每个 swarm 节点均创建相同名称的 Docker Volume（名称为 nfsdata）</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker volume create --driver <span class="built_in">local</span> \</span><br><span class="line">  --opt <span class="built_in">type</span>=nfs \</span><br><span class="line">  --opt o=addr=192.168.56.141,rw \</span><br><span class="line">  --opt device=:/data/sharedir \</span><br><span class="line">  nfsdata</span><br></pre></td></tr></table></figure><p><strong>2、查看 Volume 是否创建成功</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># swarm集群节点依次进行验证</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230111144019356.png" alt="image-20230111144019356"></p><p><strong>3、查看 Volume 详情</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect nfsdata</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230111144430328.png" alt="image-20230111144430328"></p><blockquote><p>其中：<code>Mountpoint</code> 为 Host 挂载点，<code>Options</code> 为 NFS 服务共享目录信息。</p></blockquote><h4 id="3-1-2-使用-Volume"><a href="#3-1-2-使用-Volume" class="headerlink" title="3.1.2 使用 Volume"></a>3.1.2 使用 Volume</h4><p>1、在 docker swarm 的 master 节点执行创建服务操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">  --name nginx-nfs-test \</span><br><span class="line">  --publish 1180:80 \</span><br><span class="line">  --mount <span class="built_in">type</span>=volume,<span class="built_in">source</span>=nfsdata,destination=/data/web \</span><br><span class="line">  --replicas 3 \</span><br><span class="line">  nginx:1.20.2</span><br></pre></td></tr></table></figure><p>2、查看 Service 部署情况</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230111145635747.png" alt="image-20230111145635747"></p><h4 id="3-1-3-验证数据共享特性"><a href="#3-1-3-验证数据共享特性" class="headerlink" title="3.1.3 验证数据共享特性"></a>3.1.3 验证数据共享特性</h4><p><strong>1、NFS 服务创建测试数据</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230111150058510.png" alt="image-20230111150058510"></p><p><strong>2、Service 验证是否共享 NFS 数据</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230111150309868.png" alt="image-20230111150309868"></p><p>可见，数据被共享了，当然，你在容器中 <code>/data/web</code> 目录下产生的数据也会被持久化到 NFS 服务上。</p><blockquote><p>当然，Nginx 也是正常运行的</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230111151444719.png" alt="image-20230111151444719"></p><h3 id="3-2-通过-Docker-Stack"><a href="#3-2-通过-Docker-Stack" class="headerlink" title="3.2 通过 Docker Stack"></a>3.2 通过 Docker Stack</h3><blockquote><p><a href="https://docs.docker.com/engine/reference/commandline/stack/">Docker Stack CLI</a></p></blockquote><p>通过 Volume 方式，你会发现每台 swarm 集群 work 节点都需要创建 Volume（如果 master 节点也为 work 节点，也要创建 Volume ）。稍显麻烦，我们可通过 Docker Stack 方式来弥补这点不足，也就是使用 Docker Stack 方式时，就不需要手动创建 Docker Volume 了。</p><h4 id="3-2-1-创建-YAML-文件"><a href="#3-2-1-创建-YAML-文件" class="headerlink" title="3.2.1 创建 YAML 文件"></a>3.2.1 创建 YAML 文件</h4><blockquote><p>参考1：<a href="https://docs.docker.com/engine/reference/commandline/compose/">docker compose CLI</a></p><p>参考2：<a href="https://zhuanlan.zhihu.com/p/387840381">docker compose 配置文件主要配置</a></p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim nginx-compose.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下配置文件会创建一个名为myweb_nginx-nfs-test-1的service</span></span><br><span class="line"><span class="comment"># service命名规则：stack名_service名</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  nginx-nfs-test-1:</span><br><span class="line">    image: nginx:1.20.2</span><br><span class="line">    deploy:</span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: 3</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;1181:80&quot;</span></span><br><span class="line">    networks:</span><br><span class="line">      my-overlay-network:</span><br><span class="line">        aliases:</span><br><span class="line">          - nginx-test-net</span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">&quot;mountdata:/data/web&quot;</span></span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  mountdata:</span><br><span class="line">    driver: <span class="built_in">local</span></span><br><span class="line">    driver_opts:</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;nfs&quot;</span></span><br><span class="line">      o: <span class="string">&quot;addr=192.168.56.141,rw&quot;</span></span><br><span class="line">      device: <span class="string">&quot;:/data/sharedir&quot;</span></span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  my-overlay-network:</span><br><span class="line">    driver: overlay</span><br></pre></td></tr></table></figure><p>如果你需要在指定的 Node 节点上运行 Service，可在配置文件中进行指定 Node 节点名（新增 placement 字段）。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  nginx-nfs-test-1:</span><br><span class="line">    image: nginx:1.20.2</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints:</span><br><span class="line">          - <span class="string">&quot;node.hostname==harbor-nexus&quot;</span></span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: 3</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><blockquote><p>除了可指定节点名外，还可以指定节点 ID、标签等。</p></blockquote><h4 id="3-2-2-使用-YAML-文件"><a href="#3-2-2-使用-YAML-文件" class="headerlink" title="3.2.2 使用 YAML 文件"></a>3.2.2 使用 YAML 文件</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy -c nginx-compose.yml myweb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个名为myweb的stack</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230111155010050.png" alt="image-20230111155010050"></p><blockquote><p>查看 Service 所在集群节点</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230111155249105.png" alt="image-20230111155249105"></p><h4 id="3-2-3-验证数据共享特性"><a href="#3-2-3-验证数据共享特性" class="headerlink" title="3.2.3 验证数据共享特性"></a>3.2.3 验证数据共享特性</h4><p>我在 <code>3.1</code> 小节中已经向 NFS 添加过测试数据了，现在来验证容器内部有没有测试数据。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it myweb_nginx-nfs-test-1.2.dahr1c6am279qgnhf2910449c bash</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230111155733010.png" alt="image-20230111155733010"></p><p><strong>可见，数据已经同步到 swarm service 容器内部。</strong></p><p><mark>至此，Docker Swarm 的数据持久化问题已经解决。当然，除了 NFS 共享存储外，还有 Ceph、ClusterFS 等存储也能实现。实际生产中大家自行修改使用即可。</mark></p><p><strong>这里你有没有考虑过一个问题：当我们有多个模块的时候，NFS 的共享存储目录要怎么规划呢？</strong></p><p>其实很简单，每个模块依次添加即可，如下案例（假设有 web、center 两个模块）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    image: nginx:1.20.2</span><br><span class="line">    deploy:</span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: 3</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;1080:80&quot;</span></span><br><span class="line">    networks:</span><br><span class="line">      web-net:</span><br><span class="line">        aliases:</span><br><span class="line">          - web-net-test</span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">&quot;mywebdata:/data/web&quot;</span></span><br><span class="line">  center:</span><br><span class="line">    image: center:1.20.2</span><br><span class="line">    deploy:</span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: 3</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;8181:8080&quot;</span></span><br><span class="line">    networks:</span><br><span class="line">      web-net:</span><br><span class="line">        aliases:</span><br><span class="line">          - web-net-test</span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">&quot;mycenterdata:/data/center&quot;</span></span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  mywebdata:</span><br><span class="line">    driver: <span class="built_in">local</span></span><br><span class="line">    driver_opts:</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;nfs&quot;</span></span><br><span class="line">      o: <span class="string">&quot;addr=192.168.56.141,rw&quot;</span></span><br><span class="line">      device: <span class="string">&quot;:/data/sharedir/web&quot;</span></span><br><span class="line">  mycenterdata:</span><br><span class="line">    driver: <span class="built_in">local</span></span><br><span class="line">    driver_opts:</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;nfs&quot;</span></span><br><span class="line">      o: <span class="string">&quot;addr=192.168.56.141,rw&quot;</span></span><br><span class="line">      device: <span class="string">&quot;:/data/sharedir/center&quot;</span></span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  web-net:</span><br><span class="line">    driver: overlay</span><br></pre></td></tr></table></figure><blockquote><p>注意：要在 NFS 共享目录 &#x2F;data&#x2F;sharedir&#x2F; 下创建对应的目录<br>如：mkdir &#x2F;data&#x2F;sharedir&#x2F;{web,center}<br>之后，容器产生的数据将会存储于对应的目录下。</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Docker_Swarm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ansible 快速入门</title>
      <link href="/posts/articles/7fbc334.html"/>
      <url>/posts/articles/7fbc334.html</url>
      
        <content type="html"><![CDATA[<h1 id="Ansible-快速入门"><a href="#Ansible-快速入门" class="headerlink" title="Ansible 快速入门"></a><center>Ansible 快速入门</center></h1><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/timg.jpg" alt="timg"></p><p><a href="https://docs.ansible.com/ansible/latest/">官方文档</a></p><hr><h2 id="一、Ansible-是什么"><a href="#一、Ansible-是什么" class="headerlink" title="一、Ansible 是什么?"></a>一、Ansible 是什么?</h2><p><code>Ansible</code>它是一个 IT 自动化工具。它可以配置系统、部署软件并协调更高级的 IT 任务，例如持续部署或零停机时间滚动更新等。Ansible 的主要目标是简单和易用，它还非常关注安全性和可靠性，具有最少的移动部件，其使用 <code>OpenSSH</code> 进行传输。</p><h2 id="二、Ansible-安装"><a href="#二、Ansible-安装" class="headerlink" title="二、Ansible 安装"></a>二、Ansible 安装</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h3><h4 id="2-1-1-Python-方式"><a href="#2-1-1-Python-方式" class="headerlink" title="2.1.1 Python 方式"></a>2.1.1 Python 方式</h4><p>1、安装最新版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install --user ansible</span><br></pre></td></tr></table></figure><p>2、安装指定版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install --user ansible-core==2.12.3</span><br></pre></td></tr></table></figure><p>3、升级 Ansible</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install --upgrade --user ansible</span><br></pre></td></tr></table></figure><p>4、验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible --version</span><br></pre></td></tr></table></figure><p>5、Ansible 的 shell补全</p><ul><li><p>安装 argcomplete</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install --user argcomplete</span><br></pre></td></tr></table></figure></li><li><p>配置 argcomplete</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全局配置：要求 bash 4.2</span></span><br><span class="line">activate-global-python-argcomplete</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果您没有 bash 4.2，则必须单独注册每个脚本</span></span><br><span class="line">eval $(register-python-argcomplete ansible)</span><br><span class="line">eval $(register-python-argcomplete ansible-config)</span><br><span class="line">eval $(register-python-argcomplete ansible-console)</span><br><span class="line">eval $(register-python-argcomplete ansible-doc)</span><br><span class="line">eval $(register-python-argcomplete ansible-galaxy)</span><br><span class="line">eval $(register-python-argcomplete ansible-inventory)</span><br><span class="line">eval $(register-python-argcomplete ansible-playbook)</span><br><span class="line">eval $(register-python-argcomplete ansible-pull)</span><br><span class="line">eval $(register-python-argcomplete ansible-vault)</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-1-2-Yum-方式"><a href="#2-1-2-Yum-方式" class="headerlink" title="2.1.2 Yum 方式"></a>2.1.2 Yum 方式</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install ansible</span><br></pre></td></tr></table></figure><p>其他特定系统安装请看<a href="https://docs.ansible.com/ansible/latest/installation_guide/installation_distros.html">官方文档</a>。</p><h3 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2 配置"></a>2.2 配置</h3><p>配置文件位于 <code>/etc/ansible</code> 下，Ansible 中的某些设置可通过配置文件 (ansible.cfg) 进行调整。对于大多数用户来说，Inventory 配置已经足够了。</p><h2 id="三、快速入门"><a href="#三、快速入门" class="headerlink" title="三、快速入门"></a>三、快速入门</h2><h3 id="3-1-三组件"><a href="#3-1-三组件" class="headerlink" title="3.1 三组件"></a>3.1 三组件</h3><p>一个基本的 Ansible 环境包含三个主要组件：<code>Control node</code>、<code>Managed node</code>、<code>Inventory</code></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220922100244734.png" alt="image-20220922100244734"></p><p><strong>1、Control node</strong></p><p>安装了 Ansible 的系统，安装完成后，可以在控制节点上运行 Ansible 相关命令，例如<code>ansible</code>或<code>ansible-inventory</code>。</p><p><strong>2、Managed node</strong></p><p>Ansible 控制的远程系统或主机，即接下来要说到的 hosts 文件中的主机清单。</p><p><strong>3、Inventory</strong></p><p>逻辑组织的受管节点列表，在控制节点上创建一个清单以向 Ansible 描述主机部署。</p><h3 id="3-2-基础使用"><a href="#3-2-基础使用" class="headerlink" title="3.2 基础使用"></a>3.2 基础使用</h3><blockquote><p>我的 ansible 机器为：192.168.56.132</p></blockquote><p><strong>1、安装 Ansible</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install --user ansible</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或 yum 安装</span></span><br><span class="line">yum install -y ansible</span><br></pre></td></tr></table></figure><p><strong>2、添加主机列表</strong></p><blockquote><p>通过将一个或多个远程系统的 IP 地址或完全限定域名 (FQDN) 添加到<code>/etc/ansible/hosts</code></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[web]</span><br><span class="line">192.168.56.132</span><br><span class="line">192.168.56.180</span><br></pre></td></tr></table></figure><p><strong>3、验证清单中的主机</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible all --list-hosts</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hosts (2):</span><br><span class="line">  192.168.56.132</span><br><span class="line">  192.168.56.180</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220922101103515.png" alt="image-20220922101103515"></p><p><strong>3、设置 SSH 连接</strong></p><blockquote><p>将 <code>Control node</code> 主机的 SSH 公密添加到每个远程系统（主机）上的 <code>authorized_keys</code> 文件中，以便 Ansible 可以连接到受管节点。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id 192.168.56.180</span><br></pre></td></tr></table></figure><p>如果控制节点上的用户名在主机上不同，则需要将<code>-u</code>选项与<code>ansible</code>命令一起传递。</p><p><strong>4、Ping 受管节点</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible all -m ping</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">192.168.56.180 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot;</span><br><span class="line">    &#125;, </span><br><span class="line">    &quot;changed&quot;: false, </span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br><span class="line">192.168.56.132 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot;</span><br><span class="line">    &#125;, </span><br><span class="line">    &quot;changed&quot;: false, </span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220922101829925.png" alt="image-20220922101829925"></p><h3 id="3-3-创建-Inventory"><a href="#3-3-创建-Inventory" class="headerlink" title="3.3 创建 Inventory"></a>3.3 创建 Inventory</h3><p>Inventory 文件位于 Control node 节点上（即安装 ansible 的主机）。使用清单文件，Ansible 可以通过单个命令管理大量主机，我们也可以直接将受管节点添加到<code>/etc/ansible/hosts</code>文件中，来实现批量主机管理。在 Inventory 文件编写中，其语法格式可以是<code>INI</code>或<code>YAML</code>格式，建立一个 Inventory 的基本步骤如下：</p><ul><li>在您的控制节点上打开一个终端窗口。</li><li>在任何目录中创建一个新的库存文件<code>inventory.yaml</code>并打开它进行编辑。</li><li>为您的主机添加一个新组，然后使用该字段指定每个受管节点的 IP 地址或完全限定域名 (FQDN) <code>ansible_host</code>。</li></ul><p><strong>1、创建名为 inventory.yaml 的 Inventory</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat inventory.yaml</span><br><span class="line"></span><br><span class="line">mywebhost:</span><br><span class="line">  hosts:</span><br><span class="line">    vm01:</span><br><span class="line">      ansible_host: 192.168.56.132</span><br><span class="line">    vm02:</span><br><span class="line">      ansible_host: 192.168.56.180</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">说明：mywebhost 为组名</span></span><br></pre></td></tr></table></figure><p><strong>2、验证 Inventory</strong></p><blockquote><p>如果你在主目录以外的目录中创建了清单，请使用该<code>-i</code>选项指定完整路径。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-inventory -i inventory.yaml --list</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220922104607536.png" alt="image-20220922104607536"></p><p><strong>2、ping 清单中的受管节点</strong></p><blockquote><p>在此示例中，组名称是<code>mywebhost</code>，此时可以使用<code>ansible</code>命令。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible mywebhost -m ping -i inventory.yaml</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vm01 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot;</span><br><span class="line">    &#125;, </span><br><span class="line">    &quot;changed&quot;: false, </span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br><span class="line">vm02 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot;</span><br><span class="line">    &#125;, </span><br><span class="line">    &quot;changed&quot;: false, </span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220922104904636.png" alt="image-20220922104904636"></p><p><mark>注意 Inventory 与 hosts 文件的区别：</mark></p><p>Ansible 的主机清单是 Inventory，我们可以通过创建 <code>*.yaml</code> 文件来作为我们的主机清单（Inventory）文件，如果你没有创建这个 yaml 文件，那 Ansible 的默认主机清单文件就是 hosts，这个文件在安装 Ansible 时默认存在 的。当找不到 *.yaml 主机清单文件时，就会去找 hosts 文件。</p><p>由于 hosts 文件是默认的主机清单文件，如果你想使用你自定义的其他主机清单文件，需通过 <code>-i</code> 参数指定，如 <code>ansible mywebhost -m ping -i inventory.yaml</code>，否则它会默认去找 hosts 文件。</p><h3 id="3-4-创建-playbook"><a href="#3-4-创建-playbook" class="headerlink" title="3.4 创建 playbook"></a>3.4 创建 playbook</h3><p><code>YAML</code>剧本是 Ansible 用于部署和配置托管节点的自动化蓝图。看看几个重要元素：</p><ul><li><p><strong>Playbook</strong></p><p>定义 Ansible 从上到下执行操作以实现总体目标的顺序的剧本列表。</p></li><li><p><strong>Play</strong></p><p>映射到清单中的受管节点的有序任务列表。</p></li><li><p><strong>Task</strong></p><p>定义 Ansible 执行的操作的一个或多个模块的列表。</p></li><li><p><strong>Module</strong></p><p>Ansible 在托管节点上运行的代码或二进制单元。</p></li></ul><p><mark>创建一个 playbook 的步骤如下：</mark></p><ul><li><p>在控制节点上打开一个终端窗口。</p></li><li><p>在任何目录中创建一个新的 playbook 文件<code>playbook.yaml</code>并打开它进行编辑。</p></li></ul><p><strong>1、创建 playbook</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cat</span> <span class="string">playbook.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">My</span> <span class="string">first</span> <span class="string">play</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">mywebhost</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Ping</span> <span class="string">my</span> <span class="string">hosts</span></span><br><span class="line">     <span class="attr">ansible.builtin.ping:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Print</span> <span class="string">message</span></span><br><span class="line">     <span class="attr">ansible.builtin.debug:</span></span><br><span class="line">       <span class="attr">msg:</span> <span class="string">Hello</span> <span class="string">world</span></span><br><span class="line">       </span><br><span class="line"><span class="comment"># 可看到我的主机清单指定的是mywebhost组，而这个组是在我自定义的Inventory文件中定义的</span></span><br><span class="line"><span class="comment"># 因此我在运行playbook时需要-i指定自定义的Inventory文件，如果不指定，ansible就回去找默认的hosts文件，而这个文件中根本没有mywebhost这个组名，所以会报错。</span></span><br></pre></td></tr></table></figure><p><strong>2、运行 playbook</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ansible-playbook</span> <span class="string">-i</span> <span class="string">inventory.yaml</span> <span class="string">playbook.yaml</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220922112600610.png" alt="image-20220922112600610"></p><p><mark>剧本的执行过程：</mark></p><ul><li>任务隐式运行。默认情况下，Ansible 会收集可以在 playbook 中使用的库存信息（Inventory），<code>Gather Facts</code>。</li><li>每个任务的状态。每个任务都有一个状态，<code>ok</code>这意味着它运行成功。</li><li>对每个主机的剧本中所有任务的结果进行总结的剧本回顾。在此示例中，共有三个任务，因此<code>ok=3</code>表明每个任务都运行成功。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 自动化运维 </category>
          
          <category> Ansible </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ansible </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 应用架构</title>
      <link href="/posts/articles/ff3ea403.html"/>
      <url>/posts/articles/ff3ea403.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/docker-ct.jpg" alt="docker-ct"></p><p><font color=Brown><strong>Author</strong>：rab</font></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Docker 采用 C&#x2F;S 网络应用模型，其核心组件包括：Docker 客户端（Client）、Docker 服务端（Docker Daemon）、Docker 镜像（Image）、Docker 仓库（Registry）及 Docker 容器（Container）。接下来通过架构图，详细说明一下 Docker 架构组件的功能及作用。</p><h2 id="一、架构"><a href="#一、架构" class="headerlink" title="一、架构"></a>一、架构</h2><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/Docker-cs.jpg" alt="Docker-cs"></p><p>&#x3D;&#x3D;流程&#x3D;&#x3D;：Docker 客户端（Client）向 Docker 服务端（Docker Daemon）发起请求（如 docker pull&#x2F;run&#x2F;build … 等），Docker 服务端（Docker Daemon）收到请求后就会做出响应。假如是一个 pull 请求，那 Docker 服务端（Docker Daemon）就会向 Docker 仓库（Registry）拉取指定的镜像至 Host 本地进行存储，最后再根据 Docker 客户端（Client）的请求决定是否运行容器或做其他请求操作。</p><h2 id="二、组件"><a href="#二、组件" class="headerlink" title="二、组件"></a>二、组件</h2><h3 id="2-1-客户端（Client）"><a href="#2-1-客户端（Client）" class="headerlink" title="2.1 客户端（Client）"></a>2.1 客户端（Client）</h3><p><code>Docker 客户端（Client）</code>，即 Docker 的客户端管理命令（如上图所示），Docker 客户端（Client） 可以与 Docker 服务端（Daemon）处于同个 Host 下，也可以分开（然后可通过 socket&#x2F;RESET API 进行交互）。Docker 客户端（Client）向 Docker 服务端（Daemon）发起请求，然后 Docker 服务端（Daemon）负责构建、运行和分发容器。</p><h3 id="2-2-服务端（Daemon）"><a href="#2-2-服务端（Daemon）" class="headerlink" title="2.2 服务端（Daemon）"></a>2.2 服务端（Daemon）</h3><p><code>Docker 服务端（Daemon）</code>，即以 Linux 后台服务方式运行的服务器组件，作为服务端，其为 Docker 客户端（Client）的相关请求提供服务和响应，并为客户端的请求负责创建、运行容器，及镜像构建与存储等。下图为后台运行的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker.service</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220906111549565.png" alt="image-20220906111549565"></p><p>Docker 服务端（Daemon）只能响应本地 Host 的 Docker 客户端（Client）请求，如果需要运行远程客户端的请求，需要启用 TCP 监听服务，具体步骤如下：</p><p><strong>1、修改 Docker 配置文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/systemd/system/multi-user.target.wants/docker.service</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">追加 -H tcp://0.0.0.0</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220906111859229.png" alt="image-20220906111859229"></p><p><strong>2、重启 Docker 服务端（Daemon）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure><p><strong>3、远程请求 Docker 服务端（Daemon）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker -H 10.150.16.95 info</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">10.150.16.95：远程Docker服务端（Daemon）的IP地址</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220906112508384.png" alt="image-20220906112508384"></p><h3 id="2-3-镜像（Image）"><a href="#2-3-镜像（Image）" class="headerlink" title="2.3 镜像（Image）"></a>2.3 镜像（Image）</h3><p>在前面的博文已经提到，Image 是一种分层结构的只读镜像，它可通过服务端运行（run）为容器。而什么是镜像呢？又如何创建镜像呢？我们说，镜像是容器的基础。首先要了解镜像就先要了解一个概念——<code>base 镜像</code>，我们的任何镜像都是基于一个基础（base）镜像构建而成的。</p><p>而什么又是基础镜像呢？你需要明确基础镜像的两个特点：</p><ul><li>基础镜像不依赖于其他镜像，也即是说它是镜像的基本单元；</li><li>其他镜像就可以以基础镜像为基准进行构建。</li></ul><p>那这些（基础）镜像又存储于什么位置呢？一般我们可以通过创建自己的私有 docker 镜像仓库（如 Harbor）或直接使用官方的镜像仓库来实现基础镜像及其他镜像的存储，这就是接下来即将说到的 docker 仓库（Registry）。关于如何拉取 docker 仓库（Registry）中的镜像或其他镜像管理指令，大家可以自行看官方文档，这里不作为重点。</p><p>如下图就是从镜像仓库中拉取下来的镜像：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220906114947026.png" alt="image-20220906114947026"></p><p>&#x3D;&#x3D;那问题来了：既然镜像只读，那我其他镜像又是如何基于某个基础镜像来进行构建的呢？&#x3D;&#x3D;</p><p>关于这个问题我也已经做了总结，大家可以看看我前面的文章<a href="https://blog.csdn.net/IT_ZRS/article/details/124692778?spm=1001.2014.3001.5501">《Docker 的 Copy-on-Write 特性》</a></p><h3 id="2-4-仓库（Registry）"><a href="#2-4-仓库（Registry）" class="headerlink" title="2.4 仓库（Registry）"></a>2.4 仓库（Registry）</h3><p>在镜像一节中我们说了，仓库（Registry）就是用来存放镜像（Image）的，它分为私有镜像仓库和公有镜像仓库，所谓的私有镜像仓库就是你个人或你们公司内部搭建的镜像仓库（如 Harbor），只有你个人或你公司内部相关技术人员可使用。而公有镜像仓库默认是 Docker Hub，由 Docker 公司进行维护，该镜像仓库所有人都可进行下载使用。</p><p>关于如何部署一个私有 Docker 镜像仓库，大家可以参考我这篇部署文档<a href="https://blog.csdn.net/IT_ZRS/article/details/121585898?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166244634216800180625588%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=166244634216800180625588&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-121585898-null-null.nonecase&utm_term=harbor&spm=1018.2226.3001.4450">《Harbor 私有镜像仓库部署》</a></p><h3 id="2-5-容器（Container）"><a href="#2-5-容器（Container）" class="headerlink" title="2.5 容器（Container）"></a>2.5 容器（Container）</h3><p>有了以上的基础后，紧接着就是通过镜像（Image）来运行一个容器实例了，用户可通过 Docker 客户端工具来运行、停止、删除容器了。如下图就是运行中的一个 Nginx 容器实例：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220906110737069.png" alt="image-20220906110737069"></p><p><mark>以上就是 Docker 的基础架构及各组件的功能介绍。</mark></p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 容器镜像制作</title>
      <link href="/posts/articles/550cc753.html"/>
      <url>/posts/articles/550cc753.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、镜像制作"><a href="#一、镜像制作" class="headerlink" title="一、镜像制作"></a>一、镜像制作</h2><h3 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h3><p>通过命令行的交互式方式来生成新镜像，而且是基于运行的容器来制作的新镜像。</p><blockquote><p>语法：docker commit &lt;正在运行的容器名&gt; &lt;自定义新的镜像名:冒号后面为指定镜像版本&gt;</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@qcloud ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE             COMMAND                  CREATED          STATUS          PORTS                                      NAMES</span><br><span class="line">a4cd671837dd   centos7.9:v1      &quot;/bin/bash&quot;              5 minutes ago    Up 5 minutes                                               ctos-1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将正在运行的ctos-1容器提交为新的镜像</span></span><br><span class="line">[root@qcloud ~]# docker commit ctos-1 centos7.9:v1</span><br></pre></td></tr></table></figure><h3 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h3><p>第二种方法就是通过 Dockerfile 文件进行镜像构建。实际上就是第一种方法 docker commit xx 指令的集合写在了 Dockerfile 文本中。</p><blockquote><p>语法1：docker build -t &lt;自定义新镜像名&gt; .<br>语法2：docker -f &#x2F;root&#x2F;Dockerfile build -t &lt;自定义新镜像名&gt; .</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -t centos7.9:v2 .</span><br><span class="line"></span><br><span class="line">docker build -f /opt/Dockerfile -t centos7.9:v2 .</span><br></pre></td></tr></table></figure><p>在 Dockerfile 文件里的每一个命令都会生成一个镜像，如 RUN yum install -y vim，docker 会生成一个临时镜像来进行相关写操作（其实就是我们提到镜像顶层的<code>容器层</code>），当该写操作执行完成后 Docker 就会 remove 掉这个临时镜像，并类似 docker commit xxx 生成一个新镜像层。</p><h2 id="二、镜像缓存"><a href="#二、镜像缓存" class="headerlink" title="二、镜像缓存"></a>二、镜像缓存</h2><p>Docker 具备镜像缓存功能，也就是说 Docker 会缓存已存在的镜像（我们知道 Dockerfile 里面的每条指令都会生成一层层镜像，这每一层镜像都会被容器引擎 Docker 给缓存下来），当我们通过 Dockerfile 生成新镜像的时候，如果 Dockerfile 里面的语句（如：RUN yum install -y vim）和 Docker 镜像缓存中一致时，则直接使用缓存镜像，大大提高了镜像构建速度，但是有一个前提，就是新构建的镜像的基础镜像需和 Docker 缓存的镜像的基础镜像属于同一镜像才行。</p><p>举个例子：<br>基础镜像：p<br>基础镜像：u</p><p>新镜像1：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM P</span><br><span class="line">RUN yum install -y vim</span><br></pre></td></tr></table></figure><p>新镜像2：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM p</span><br><span class="line">RUN yum install -y vim</span><br><span class="line">RUN touch /opt/docker.txt</span><br></pre></td></tr></table></figure><p>新镜像3：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM u</span><br><span class="line">RUN yum install -y vim</span><br></pre></td></tr></table></figure><p>构建顺序：新镜像1 ——&gt; 新镜像2 ——&gt; 新镜像3</p><p>是否使用到镜像缓存？</p><ul><li>镜像2：<br>新镜像2 使用到了镜像1的缓存，因为他们的 Dockerfile 都是同一个基础镜像，而且在该基础镜像上，他们都使用了相同的 <code>RUN yum install -y vim（即同个镜像）</code>，此时镜像2 就会直接使用镜像1 的缓存（即省略了安装 vim 的步骤），加快了镜像的构建。</li><li>镜像3：<br>但是镜像3 没有使用到镜像1 或者镜像2 的缓存，因为他们 Dockerfile 文件的基础镜像不同。</li></ul><p>但是有一个问题，如果镜像1、镜像2的 Dockerfile 文件的指令顺序发生变化，那镜像缓存就不会生效，具体如下：</p><p>对上述镜像2的 Dockerfile 的指令顺序做如下修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM p</span><br><span class="line">RUN touch /opt/docker.txt</span><br><span class="line">RUN yum install -y vim</span><br></pre></td></tr></table></figure><p>此时的 Dockerfile 构建的镜像是不会使用到镜像1的缓存的，尽管镜像1和镜像2的基础镜像是一样的，但是镜像2的 Dockerfile 的指令顺序与镜像1的 Dockerfile 指令顺序不一样，所以不会引用镜像1的镜像缓存。尽管内容没发生变化，仅仅顺序发生变化，但是由于 Docker 分层结构特性，Docker 必须重建受影响的镜像。</p><p>查看镜像构建的过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@qcloud ~]# docker history centos7.9:v2</span><br><span class="line">IMAGE          CREATED             CREATED BY                                      SIZE      COMMENT</span><br><span class="line">9f16f2ab2cbc   About an hour ago   /bin/sh -c yum install -y vim &amp;&amp; touch /opt/…   221MB     </span><br><span class="line">eeb6ee3f44bd   7 months ago        /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B        </span><br><span class="line">&lt;missing&gt;      7 months ago        /bin/sh -c #(nop)  LABEL org.label-schema.sc…   0B        </span><br><span class="line">&lt;missing&gt;      7 months ago        /bin/sh -c #(nop) ADD file:b3ebbe8bd304723d4…   204MB </span><br></pre></td></tr></table></figure><p>如果不想使用缓存功能，可以在镜像构建时添加 –no-cache</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --no-cache -t centos7.2:v3 .</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 数据存储及持久化应用</title>
      <link href="/posts/articles/ff15f591.html"/>
      <url>/posts/articles/ff15f591.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/cunchu.webp" alt="cunchu"></p><p><font color=Brown><strong>Author</strong>：rab</font><br><font color=Brown><strong>Date</strong>：2022&#x2F;08&#x2F;09</font><br><font color=Brown><strong>Blog</strong>：<a href="https://blog.csdn.net/IT_ZRS?type=blog"><font color=Brown>https://blog.csdn.net/IT_ZRS?type&#x3D;blog</font></a></font></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Docker 为容器提供了两种存放数据的资源：</p><ul><li>storage driver：管理镜像层和容器层；</li><li>data volume：管理容器应用数据。</li></ul><h2 id="一、Storage-Driver"><a href="#一、Storage-Driver" class="headerlink" title="一、Storage Driver"></a>一、Storage Driver</h2><h3 id="1-1-Storage-Driver-介绍"><a href="#1-1-Storage-Driver-介绍" class="headerlink" title="1.1 Storage Driver 介绍"></a>1.1 Storage Driver 介绍</h3><p>不同操作系统 Docker 默认的存储驱动可能不同，如 Ubuntu 15.04 使用的存储驱动是 aufs，底层文件系统时 extfs。而我下图中是 CentOS 7.9。其 Docker 存储驱动就是 overlay2。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220809122145202.png" alt="image-20220809122145202"></p><blockquote><p>查看存储驱动</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220809121816382.png" alt="image-20220809121816382"></p><p>之前博客中提到 Docker 的 Copy-on-Write 特性，之所以可以实现这样的特性，主要是因为我们 Docker Storage Driver 存储驱动，它实现了多层数据堆叠，并为用户提供一个单一的合并之后的统一视图。有兴趣的可以去看看我前面的博客<a href="https://blog.csdn.net/IT_ZRS/article/details/124692778">《Docker 的 Copy-on-Write 特性》</a>。</p><h3 id="1-2-Storage-Driver-类型"><a href="#1-2-Storage-Driver-类型" class="headerlink" title="1.2 Storage Driver 类型"></a>1.2 Storage Driver 类型</h3><p>Docker 支持多种 Storage Driver，主要有这几种类型：</p><ul><li><p>VFS</p></li><li><p>ZFS</p></li><li><p>Btrfs</p></li><li><p>AUFS</p></li><li><p>OverlayFS</p></li><li><p>Device Mapper</p></li></ul><p>对于 DOcker 使用哪种类型的存储引擎，官方给出的答案是：默认使用你当前 Linux 发行版的 Storage Driver，因为默认的 Storage Driver 是最稳定存储引擎，在发行版上经过了严格的测试。</p><p>使用 Storage Driver 数据存储有什么优势呢？对于那些无状态（即无需数据持久化到本地）的容器，Storage Driver  的优势将是毫无疑问的，因为它能从镜像直接创建、删除（且删除时生成的数据也一并随容器删除）。</p><p>而对于需要做数据持久化的容器，Storage Driver 显然就不如 Data Volume，也就是对于这类有状态的容器，我们要用到 Docker 的 Data Volume 来做容器数据持久化存储。</p><h2 id="二、Data-Volume"><a href="#二、Data-Volume" class="headerlink" title="二、Data Volume"></a>二、Data Volume</h2><h3 id="2-1-Data-Volume-介绍"><a href="#2-1-Data-Volume-介绍" class="headerlink" title="2.1 Data Volume 介绍"></a>2.1 Data Volume 介绍</h3><p>Data Volume 实际上是我们宿主机上的目录或文件，我们通过挂载的方式将 Host 的目录或文件挂载到容器内部文件系统，有时也可以说是把容器文件系统映射到宿主机上。</p><p>这样一来容器产生的数据就可以往 Volume 写入数据了，并持久化到 Host 本地了，即使该容器被删除了，再次运行一个新的容器，状态也是与之前保持一致的。</p><h3 id="2-2-Data-Volume-类型"><a href="#2-2-Data-Volume-类型" class="headerlink" title="2.2 Data Volume 类型"></a>2.2 Data Volume 类型</h3><h4 id="2-2-1-bind-mount"><a href="#2-2-1-bind-mount" class="headerlink" title="2.2.1 bind mount"></a>2.2.1 bind mount</h4><p>该类型是将 Host 上已存在的目录或文件 mount 到容器。</p><p>1、具体案例</p><p>看下面案例：其语法结构为 <code>-v &lt;Host_path&gt;:&lt;container_path(不存在则创建)&gt;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker run -it \</span><br><span class="line">--name=elasticsearch \</span><br><span class="line">--privileged=true \</span><br><span class="line">--restart=always \</span><br><span class="line">--net=host \</span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">-v /data/elasticsearch/data:/usr/share/elasticsearch/data \</span><br><span class="line">-v /data/elasticsearch/logs:/usr/share/elasticsearch/logs \</span><br><span class="line">-v /data/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">-v /data/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</span><br><span class="line">-e ES_JAVA_OPTS=&quot;-Xms512m -Xmx512m&quot; \</span><br><span class="line">-e &quot;discovery.type=single-node&quot; \</span><br><span class="line">-d elasticsearch:6.8.20</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意：&#x3D;&#x3D;如果 <code>container_path</code> 存在数据，则会被隐藏，取而代之的是 Host mount 的目录或文件，这与 Linux 中 mount 效果一样。</p><p>2、带有权限的 bind mount</p><p>类似 Linux 的 mount，在挂载时可指定挂载目录权限，默认时<code>读写权限</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -it \</span><br><span class="line">...</span><br><span class="line">-v /data/elasticsearch/plugins:/usr/share/elasticsearch/plugins:ro \</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ro：只读</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rw：读写</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;小结：&#x3D;&#x3D;从上面的案例上看，bind mount 可实现对目录或文件的 mount 操作，可根据你的实际情况操作。</p><h4 id="2-2-2-docker-managed-volume"><a href="#2-2-2-docker-managed-volume" class="headerlink" title="2.2.2 docker managed volume"></a>2.2.2 docker managed volume</h4><p>与 bind mount 不同的是，<code>docker managed volume</code> 不需要指定 mount 源，只需指明挂载点（mount point）即可。</p><p>1、案例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name=tmp -p 8280:80 -v /usr/local/apache2/htdocs httpd</span><br></pre></td></tr></table></figure><blockquote><p>我只指定了容器内部挂载点，并没有指定 Host 源目录&#x2F;文件，那这个数据持久化到 Host 的哪个位置呢？</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220809150246050.png" alt="image-20220809150246050"></p><p>继续查看容器的详细信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker inspect tmp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">看 Mount 部分</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220809150430133.png" alt="image-20220809150430133"></p><p>2、如何持久化呢？</p><p>此时上图红框中的部分就是数据持久化目录了，就可以像 bind mount 对持久化目录&#x2F;文件进行相关更新了。具体如下：</p><ul><li><p>当前内容</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220809151421398.png" alt="image-20220809151421398"></p></li><li><p>内容更新</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@docker_swarm_work1 _data]# pwd</span><br><span class="line">/var/lib/docker/volumes/fb39b435deb9bd50531b7da00ff1313f94bed8e489afb0ff69f27b77cd8a9253/_data</span><br><span class="line">[root@docker_swarm_work1 _data]# cat index.html </span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</span><br><span class="line">[root@docker_swarm_work1 _data]# echo &#x27;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Update It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&#x27; &gt; index.html</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220809151823689.png" alt="image-20220809151823689"></p></li><li><p>删除容器并新起一个容器（验证数据持久化）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker stop tmp &amp;&amp; docker rm tmp</span><br><span class="line">docker run -d --name=tmp -p 8288:80 -v /usr/local/apache2/htdocs httpd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再起一个新容器的话，docker 又会重新创建一个随机的持久话目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">但是我们之前的数据依然是在红框的上一个目录里面的</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220809152528267.png" alt="image-20220809152528267"></p></li></ul><h3 id="2-3-查看-Data-Volume"><a href="#2-3-查看-Data-Volume" class="headerlink" title="2.3 查看 Data Volume"></a>2.3 查看 Data Volume</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220809154016353.png" alt="image-20220809154016353"></p><p>但是需注意，<code>docker volume ls</code> 只能查看 <code>docker managed volume</code> 类型的 <code>Data Volume</code>， <code>bind mount</code> 的 <code>Data Volume</code> 需要通过 <code>docker inspect &lt;container_name&gt;</code> 来查看。</p><p>&#x3D;&#x3D;如果我想在删除容器时，连 volume 也一并删除，如何操作？&#x3D;&#x3D;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker stop tmp</span><br><span class="line">docker rm -v tmp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其中-v就表示volume</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果你确定不再需要这些持久化数据了就可执行 -v 操作</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker <span class="built_in">rm</span> -v &lt;container_name&gt; 对 <span class="built_in">bind</span> mount 类型的volume无效（也是无法删除，想删除需手动）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果你运行容器时指定了--<span class="built_in">rm</span>，那在停止容器时volume也会被自动删除（当然也是只对docker managed volume才有效）</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220809154426361.png" alt="image-20220809154426361"></p><blockquote><p>如果删除 docker managed volume 类型容器的时候，忘记带 -v 参数了，这样的化会产生孤儿 volume，也就是说被删除的容器数据还持久化在 Host 上的（除非你确定该数据已经不需要要了，那就可以删除了），如何删除？</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除指定volume</span></span><br><span class="line">docker volume rm 02cc4ecdf7ac50fe346d67476e5e1e5ef67e207ca5ce0dd5db93cb510377c79f</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除所有volume</span></span><br><span class="line">docker volume rm $(docker volume ls -q)</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220809170514878.png" alt="image-20220809170514878"></p><h2 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h2><p><code>bind mount</code> 与 <code>docker managed volume</code> 就类似于动态指定端口和静态指定端口，动态指定端口：<code>-p 80</code> 此时会将容器的 80 端口在 Host 上映射一个随机端口，静态指定端口：<code>-p 8080:80</code>。</p><p><mark>区别：</mark></p><ul><li><p><code>bind mount</code> 指定的数据卷是静态的，而 <code>docker managed volume</code> 指定的数据卷是随机动态的；</p></li><li><p><code>bind mount</code> 挂载时 Host 源 path 会覆盖掉容器目标 path（但并不代表被永久替换），而  <code>docker managed volume</code> 则是将容器原有的目录或文件随机持久化在 <code>/var/lib/docker/volumes</code> 目录下；</p></li><li><p><code>bind mount</code> 可指定挂载目录的读写权限，而 <code>docker managed volume</code> 不能；</p></li><li><p><code>bind mount</code> 的 mount 源可以是目录或文件，而 <code>docker managed volume</code> 只能是目录。</p></li></ul><p>对于无状态（无需做数据持久化）的容器我们可以选择 <code>Storage Driver</code> 默认存储引擎即可，如果对于有状态（需做数据持久化）的容器我们需要引入 <code>Data Volume</code> 实现数据持久化。</p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 底层技术</title>
      <link href="/posts/articles/3afbe0a6.html"/>
      <url>/posts/articles/3afbe0a6.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、Cgroup"><a href="#一、Cgroup" class="headerlink" title="一、Cgroup"></a>一、Cgroup</h2><p>cgroup（Control Group），它用于 linux 系统资源分配、限制，前面提到的 Docker 资源分配与限制就是使用的 linux 底层技术来实现。</p><ul><li><p>CPU：&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;docker</p></li><li><p>内存：&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;docker</p></li><li><p>磁盘 IO：&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;blkio&#x2F;docker</p></li></ul><p>当运行一个容器时，linux系统（宿主机）就会为这个容器创建一个 cgroup 目录，并以容器长 ID 命名，如下图：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230330211721016.png" alt="image-20230330211721016"></p><p>该长 ID 目录下就有一个 cpu.shares 文件，其值为默认值或是你在运行容器时指定的值，如下图：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230330211743069.png" alt="image-20230330211743069"></p><p>内存、磁盘 IO 类似。</p><h2 id="二、Namespace"><a href="#二、Namespace" class="headerlink" title="二、Namespace"></a>二、Namespace</h2><p>抛开宿主机后，你会发现每个容器都已自己独立的一套完整资源，如网卡设备、文件系统等，而实现这一技术的正是 <code>namespace</code>，namespace 管理 Host 中全局唯一资源，并可以让每个容器都觉得只有自己在使用它。其实也就是 namespace 实现了容器间资源的隔离。你也可以类比 k8s 的 namespace，在 k8s 中，namespace 可实现权限划分、资源访问等。</p><p>Linux 使用了 6 种 namespace，分别是：Mount、UTS、IPC、PID、Network 和 User。</p><p><strong>1、Mount</strong></p><p>该 namespace 可让容器拥有自己独立的文件系统，比如容器有自己的 &#x2F; 目录，可实现相关的挂载操作（当然这些操作并不会影响我们的宿主机及其他容器）</p><p><strong>2、UTS</strong></p><p>该 namespace 可让容器拥有自己独立的 hostname，比如我们在运行容器时通过 -h 指定 hostname。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -h rab ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其中rab就是该容器的主机名</span></span><br></pre></td></tr></table></figure><p><strong>3、IPC</strong></p><p>该 namespace 让容器拥有自己的共享内存和信号量，来实现进程间的通信，而不会与宿主机（Host）及其他容器混在一起。</p><p><strong>4、PID</strong></p><p>该 namespace 让容器拥有自己独立一套的 PID，每个容器都是以进程的形式在宿主机（Host）中运行，如图下运行了三个容器及其在 Host 中对应的 PID。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230330211817540.png" alt="image-20230330211817540"></p><p>可看到，所有容器进程都挂到了 docker 容器引擎进程 <code>/usr/bin/containerd</code> 下。</p><p><strong>注意</strong>：每个容器拥有自己独立一套的 PID，但容器中为 1 的 PID 并不是 Host 的 init 进程，因为容器与 Host 的 PID 是完全隔离且完整独立的。</p><p><strong>5、Network</strong></p><p>该 namespace 让容器拥有自己独立网卡设备、路由等资源，同样与 Host 的 Network 是完全隔离且完整独立的。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230330211842636.png" alt="image-20230330211842636"></p><p><strong>6、User</strong></p><p>该 namespace 让容器拥有自己独立的用户空间，同样与 Host 的 User 是完全隔离且完整独立的。</p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 镜像 Tag 管理</title>
      <link href="/posts/articles/ad0675e5.html"/>
      <url>/posts/articles/ad0675e5.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/docker-docs.webp" alt="docker-docs"></p><p><font color="Brown"><strong>Author</strong>：rab</font></p><hr><p>良好的镜像版本命名习惯能让我们更好的管理和使用镜像（如项目上线失败后可有效的进行版本回退），以下是 Docker 社区常用的 tag 方案。</p><p>比如我现在已经构建了一个 <code>coredns/coredns:1.8.4</code> 镜像，现在对该镜像进行打 tag，具体命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker tag -t coredns/coredns:1.8.4 mycoredns:1.8</span><br><span class="line">docker tag -t coredns/coredns:1.8.4 mycoredns:1.8.4</span><br><span class="line">docker tag -t coredns/coredns:1.8.4 mycoredns:latest</span><br></pre></td></tr></table></figure><p>如果此时我又发布了 <code>coredns/coredns:1.8.5</code> 镜像，我又可以将之前打的 1.8 更新，因为我想实现的是：不管发布的镜像版本是 <code>1.8.4、1.8.5、1.8.6、1.8.x</code>，我的 1.8 大版本始终是保持最新的，而我的小版本（1.8.4）可以进行相关的版本回退或在特定环境中实现部署等，具体操作指令如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker tag -t coredns/coredns:1.8.5 mycoredns:1.8</span><br><span class="line">docker tag -t coredns/coredns:1.8.5 mycoredns:1.8.5</span><br><span class="line">docker tag -t coredns/coredns:1.8.5 mycoredns:latest</span><br></pre></td></tr></table></figure><p><strong>通过下图就比较容易理解与记忆：</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/Docker%20Tag.jpg" alt="Docker Tag"></p><p><mark>小结：每个镜像（repository）可以有多个 tag，而多个 tag 可能对应的是同一个镜像。</mark></p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 网络</title>
      <link href="/posts/articles/4b442585.html"/>
      <url>/posts/articles/4b442585.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、None"><a href="#一、None" class="headerlink" title="一、None"></a>一、None</h2><p>该网络模式，即没有网络的网络模式，可通过 –network&#x3D;none 来指定。该网络模式的容器除了 lo 本地回环网卡外，无其他任何网卡，那该网络模式存在的意义是什么呢？</p><p>在一些安全级别要求高的场景下是需要的，如：用作密码服务器，就不需要任何的网络模式。</p><h2 id="二、Bridge"><a href="#二、Bridge" class="headerlink" title="二、Bridge"></a>二、Bridge</h2><p><strong>1、容器虚拟网卡</strong></p><p>如果在运行容器时，不指定任何网络模式，那创建的容器默认都会挂到 docker0 网卡上，如下图，这三个容器我都没通过 –network 指定网络模式。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214182925558.png" alt="image-20221214182925558"></p><p>【interfaces】字段下的内容就是运行的这三个容器对应的虚拟网卡。此时进入某个容器，去查看一下其网卡名，如下图所示：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214182942221.png" alt="image-20221214182942221"></p><p>你会发现该容器的网卡名与【interfaces】字段下的虚拟网卡名不一致，这是为什么呢？</p><p>其实这是因为容器的虚拟网卡与挂在 docker0 下的虚拟网卡是一对特殊的 <code>veth pair</code> 网络设备。</p><p><strong>2、容器 IP 地址</strong></p><p>通过上图我们可以看到，运行的容器自动分配了一个 IP 地址，那该 IP 地址是从哪获取的呢？我们可以查看一下 Bridge 的网络配置信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect bridge</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214183000755.png" alt="image-20221214183000755"></p><p>网段：172.17.0.0</p><p>网关：172.17.0.1</p><p>此时你会想，容器是如何与外界通信的（比如 yum install .. 安装等），其实正是上面这个网关地址，这个网关地址就是 docker0 网卡地址，如下图：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214183016265.png" alt="image-20221214183016265"></p><p>通过上图你就会明白，运行的容器能连接外网安装一些基础工具，通过路由表可知其过程是：</p><ul><li>先访问目标IP（比如：221.237.105.143），发现没在自己的路由表中（既不是 <code>10.150.16.0</code> 也不是 <code>172.17.0.0</code>）；</li><li>于是就走 <code>0.0.0.0</code>，通过宿主机网关 <code>10.150.16.1</code> 与外界通信。</li></ul><h2 id="三、Host"><a href="#三、Host" class="headerlink" title="三、Host"></a>三、Host</h2><p>相对 Bridge 网络模式来说，Host 网络模式更便于理解，可通过 –network&#x3D;host 来指定，此时，容器的网络配置与宿主机（Host）完全一样。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --network=host busybox</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214183035316.png" alt="image-20221214183035316"></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214183047741.png" alt="image-20221214183047741"></p><p>从上图可看出，容器和宿主机的网络保持一致，换句话说，容器共享宿主机网络，这有什么好处？</p><p>对于网络性能要求较高的场景可以使用 Host 网络模式。</p><p>但该网络模式也有一些缺点，就是要考虑到容器和宿主机端口冲突的问题。</p><h2 id="四、自定义网络"><a href="#四、自定义网络" class="headerlink" title="四、自定义网络"></a>四、自定义网络</h2><p>除了以上三种网络模式，我们也可以自定义网络模式。</p><p><strong>1、自定义 Bridge 类型网络模式</strong></p><blockquote><p>不指定 –driver 的话，默认就是 Bridge 类型</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@qcloud ~]# docker network create --driver bridge net_a</span><br><span class="line">8568822dd4bf8ab5e9a33635f2f5bdb6a4577652879c55e13390b43d950f99ec</span><br><span class="line">[root@qcloud ~]# brctl show</span><br><span class="line">bridge namebridge idSTP enabledinterfaces</span><br><span class="line">br-8568822dd4bf8000.0242232f6190no</span><br><span class="line">docker08000.02429fa58d80noveth4b12f0c</span><br><span class="line">veth5cfded2</span><br><span class="line">veth6e1ba81</span><br></pre></td></tr></table></figure><p>查看具体属性：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[root@qcloud ~]# docker network inspect net_a </span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;net_a&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;8568822dd4bf8ab5e9a33635f2f5bdb6a4577652879c55e13390b43d950f99ec&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2022-05-12T19:13:11.197656976+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可看到 Driver 驱动类型为 bridge 类型网络，同时 Docker 为其分配了 IP 段。</p><p><strong>2、自定义 IP 段</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@qcloud ~]# docker network create --driver bridge --subnet 192.168.4.0/24 --gateway 192.168.4.1 net_b</span><br></pre></td></tr></table></figure><p>查看具体属性：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@qcloud ~]# docker network inspect net_b</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;net_b&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;bb8dfbced7b2b38b47dc603abc010ca30888192d035eace29268baa035ba10f4&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2022-05-12T19:21:57.617051707+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;192.168.4.0/24&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;192.168.4.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>3、运行容器并指定自定义网络</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@qcloud ~]# docker run -it --network=net_b busybox</span><br><span class="line">/ # ifconfig </span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:C0:A8:04:02  </span><br><span class="line">          inet addr:192.168.4.2  Bcast:192.168.4.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:9 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:766 (766.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br></pre></td></tr></table></figure><p>既然我可以自定义网络模式，那我可不可以运行容器时指定一个静态 IP？</p><p><code>答案是可以的</code>，但前提是你这个网络必须是 <code>--subnet</code> 指定网段方式的自定义网络模式才行，具体如下：</p><ul><li><p>未使用 –subnet 指定网段的网络模式</p><blockquote><p>这种情况下是无法指定静态 IP 的，会报错。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@qcloud ~]# docker run -it --network=net_a --ip 172.18.0.5 busybox</span><br><span class="line">docker: Error response from daemon: user specified IP address is supported only when connecting to networks with user configured subnets.</span><br></pre></td></tr></table></figure></li><li><p>使用 –subnet 指定网段的网络模式</p><blockquote><p>这种情况下可以指定静态 IP。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@qcloud ~]# docker run -it --network=net_b --ip 192.168.4.191 busybox</span><br><span class="line">/ # ifconfig </span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:C0:A8:04:BF  </span><br><span class="line">          inet addr:192.168.4.191  Bcast:192.168.4.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:7 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:586 (586.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br></pre></td></tr></table></figure></li></ul><p> 对于自定义的 Bridge 类型网络模式，你每定义一个，Docker 都会将默认的 IP 网段（172.17.0.0&#x2F;16）往上加 1（除非是你自定义IP段）。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">172.17.0.0/16</span><br><span class="line">172.18.0.0/16</span><br><span class="line">172.19.0.0/16</span><br><span class="line">172.20.0.0/16</span><br><span class="line">172.21.0.0/16</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 资源分配与限制</title>
      <link href="/posts/articles/3767a45b.html"/>
      <url>/posts/articles/3767a45b.html</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-资源分配与限制"><a href="#Docker-资源分配与限制" class="headerlink" title="Docker 资源分配与限制"></a>Docker 资源分配与限制</h1><blockquote><p>我的宿主机：1C&#x2F;2G 50G 配置</p></blockquote><h2 id="1、CPU"><a href="#1、CPU" class="headerlink" title="1、CPU"></a>1、CPU</h2><p>默认情况下所有容器平等使用 Host 宿主机 CPU 资源，Docker 通过 -c 或 –cpu-shares 参数来指定容器使用 <code>CPU 的权重</code>。如果在运行容器时不指定，则权重值默认为 1024。接下来启动两个容器来做测试：</p><p>A 容器：权重1024</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name=cpu_a -c 1024 progrium/stress --cpu 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--cpu：表示工作线程数</span></span><br></pre></td></tr></table></figure><p>B 容器：权重512</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name=cpu_b -c 512 progrium/stress --cpu 1</span><br></pre></td></tr></table></figure><p>top 查看宿主机的 CPU 资源消耗情况：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230330212623142.png" alt="image-20230330212623142"></p><ul><li>66.3 为 A 容器消耗的 CPU</li><li>33.0 为 B 容器消耗的 CPU</li></ul><p>通过上图结果，那是不是表明权重值越高，占用 CPU 的时间就越多呢？</p><p>这并不一定，一般这种按权重分配 CPU 只会发生在 CPU 资源紧张的情况下，怎么理解呢，如果 A 容器处于空闲状态，此时为了 CPU 资源的充分利用，B 容器也可以分到全部可用 CPU。</p><p>此时，如果我停掉权重为 1024 的容器 cpu_a，再来看看权重为 512 的容器 cpu_b 占用的 CPU：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pause cpu_a</span><br></pre></td></tr></table></figure><p>top 查看宿主机的 CPU 资源消耗情况：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230330212644117.png" alt="image-20230330212644117"></p><p>可以看到，尽管我的容器 B 的权重值为 512，但如果比容器 B 容器大的其他容器不占用 CPU 或对 CPU 的占用少时，权重小的容器依然能够充分利用 CPU 资源。</p><h2 id="2、内存"><a href="#2、内存" class="headerlink" title="2、内存"></a>2、内存</h2><p>默认情况下 Docker 运行的容器对宿主机的<code>物理内存/swap交换内存</code>的使用是无限制的，为了避免过多容器使用过多内存导致 Host 的资源消耗殆尽，因此我们需要按照实际情况来对容器进行合理的<code>物理内存/swap交换内存</code>分配。具体分配指令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -m 200M --memory-swap=300M &lt;image&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">【-m（或--memory）：物理内存】表示该容器允许使用的最大物理内存。默认值为-1，表示无限制</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">【--memory-swap：物理内存+虚拟内存】表示该容器允许使用的最大 swap 交换内存。默认值为-1，表示无限制</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -m 200M --memory-swap=300M centos:7.9.2009</span><br></pre></td></tr></table></figure><p>需注意的是：</p><ul><li>如果只指定 -m，则 –memory-swap 默认为 -m 的两倍；</li><li>如果 -m 的值等于 –memory-swap 的值，那将无法使用 swap 交换分区。</li></ul><p>我们可以使用 progrium&#x2F;stress 镜像来进行压力测试：</p><ul><li><p>启动一个内存工作线程，且每个线程分配 280M 内存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@qcloud opt]# docker run -it -m 200M --memory-swap=300M progrium/stress --vm 1 --vm-bytes 280M</span><br><span class="line">stress: info: [1] dispatching hogs: 0 cpu, 0 io, 1 vm, 0 hdd</span><br><span class="line">stress: dbug: [1] using backoff sleep of 3000us</span><br><span class="line">stress: dbug: [1] --&gt; hogvm worker 1 [6] forked</span><br><span class="line">stress: dbug: [6] allocating 293601280 bytes ...</span><br><span class="line">stress: dbug: [6] touching bytes in strides of 4096 bytes ...</span><br><span class="line">stress: dbug: [6] freed 293601280 bytes</span><br><span class="line">stress: dbug: [6] allocating 293601280 bytes ...</span><br><span class="line">stress: dbug: [6] touching bytes in strides of 4096 bytes ...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--vm：指定内存工作线程数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--vm-bytes：指定每个内存工作线程数分配的大小</span></span><br></pre></td></tr></table></figure></li><li><p>模拟内存分配超过指定的可使用内存大小</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@qcloud opt]# docker run -it -m 200M --memory-swap=300M progrium/stress --vm 1 --vm-bytes 310M</span><br><span class="line">stress: info: [1] dispatching hogs: 0 cpu, 0 io, 1 vm, 0 hdd</span><br><span class="line">stress: dbug: [1] using backoff sleep of 3000us</span><br><span class="line">stress: dbug: [1] --&gt; hogvm worker 1 [6] forked</span><br><span class="line">stress: dbug: [6] allocating 325058560 bytes ...</span><br><span class="line">stress: dbug: [6] touching bytes in strides of 4096 bytes ...</span><br><span class="line">stress: FAIL: [1] (416) &lt;-- worker 6 got signal 9</span><br><span class="line">stress: WARN: [1] (418) now reaping child worker processes</span><br><span class="line">stress: FAIL: [1] (422) kill error: No such process</span><br><span class="line">stress: FAIL: [1] (452) failed run completed in 1s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可看到 <span class="built_in">kill</span> error: No such process</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="3、磁盘"><a href="#3、磁盘" class="headerlink" title="3、磁盘"></a>3、磁盘</h2><p>这里主要说的是磁盘 IO 读写情况，默认情况下，所有容器平等读写宿主机磁盘，与 CPU 资源类似，也是通过 –blkio-weight 参数设置权重值（<code>默认为 500</code>）来分配宿主机资源。启动两个容器来做测试：</p><p>A 容器：权重600</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name disk_a --blkio-weight 600 centos:7.9.2009</span><br></pre></td></tr></table></figure><p>B 容器：权重300</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name disk_b --blkio-weight 300 centos:7.9.2009</span><br></pre></td></tr></table></figure><p>与 CPU 资源利用类似，A 容器磁盘读写带宽为 B 容器的两倍数。</p><p><strong>如何限制 bps 和 iops ？</strong></p><blockquote><p>bps：每秒读写数据量</p><p>iops：每秒 IO 次数</p></blockquote><ul><li>--device-read-bps</li><li>--device-write-bps</li><li>--device-read-iops</li><li>--device-write-iops</li></ul><p>具体案例：</p><ul><li><p>限制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">限制容器使用宿主机的磁盘IO</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/dev/vda 为宿主机的磁盘设备，限制该容器每秒最多可向宿主机写30MB的数据</span></span><br><span class="line"></span><br><span class="line">[root@qcloud test]# docker run -it --device-write-bps /dev/vda:30MB centos:7.9.2009</span><br><span class="line">[root@03e61211de28 /]# time dd if=/dev/zero of=test_file.out bs=1M count=1000 oflag=direct</span><br><span class="line">1000+0 records in</span><br><span class="line">1000+0 records out</span><br><span class="line">1048576000 bytes (1.0 GB) copied, 33.3441 s, 31.4 MB/s</span><br><span class="line"></span><br><span class="line">real0m33.353s</span><br><span class="line">user0m0.003s</span><br><span class="line">sys0m0.224s</span><br></pre></td></tr></table></figure><blockquote><p>从结果可看出，基本在30MB左右。</p></blockquote></li><li><p>不限制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@qcloud test]# docker run -it centos:7.9.2009</span><br><span class="line">[root@fa7ff773d45e /]# time dd if=/dev/zero of=test_file.out bs=1M count=1000 oflag=direct</span><br><span class="line">1000+0 records in</span><br><span class="line">1000+0 records out</span><br><span class="line">1048576000 bytes (1.0 GB) copied, 22.8758 s, 45.8 MB/s</span><br><span class="line"></span><br><span class="line">real0m22.877s</span><br><span class="line">user0m0.010s</span><br><span class="line">sys0m0.276s</span><br></pre></td></tr></table></figure><blockquote><p>从结果可看出，不做限制的情况下，基本在45MB以上甚至更高。</p></blockquote></li></ul><p>其他参数类似。</p><p><mark>那以上配置的资源信息存储在 Host 哪个位置呢？如CPU资源</mark></p><blockquote><p>其目录在 <code>/sys/fs/cgroup/cpu/docker/*</code> 下<br>该目录下会对应有一个以正在运行的容器长ID为名的目录<br>其他资源同理：<code>/sys/fs/cgroup/blkio/docker/*</code>、<code>/sys/fs/cgroup/memory/docker/*</code></p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220907141842911.png" alt="image-20220907141842911"></p><p>如：CPU 的资源限制（权重或大小）就在这个长ID目录下的 cpu.shares 文件，可查看该值大小，且该值大小就是我们 –cpu-shares 指定的值。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220907142515237.png" alt="image-20220907142515237"></p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 的 Copy-on-Write 特性</title>
      <link href="/posts/articles/1fb9a4a3.html"/>
      <url>/posts/articles/1fb9a4a3.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、疑问"><a href="#一、疑问" class="headerlink" title="一、疑问"></a>一、疑问</h2><p>一个基础镜像可以运行一个容器，那可不可以一个基础镜像运行多个容器呢？答案是可以的。</p><p>那如果一个基础镜像运行多个容器后，我在某个容器上修改了基础镜像的内容，如：删除 &#x2F;etc&#x2F;hello.conf（假设我的基础镜像是有 hello.conf 文件的）文件，是否共用我基础镜像的其他容器的 &#x2F;etc&#x2F;hello.conf 文件也被删除了呢？答案是不会的。</p><h2 id="二、解答"><a href="#二、解答" class="headerlink" title="二、解答"></a>二、解答</h2><p>上面的问题其实应用到了 Docker 的 <code>Copy-on-Write</code> 特性，我们来看看这是怎么回事呢？</p><p>当某个容器启动时，一个新的可写层会被加载到其基础镜像的顶部，我们称之为“容器层”，所有添加、删除均发生在“容器层之中”。“容器层”之下的均为镜像层，最底部的镜像又称“基础镜像”层。</p><p>当在容器中进行数据修改时（比如修改 &#x2F;etc&#x2F;hello.conf 文件），Dockers 会从上至下依次在各个镜像层中查找此文件，一旦找到该文件，会立即将其复制到“容器层”，然后再进行修改操作（也就是 <code>Copy-on-Write</code>），其他的操作也是一样（如添加、读取、删除等操作）。<code>因此，“容器层”保存的是镜像变化的部分，而不会对镜像本身进行任何修改。</code></p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 运行的容器的内核版本是谁的？</title>
      <link href="/posts/articles/abf826c0.html"/>
      <url>/posts/articles/abf826c0.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、疑问"><a href="#一、疑问" class="headerlink" title="一、疑问"></a>一、疑问</h2><p>有没有想过这样一个问题，CentOS 7 系统版本的内核版本为 3.x.x，Ubuntu 18、CentOS 8 等系统版本的内核版本为 4.x.x。那如果我是在 CentOS 8 系统上运行 Dockers 容器（如 CentOS 7 ），运行的这个容器的内核版本会是多少呢？</p><h2 id="二、解答"><a href="#二、解答" class="headerlink" title="二、解答"></a>二、解答</h2><p>在上一篇文章<a href="https://blog.csdn.net/IT_ZRS/article/details/124682432?spm=1001.2014.3001.5502">《为什么运行一个 CentOS 容器的镜像只需 200MB 左右？》</a>中讲到，对于容器的镜像来说，底层直接使用宿主机的内核空间，它只需提供用户空间 rootfs 文件系统即可。因此，Docker 运行的容器的内核版本就是你宿主机（CentOS 8）的内核版本。实践出真理，接下来我们实际测试一下。</p><p>1、查看宿主机系统版本及内核版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@qcloud ~]# cat /etc/redhat-release </span><br><span class="line">CentOS Linux release 8.3.2011</span><br><span class="line">[root@qcloud ~]# uname -a</span><br><span class="line">Linux qcloud 4.18.0-240.el8.x86_64 #1 SMP Fri Sep 25 19:48:47 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><p>2、在上述的宿主机上运行 CentOS 7 容器并查看其内核版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@qcloud ~]# docker run -it centos:7.9.2009</span><br><span class="line">[root@74ecee4db934 /]# uname -a</span><br><span class="line">Linux 74ecee4db934 4.18.0-240.el8.x86_64 #1 SMP Fri Sep 25 19:48:47 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><p>从测试结果可看出，运行的 CentOS 7 容器的内核版本为 4.18，证明<code>对于容器的镜像来说，底层直接使用宿主机的内核空间</code>这句话是完全没问题的。</p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8s 探针</title>
      <link href="/posts/articles/d2d57643.html"/>
      <url>/posts/articles/d2d57643.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/k8s-cert.png" alt="k8s-cert"></p><p><a href="https://huaweicloud.csdn.net/63311d87d3efff3090b52a95.html?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~activity-5-123894868-blog-126919159.pc_relevant_3mothn_strategy_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~activity-5-123894868-blog-126919159.pc_relevant_3mothn_strategy_recovery&utm_relevant_index=10">参考1</a></p><p><a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/">官方参考文档</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>玩过 <code>Docker Swarm</code> 的应该都知道，有一种功能叫<code>自愈功能</code>，当集群检测到节点或服务故障时回进行自动故障转移，从而保障业务的可用性。而 K8s 集群相对于其他集群体系，其自愈能力更加强大，这也是 K8s 容器编排引擎的一重要特性。自愈从某种角度上来讲，其实现了以下几几种功能特性：</p><ul><li>零停机部署；</li><li>避免无效镜像；</li><li>实现滚动升级与回退。</li></ul><p>K8s 有三种探针，分别是：<code>存活（Liveness）</code>、<code>就绪（Readiness）</code>和<code>启动（Startup）</code></p><ul><li><p><strong>存活（Liveness）</strong>：kubelet 使用存活探针来确定什么时候要重启容器。 例如，存活探针可以探测到应用死锁（应用程序在运行，但是无法继续执行后面的步骤）情况。 重启这种状态下的容器有助于提高应用的可用性，即使其中存在缺陷。</p></li><li><p><strong>就绪（Readiness）</strong>：kubelet 使用就绪探针可以知道容器何时准备好接受请求流量。当一个 Pod 内的所有容器都就绪时，才能认为该 Pod 就绪。 这种信号的一个用途就是控制哪个 Pod 作为 Service 的后端。 若 Pod 尚未就绪，会被从 Service 的负载均衡器中剔除。</p></li><li><p><strong>启动（Startup）</strong>：kubelet 使用启动探针来了解应用容器何时启动。 如果配置了这类探针，你就可以控制容器在启动成功后再进行存活性和就绪态检查， 确保这些存活、就绪探针不会影响应用的启动。 启动探针可以用于对慢启动容器进行存活性检测，避免它们在启动运行之前就被杀掉。</p></li></ul><p>K8s 探针有三种探测方式，分别是：<code>ExecAction</code>、<code>HTTPGetAction</code> 和 <code>TCPSocketAction</code>，这三种探测方式只能同时使用一种，不能两种或三种同时使用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExecAction：      <span class="comment"># 在容器中执行指定的命令，如果执行成功，退出码为0则探测成功。</span></span><br><span class="line">HTTPGetAction：   <span class="comment"># 通过容器的IP地址、端口号及路径调用HTTP Get方法，如果响应的状态码大于等于200且小于400，则认为容器健康。</span></span><br><span class="line">TCPSocketAction： <span class="comment"># 通过容器的IP地址和端口号执行TCP检查，如果能够建立TCP连接，则表明容器健康。</span></span><br></pre></td></tr></table></figure><blockquote><p>探针探测的结果有以下值：</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Success：  <span class="comment"># 表示通过检测。</span></span><br><span class="line">Failure：  <span class="comment"># 表示未通过检测。</span></span><br><span class="line">Unknown：  <span class="comment"># 表示检测没有正常进行。</span></span><br></pre></td></tr></table></figure><h2 id="一、默认健康检测"><a href="#一、默认健康检测" class="headerlink" title="一、默认健康检测"></a>一、默认健康检测</h2><h3 id="1-1-restartPolicy"><a href="#1-1-restartPolicy" class="headerlink" title="1.1 restartPolicy"></a>1.1 restartPolicy</h3><p>了解 Docker 的都知道，每个容器启动时都会执行一个进程，该进程由 Dockerfile 的 CMD 或 ENTRYPOINT 指定。如果进程退出或返回状态码为非零时，则认为容器发生故障，这个时候 K8s 就会根据 <code>restartPolicy</code> 重启容器。<code>restartPolicy</code> 有三种重启策略：</p><ul><li><p><strong>Always</strong></p><p>Pod 中容器不论如何停止都将自动重启；</p></li><li><p><strong>OnFailure</strong><br>Pod 中容器非正常停止会自动重启，正常停止不会重启；</p></li><li><p><strong>Never</strong><br>Pod 中容器不论以任何方式停止，都不会自动重启。</p></li></ul><p>K8s 的  <code>restartPolicy</code>  默认为 <code>Always</code>。如果探针超过失败重试的次数，则 Pod 就会根据 restartPolicy 策略进行选择是否重启。</p><h3 id="1-2-测试案例"><a href="#1-2-测试案例" class="headerlink" title="1.2 测试案例"></a>1.2 测试案例</h3><p>1、创建一个 Pod</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    <span class="built_in">test</span>: healthcheck</span><br><span class="line">  name: healthcheck</span><br><span class="line">spec:</span><br><span class="line">  restartPolicy: OnFailure</span><br><span class="line">  containers:</span><br><span class="line">  - name: healthcheck</span><br><span class="line">    image: busybox</span><br><span class="line">    args:</span><br><span class="line">    - /bin/sh</span><br><span class="line">    - -c</span><br><span class="line">    - <span class="built_in">sleep</span> 10;<span class="built_in">exit</span> 1</span><br></pre></td></tr></table></figure><p>2、观察 Pod 状态</p><p>这个容器启动 10s 后会发生故障，接下来执行 <code>kubectl apply</code> 创建 Pod，Pod Name 为 healthcheck。过几分钟后看看 Pod 的状态：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221222110433382.png" alt="image-20221222110433382"></p><p>可看到已经重启了三次，该案例中容器进程返回值为非零，k8s 则认为容器发生故障，需要重启。但可能有些情况下发生了故障进程不退出的现象，如访问 Web 服务器时返回 500 错误代码，这可能是系统负荷较大或资源锁死，此时 httpd 进程并没有异常退出，这种情况下可直接重启容器。而 K8s 的 Liveness 机制刚好能解决此类问题（即出现此类问题会直接 Kill 掉容器并重新启动）。</p><h2 id="二、Liveness"><a href="#二、Liveness" class="headerlink" title="二、Liveness"></a>二、Liveness</h2><p>Liveness 探针让用户可以自定义判断容器是否健康的条件，如果探测失败，K8s 就会重启容器，如下案例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    <span class="built_in">test</span>: liveness</span><br><span class="line">  name: liveness-exec</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: liveness</span><br><span class="line">    image: busybox</span><br><span class="line">    args:</span><br><span class="line">    - /bin/sh</span><br><span class="line">    - -c</span><br><span class="line">    - <span class="built_in">touch</span> /tmp/healthy; <span class="built_in">sleep</span> 30; <span class="built_in">rm</span> -f /tmp/healthy; <span class="built_in">sleep</span> 600</span><br><span class="line">    livenessProbe:</span><br><span class="line">      <span class="built_in">exec</span>:</span><br><span class="line">        <span class="built_in">command</span>:</span><br><span class="line">        - <span class="built_in">cat</span></span><br><span class="line">        - /tmp/healthy</span><br><span class="line">      initialDelaySeconds: 5</span><br><span class="line">      periodSeconds: 5</span><br></pre></td></tr></table></figure><p>在这个配置文件中，可以看到 Pod 中只有一个 <code>Container</code>。 <code>periodSeconds</code> 字段指定了 kubelet 应该每 5 秒执行一次存活探测。 <code>initialDelaySeconds</code> 字段告诉 kubelet 在执行第一次探测前应该等待 5 秒（即 5 秒后才开始启动探针）。 kubelet 在容器内执行命令 <code>cat /tmp/healthy</code> 来进行探测。 如果命令执行成功并且返回值为 0，kubelet 就会认为这个容器是健康存活的。 如果这个命令返回非 0 值，kubelet 会杀死这个容器并重新启动它。当容器启动时，会执行如下的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh -c &quot;touch /tmp/healthy; sleep 30; rm -f /tmp/healthy; sleep 600&quot;</span><br></pre></td></tr></table></figure><p>这个容器生命的前 30 秒，<code>/tmp/healthy</code> 文件是存在的。 所以在这最开始的 30 秒内，执行命令 <code>cat /tmp/healthy</code> 会返回成功代码。 30 秒之后，执行命令 <code>cat /tmp/healthy</code> 就会返回失败代码。</p><p>执行 <code>kubectl apply</code> 创建 Pod 。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f liveness.yml</span><br></pre></td></tr></table></figure><p>查看 Pod 启动日志：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod liveness-exec</span><br></pre></td></tr></table></figure><p>前 30s <code>/tmp/healthy</code> 文件是存在的：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221222113744208.png" alt="image-20221222113744208"></p><p>35s 后检测到<code>/tmp/healthy</code> 文件已经不存在：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221222114051362.png" alt="image-20221222114051362"></p><p>再过十几秒后容器被重启：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221222114308594.png" alt="image-20221222114308594"></p><h2 id="三、Readiness"><a href="#三、Readiness" class="headerlink" title="三、Readiness"></a>三、Readiness</h2><p>除了可以自定义判断容器是否健康的条件外，用户也可以通过 <code>Readiness</code> 探针告诉 K8s 什么时候可以重启容器实现自愈，<code>Readiness</code> 探针则告诉 K8s 什么时候可以将容器加入到 Service 负载均衡池中，对外提供服务。就绪探针的配置和存活探针的配置相似。 唯一区别就是要使用 <code>readinessProbe</code> 字段，而不是 <code>livenessProbe</code> 字段。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    <span class="built_in">test</span>: readiness</span><br><span class="line">  name: readiness-exec</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: liveness</span><br><span class="line">    image: busybox</span><br><span class="line">    args:</span><br><span class="line">    - /bin/sh</span><br><span class="line">    - -c</span><br><span class="line">    - <span class="built_in">touch</span> /tmp/healthy; <span class="built_in">sleep</span> 30; <span class="built_in">rm</span> -f /tmp/healthy; <span class="built_in">sleep</span> 600</span><br><span class="line">    readinessProbe:</span><br><span class="line">      <span class="built_in">exec</span>:</span><br><span class="line">        <span class="built_in">command</span>:</span><br><span class="line">        - <span class="built_in">cat</span></span><br><span class="line">        - /tmp/healthy</span><br><span class="line">      initialDelaySeconds: 5</span><br><span class="line">      periodSeconds: 5</span><br></pre></td></tr></table></figure><p>看看启动日志，与 <code>Liveness</code> 探针类似</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod readiness-exec</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221222121220005.png" alt="image-20221222121220005"></p><p>Probe 有很多配置字段，可以使用这些字段精确地控制启动、存活和就绪检测的行为：</p><ul><li><code>initialDelaySeconds</code>：容器启动后要等待多少秒后才启动启动、存活和就绪探针， 默认是 0 秒，最小值是 0。</li><li><code>periodSeconds</code>：执行探测的时间间隔（单位是秒）。默认是 10 秒。最小值是 1。</li><li><code>timeoutSeconds</code>：探测的超时后等待多少秒。默认值是 1 秒。最小值是 1。</li><li><code>successThreshold</code>：探针在失败后，被视为成功的最小连续成功数。默认值是 1。 存活和启动探测的这个值必须是 1。最小值是 1。</li><li><code>failureThreshold</code>：当探测失败时，Kubernetes 的重试次数。 对存活探测而言，放弃就意味着重新启动容器。 对就绪探测而言，放弃意味着 Pod 会被打上未就绪的标签。默认值是 3。最小值是 1。</li></ul><p><mark>注意</mark>：存活探针 <strong>不等待</strong> 就绪性探针成功。如果要在执行存活探针之前等待就绪性探针，应该使用 <code>initialDelaySeconds</code> 或 <code>startupProbe</code>。</p><h2 id="四、Startup"><a href="#四、Startup" class="headerlink" title="四、Startup"></a>四、Startup</h2><p>Startup 是 <code>k8s 1.16+</code> 版本后新加的探测方式，用于判断容器内应用程序是否已经启动，如果同时配置了 <code>startuprobe</code>、<code>Livenessprobe</code>、<code>Readinessprobe</code>，K8s 就会先禁用其他的探针，而首先使用 <code>startuprobe </code>探测直到它成功为止，成功后将不再进行探测。</p><p><strong>startupProbe 探针与另两种区别？</strong></p><ul><li><p>如果三个探针同时存在，先执行startupProbe探针，其他两个探针将会被暂时禁用，直到pod满足startupProbe探针配置的条件，其他2个探针启动，如果不满足按照规则重启容器。</p></li><li><p>另外两种探针在容器启动后，会按照配置，直到容器消亡才停止探测，而startupProbe探针只是在容器启动后按照配置满足一次后，不在进行后续的探测。</p></li></ul><p><mark>那 Startup 存在的意义又是什么呢？</mark></p><p>试想一个问题，如果启动一个服务需要 1 分钟，如果没有 <code>Startup</code> 的情况下，且假设我们配置了 <code>livenessProbe</code> 探针，具体如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">livenessProbe:</span><br><span class="line">  httpGet:</span><br><span class="line">    path: /test</span><br><span class="line">    prot: 80</span><br><span class="line">failureThreshold: 6</span><br><span class="line">initialDelay：40</span><br><span class="line">periodSeconds: 5</span><br></pre></td></tr></table></figure><p>我们设置了失败重试次数为 6，每 5 秒探测一次，加上我们探测前等待的 40 秒，总时间就是：40 + 6 x 5 &#x3D; 70s，这样 Pod 确实能够启动起来。那问题又来了，如果这个配置用于生产配置上，将会导致我们比较晚的收到服务不可用的情况，也就是说我的服务可能在 5s 时已经不可用，但是由于我们探测机制（有 6 次失败重试的机会），我们在至少 6 x 5 &#x3D; 30s 才会发现服务不可用的情况，这在生产上一般是不被允许的。<strong>那该如何解决类似这样的问题呢？</strong>答案就是 <code>startupProbe</code>。</p><blockquote><p>注意上面这个案例，如果 <code>failureThreshold</code> 设置为 1 或 2，那这个服务是永远起不起来的，因为你把 <code>initialDelay</code> 的时间算上也不足 1 分钟，因为我们说启动至少需要 1 分钟，那超过失败重试次数后，就会根据 Pod 的 <code>restartPolicy</code> 来重启容器。</p></blockquote><p>接着我们引入 <code>startupProbe</code>，继续优化：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">livenessProbe:</span><br><span class="line">  httpGet:</span><br><span class="line">    path: /test</span><br><span class="line">    prot: 80</span><br><span class="line">failureThreshold: 1</span><br><span class="line">initialDelaySeconds：5</span><br><span class="line">periodSeconds: 5</span><br><span class="line"></span><br><span class="line">startupProbe:</span><br><span class="line">  httpGet:</span><br><span class="line">    path: /test</span><br><span class="line">    prot: 80</span><br><span class="line">failureThreshold: 60</span><br><span class="line">initialDelaySeconds：5</span><br><span class="line">periodSeconds: 5</span><br></pre></td></tr></table></figure><p>前面说了，<code>startupProbe</code> 会在探测成功后停止探测，而其他两种探针则是随着 Pod 的生命周期一直在探测的。因此上面的配置功能就是：K8s 部署服务后会在 5s 后启动 <code>startupProbe</code>，在 5 x 60 &#x3D; 300s 的时间内只要成功探测到服务则停止探测（否则需接受 Pod 的重启策略进行重启），并启用 <code>livenessProbe</code> 探针，此时<code>livenessProbe</code> 探针就会伴随着 Pod 的生命周期每 5s 检测一次，且我们只设置了 1 次失败重试的机会，这就意味着我们只需要在 1 x 5 &#x3D; 5s 时间就可以发现服务不可用。因此，你配置了 <code>startupProbe</code>，那其他2种探针如果配置了<code>initialDelaySeconds</code>，建议时间就不要给太长。<mark>这就是 Startup 探针存在的意义。</mark></p><h2 id="五、应用场景"><a href="#五、应用场景" class="headerlink" title="五、应用场景"></a>五、应用场景</h2><p>从上面的实验来看，探针的作用是很明显的，那这些探针在实际工作中是如何应用的呢？</p><h3 id="5-1-在-Scale-Up-中的应用"><a href="#5-1-在-Scale-Up-中的应用" class="headerlink" title="5.1 在 Scale Up 中的应用"></a>5.1 在 Scale Up 中的应用</h3><p>当我们执行 <code>Scale Up</code> 操作时（如新增副本数），新副本会作为 backend 被添加到 Service 的负载均衡中，与已有的副本一起处理客户的请求。考虑到应用启动通常都需要一个准备阶段，如加载缓存数据、连接数据库等，也就是说从容器启动到真正能够提供服务是需要一段时间的，此时，我们就可以通过 Readiness 探测判断容器是否就绪，避免将请求发送到还没准备好的 backend。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      run: web</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        run: web</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: web</span><br><span class="line">        image: httpd</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">        readinessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            scheme: HTTP</span><br><span class="line">            path: /</span><br><span class="line">            port: 80</span><br><span class="line">          initialDelaySeconds: 5</span><br><span class="line">          periodSeconds: 5</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: web-svc</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    run: web</span><br><span class="line">  ports:</span><br><span class="line">  - protocol: TCP</span><br><span class="line">    port: 80</span><br><span class="line">    targetPort: 80</span><br></pre></td></tr></table></figure><blockquote><p>查看 Pod 是否正常</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221227102346704.png" alt="image-20221227102346704"></p><blockquote><p>查看 Service 资源</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221227102527625.png" alt="image-20221227102527625"></p><blockquote><p>集群请求验证</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221227102754960.png" alt="image-20221227102754960"></p><p>因此不难看出，就绪探针的好处就是，只有等待 Pod 完全就绪后才会接收来自客户端的请求。</p><p>完整流程就是：</p><ul><li>容器启动 5s 后开始进行就绪探测；</li><li>如果 GET 请求的 <a href="http://container_ip/">http://container_ip:80/</a> 返回代码不是 200~400，则表示容器没就绪，此时该容器不接收 Service web-svc 的请求；</li><li>之后会每隔 5s 探测一次；</li><li>直到 GET 请求的 <a href="http://container_ip/">http://container_ip:80/</a> 返回代码为 200~400，则表示容器已经就绪，此时该容器将加入到 web-svc 的负载均衡中，开始处理客户的请求；</li><li>探针还会继续以 5s 的时间间隔探测，如果连续发生 3 次失败（YAML 文件中未指定，默认为 3 次，可通过 <code>failureThreshold</code> 来指定），容器又会从负载均衡中移除，直到下次探测成功再重新加入。</li></ul><p><mark>注意，这里我没有做 NodePort 类型哦，但并不影响我们的实验。</mark></p><h3 id="5-2-在滚动更新中的应用"><a href="#5-2-在滚动更新中的应用" class="headerlink" title="5.2 在滚动更新中的应用"></a>5.2 在滚动更新中的应用</h3><p>还有一个比较重要的应用场景就是<code>滚动更新（Rolling Update）</code>，试想一下，现有一个正常运行的多副本应用，接下来对应用进行更新（如升级镜像版本），K8s 会启动新副本，就会存在一下两种情况：</p><ul><li>正常情况下新副本需要 10s 来完成准备工作，在此期间是无法响应业务请求的；</li><li>由于人为配置错误，副本始终无法完成准备工作（如无法连接后端数据库）。</li></ul><p>那如果出现以上的两种情况，且又没有配置探针的话，会出现什么问题呢？</p><p>新副本本身没有异常退出，那默认的健康检查机制就会认为容器已经就绪，进而就会逐步用新的副本替换现有的副本。最终结果就是：所有旧副本都被替换后，整个应用将无法对外提供服务，那这在生产上是绝对不允许的。</p><p>那如果配置了对应的探针机制后，新副本只有通过了 Readiness 探测才会被添加到 Service 中，如果没有通过探测，则现有副本就不会被全部替换（根据比例可能会替换部分），业务仍然正常进行。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim app-v1.yml</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: app</span><br><span class="line">spec:</span><br><span class="line">  replicas: 10</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      run: app</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        run: app</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: app</span><br><span class="line">        image: busybox</span><br><span class="line">        args:</span><br><span class="line">        - /bin/sh</span><br><span class="line">        - -c</span><br><span class="line">        - <span class="built_in">sleep</span> 10; <span class="built_in">touch</span> /tmp/healthy; <span class="built_in">sleep</span> 30000</span><br><span class="line">        readinessProbe:</span><br><span class="line">          <span class="built_in">exec</span>:</span><br><span class="line">            <span class="built_in">command</span>:</span><br><span class="line">            - <span class="built_in">cat</span></span><br><span class="line">            - /tmp/healthy</span><br><span class="line">          initialDelaySeconds: 10</span><br><span class="line">          periodSeconds: 5</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f app-v1.yml</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可看到10s后副本通过readinessProbe探测</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221227121011463.png" alt="image-20221227121011463"></p><p>接下来进行滚动更新应用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim app-v2.yml</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: app</span><br><span class="line">spec:</span><br><span class="line">  replicas: 10</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      run: app</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        run: app</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: app</span><br><span class="line">        image: busybox</span><br><span class="line">        args:</span><br><span class="line">        - /bin/sh</span><br><span class="line">        - -c</span><br><span class="line">        - <span class="built_in">sleep</span> 3000</span><br><span class="line">        readinessProbe:</span><br><span class="line">          <span class="built_in">exec</span>:</span><br><span class="line">            <span class="built_in">command</span>:</span><br><span class="line">            - <span class="built_in">cat</span></span><br><span class="line">            - /tmp/healthy</span><br><span class="line">          initialDelaySeconds: 10</span><br><span class="line">          periodSeconds: 5</span><br></pre></td></tr></table></figure><p>很显然，本次的更新的新副本中并没有 <code>/tmp/healthy</code> 文件，因此是无法通过 <code>readiness</code> 探测的，开始更新服务。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f app-v1.yml</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221227141219466.png" alt="image-20221227141219466"></p><p><mark>从 kubectl get pod 输出结果分析：</mark></p><ul><li>从启动时间（AGE）可判断，开头 5 个是新副本，出于 NOTREADY 状态；</li><li>旧副本从最初的 10 个减少到 8 个。</li></ul><p><mark>从 kubectl get deployment app 输出结果分析：</mark></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221227141624890.png" alt="image-20221227141624890"></p><ul><li>READY：就绪个数&#x2F;期望个数；</li><li>UP-TO-DATE：为了达到期望状态，已经更新的副本数；</li><li>AVAILABLE：可供用户使用的副本数。</li></ul><p>在我们的设定中，新副本始终都无法通过 Readiness 探测，所以这个状态会一直持续下去。对于 K8s 健康检查机制来说，它帮我们屏蔽了有缺陷的副本，同时保留了大部分旧副本，业务没有因为更新失败受到影响。</p><p><mark>为什么新创建的副本数是 5 个，同时只销毁了 2 个旧副本？</mark></p><p>原因是：滚动更新通过参数 <code>maxSurge</code> 和 <code>maxUnavailable</code> 来控制副本替换的数量。</p><p><strong>maxSurge</strong></p><p>此参数控制滚动更新过程中副本总数超过 <code>READY</code> 期望数的上限。maxSurge 可以是具体的整数，也可以是百分比，向上取整。若不指定，则 maxSurge 的默认值为 25%。</p><p>在上面的例子中，期望是 10，那副本总数的最大值为：10 + 10 x 25% &#x3D; 13，所以我们看到的 Pod 数为 13 个就是这么来的。</p><p><strong>maxUnavailable</strong></p><p>此参数控制滚动更新过程中，不可用的副本数占期望数的最大比例。maxUnavailable 可以是整数，也可以是百分比，向下取整。若不指定，则 maxUnavailable 的默认值为 25%。</p><p>在上面的例子中，期望是 10，那可用的副本数至少要为：10 - 10 x 25% &#x3D; 8，所以我们看到的 Pod 中只有 8 个是可用的。</p><p><mark>因此，理想情况下，我们这个案例的滚动更新过程是这样的：</mark></p><ul><li>创建 3 个新副本，使副本总数达到 13 个；</li><li>销毁 2 个旧副本，使可用副本数降到 8 个；</li><li>当 2 个旧副本销毁成功后，再创建 2 个新副本，使副本数保持为 13 个；</li><li>当新副本通过 Readiness 探测后，会使可用副本数增加，超过 8 个；</li><li>进而可继续销毁更多的旧副本，使可用副本数回到 8 个；</li><li>旧副本的销毁会使副本总数低于 13，这样就允许创建更多的新副本；</li><li>这个过程会持续进行，直到所有的旧副本都被新副本替换，滚动更新才完成。</li></ul><p>而上面案例中，我们在第四步就卡主了，因为新的副本无法通过 Readiness 探测。这个过程可通过 Deployment 日志部分来查看。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe deployment app</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221227150137960.png" alt="image-20221227150137960"></p><p>因此，对于上面的滚动更新失败案例，我们想要恢复原来正常提供的服务，我们只需要进行回滚操作即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先看看可回滚的历史版本（revision）</span></span><br><span class="line">kubectl rollout <span class="built_in">history</span> deployment app</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221227150540721.png" alt="image-20221227150540721"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看revision的详情</span></span><br><span class="line">kubectl rollout <span class="built_in">history</span> deployment app --revision=1</span><br><span class="line">kubectl rollout <span class="built_in">history</span> deployment app --revision=2</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221227150744680.png" alt="image-20221227150744680"></p><p>很明显，<code>revision = 1</code> 就是我们最初的版本，我们只需要回滚到这个版本上即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout undo deployment app --to-revision=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可看到，之前被销毁的两个Pod已经启动且为可用状态</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221227151243160.png" alt="image-20221227151243160"></p><p><mark>如何在 YAML 文件中指定 maxSurge 和 maxUnavailable？</mark></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: app</span><br><span class="line">spec:</span><br><span class="line">  strategy:</span><br><span class="line">    rollingUpdate:</span><br><span class="line">      maxSurge: 35%</span><br><span class="line">      maxUnavailable: 35%</span><br><span class="line">  replicas: 10</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      run: app</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        run: app</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: app</span><br><span class="line">        image: busybox</span><br><span class="line">        args:</span><br><span class="line">        - /bin/sh</span><br><span class="line">        - -c</span><br><span class="line">        - <span class="built_in">sleep</span> 10; <span class="built_in">touch</span> /tmp/healthy; <span class="built_in">sleep</span> 30000</span><br><span class="line">        readinessProbe:</span><br><span class="line">          <span class="built_in">exec</span>:</span><br><span class="line">            <span class="built_in">command</span>:</span><br><span class="line">            - <span class="built_in">cat</span></span><br><span class="line">            - /tmp/healthy</span><br><span class="line">          initialDelaySeconds: 10</span><br><span class="line">          periodSeconds: 5</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> K8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8s </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubeadm 部署 k8s 集群</title>
      <link href="/posts/articles/82357013.html"/>
      <url>/posts/articles/82357013.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/k8s-cert.png" alt="k8s-cert"></p><p>K8s 版本：1.23</p><hr><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><p><strong>1、服务器配置</strong></p><table><thead><tr><th>OS</th><th>配置</th><th>用途</th></tr></thead><tbody><tr><td>CentOS 7.9（172.27.0.13）</td><td>2C&#x2F;4G</td><td>k8s-master</td></tr><tr><td>CentOS 7.9（172.27.0.10）</td><td>2C&#x2F;4G</td><td>k8s-work1</td></tr><tr><td>CentOS 7.9（172.27.0.11）</td><td>2C&#x2F;4G</td><td>k8s-work2</td></tr></tbody></table><p><strong>注</strong>：这是演示 k8s 集群安装的实验环境，配置较低，生产环境中我们的服务器配置至少都是 <code>8C/16G</code> 的基础配置。</p><p><strong>2、版本选择</strong></p><ul><li>CentOS：7.9+</li><li>k8s组件版本：1.23.6（当前最新）</li></ul><h2 id="一、服务器基础配置"><a href="#一、服务器基础配置" class="headerlink" title="一、服务器基础配置"></a>一、服务器基础配置</h2><p><strong>1、配置主机名</strong></p><blockquote><p>所有节点执行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server ~]# hostnamectl set-hostname k8s-master</span><br><span class="line">[root@server ~]# hostnamectl set-hostname k8s-work1</span><br><span class="line">[root@server ~]# hostnamectl set-hostname k8s-work2</span><br></pre></td></tr></table></figure><p><strong>2、关闭防火墙</strong></p><blockquote><p>所有节点执行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭firewalld</span></span><br><span class="line">[root@k8s-master ~]# systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭selinux</span></span><br><span class="line">[root@k8s-master ~]# sed -i &#x27;s/enforcing/disabled/&#x27; /etc/selinux/config</span><br><span class="line">[root@k8s-master ~]# setenforce 0</span><br></pre></td></tr></table></figure><p><strong>3、互做本地解析</strong></p><blockquote><p>所有节点执行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# vim /etc/hosts</span><br><span class="line"></span><br><span class="line">172.27.0.13 k8s-master</span><br><span class="line">172.27.0.10 k8s-work1</span><br><span class="line">172.27.0.11 k8s-work2</span><br></pre></td></tr></table></figure><p><strong>4、SSH 免密通信（可选）</strong></p><blockquote><p>所有节点执行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# ssh-keygen </span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/root/.ssh/id_rsa): </span><br><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved in /root/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /root/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:qmMRk/pyFrxMRCqzeko/fPbVBzPYz1Em4u5cNR7dvzs root@k8s-master</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|                 |</span><br><span class="line">|    .            |</span><br><span class="line">|   o .     . . o |</span><br><span class="line">|o . =     + . + o|</span><br><span class="line">| + + o  S. * . +o|</span><br><span class="line">|. . =  .  o * + +|</span><br><span class="line">|...+ +.  . o = ..|</span><br><span class="line">|o +oO+  . o o  E.|</span><br><span class="line">|.o *=...   o   oo|</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure><blockquote><p>所有节点执行（互发公钥）</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# ssh-copy-id root@172.27.0.9</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: &quot;/root/.ssh/id_rsa.pub&quot;</span><br><span class="line">The authenticity of host &#x27;172.27.0.9 (172.27.0.9)&#x27; can&#x27;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:IzYTCZWXEv8rTdYYx+RdTyi+EJF2Jqggz0pT5v/oZwk.</span><br><span class="line">ECDSA key fingerprint is MD5:d0:89:66:b8:73:d0:eb:3b:19:cb:b2:3c:82:d0:a5:ff.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys</span><br><span class="line">root@172.27.0.9&#x27;s password: </span><br><span class="line"></span><br><span class="line">Number of key(s) added: 1</span><br><span class="line"></span><br><span class="line">Now try logging into the machine, with:   &quot;ssh &#x27;root@172.27.0.9&#x27;&quot;</span><br><span class="line">and check to make sure that only the key(s) you wanted were added.</span><br></pre></td></tr></table></figure><p><strong>5、加载 br_netfilter 模块</strong></p><blockquote><p>确保 br_netfilter 模块被加载<br>所有节点执行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载模块</span></span><br><span class="line">[root@k8s-master ~]# modprobe br_netfilter</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看加载请看</span></span><br><span class="line">[root@k8s-master ~]# lsmod | grep br_netfilter</span><br><span class="line">br_netfilter           22256  0 </span><br><span class="line">bridge                151336  1 br_netfilter</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久生效</span></span><br><span class="line">cat &lt;&lt;EOF | tee /etc/modules-load.d/k8s.conf</span><br><span class="line">br_netfilter</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p><strong>6、允许 iptables 检查桥接流量</strong></p><blockquote><p>所有节点执行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.conf</span><br><span class="line">br_netfilter</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">[root@k8s-master ~]# cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">[root@k8s-master ~]# sudo sysctl --system</span><br></pre></td></tr></table></figure><p><strong>7、关闭 swap</strong></p><blockquote><p>所有节点执行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时关闭</span></span><br><span class="line">[root@k8s-master ~]# swapoff -a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久关闭</span></span><br><span class="line">[root@k8s-master ~]# sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab</span><br></pre></td></tr></table></figure><p><strong>8、时间同步</strong></p><blockquote><p>所有节点执行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同步网络时间</span></span><br><span class="line">[root@k8s-master ~]# ntpdate time.nist.gov</span><br><span class="line">26 Apr 19:58:05 ntpdate[13947]: the NTP socket is in use, exiting</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将网络时间写入硬件时间</span></span><br><span class="line">[root@k8s-master ~]# hwclock --systohc</span><br></pre></td></tr></table></figure><p><strong>9、安装 Docker</strong></p><blockquote><p>所有节点执行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">过程略，需要 Docker 快速安装脚本的可私我。</span><br></pre></td></tr></table></figure><p><strong>10、安装 kubeadm、kubelet</strong></p><blockquote><p>所有节点执行</p></blockquote><ul><li><p>添加 k8s 镜像源</p><blockquote><p>地址：<a href="https://developer.aliyun.com/mirror/kubernetes?spm=a2c6h.13651102.0.0.1cd01b116JYQIn">https://developer.aliyun.com/mirror/kubernetes?spm=a2c6h.13651102.0.0.1cd01b116JYQIn</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>建立 k8s YUM 缓存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# yum makecache</span><br></pre></td></tr></table></figure></li><li><p>安装 k8s 相关工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看可安装版本</span></span><br><span class="line">[root@k8s-master ~]# yum list kubelet --showduplicates</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">kubelet.x86_64                                           1.23.0-0                                             kubernetes</span><br><span class="line">kubelet.x86_64                                           1.23.1-0                                             kubernetes</span><br><span class="line">kubelet.x86_64                                           1.23.2-0                                             kubernetes</span><br><span class="line">kubelet.x86_64                                           1.23.3-0                                             kubernetes</span><br><span class="line">kubelet.x86_64                                           1.23.4-0                                             kubernetes</span><br><span class="line">kubelet.x86_64                                           1.23.5-0                                             kubernetes</span><br><span class="line">kubelet.x86_64                                           1.23.6-0                                             kubernetes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始安装（指定你要安装的版本）</span></span><br><span class="line">[root@k8s-master ~]# yum install -y kubelet-1.23.6 kubeadm-1.23.6 kubectl-1.23.6</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置开机自启动并启动kubelet（kubelet由systemd管理）</span></span><br><span class="line">[root@k8s-master ~]# systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure></li></ul><h2 id="二、Master-节点"><a href="#二、Master-节点" class="headerlink" title="二、Master 节点"></a>二、Master 节点</h2><p><strong>1、k8s 初始化</strong></p><blockquote><p>Master 节点执行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# kubeadm init \</span><br><span class="line">  --apiserver-advertise-address=172.27.0.13 \</span><br><span class="line">  --image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">  --kubernetes-version v1.23.6 \</span><br><span class="line">  --service-cidr=10.96.0.0/12 \</span><br><span class="line">  --pod-network-cidr=10.244.0.0/16 \</span><br><span class="line">  --ignore-preflight-errors=all</span><br></pre></td></tr></table></figure><p>参数说明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--apiserver-advertise-address  # 集群master地址</span><br><span class="line">--image-repository             # 指定k8s镜像仓库地址（会从阿里的Registry下载组件的Docker镜像，不指定则默认为Google的Registry，但可能会pull镜像失败）</span><br><span class="line">--kubernetes-version           # 指定K8s版本（与kubeadm、kubelet版本保持一致）</span><br><span class="line">--service-cidr                 # Pod统一访问入口（即Service的IP地址池）</span><br><span class="line">--pod-network-cidr             # Pod网络（即Pod的IP地址池，与CNI网络保持一致）</span><br></pre></td></tr></table></figure><p>初始化后输出内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">...</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster</span><br><span class="line">[bootstrap-token] Creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace</span><br><span class="line">[kubelet-finalize] Updating &quot;/etc/kubernetes/kubelet.conf&quot; to point to a rotatable kubelet client certificate and key</span><br><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, if you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 172.27.0.13:6443 --token hgtxra.fccj35x2szia3r3c \</span><br><span class="line">--discovery-token-ca-cert-hash sha256:578cf5ca4cf588e3d84005d06f6503bf5d9ee25f63b0cfab4f78677a24b92bdd</span><br></pre></td></tr></table></figure><p><strong>2、根据输出提示创建相关文件</strong></p><blockquote><p>Master 节点执行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# mkdir -p $HOME/.kube</span><br><span class="line">[root@k8s-master ~]# cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">[root@k8s-master ~]# chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p><strong>3、查看 k8s 运行的容器</strong></p><blockquote><p>Master 节点执行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl get pods -n kube-system</span><br><span class="line">NAME                                 READY   STATUS    RESTARTS   AGE</span><br><span class="line">coredns-6d8c4cb4d-85dx9              0/1     Pending   0          53m</span><br><span class="line">coredns-6d8c4cb4d-f7wld              0/1     Pending   0          53m</span><br><span class="line">etcd-k8s-master                      1/1     Running   1          53m</span><br><span class="line">kube-apiserver-k8s-master            1/1     Running   1          53m</span><br><span class="line">kube-controller-manager-k8s-master   1/1     Running   1          53m</span><br><span class="line">kube-proxy-5mpdp                     1/1     Running   0          13m</span><br><span class="line">kube-proxy-9lp29                     1/1     Running   0          12m</span><br><span class="line">kube-proxy-9ttf6                     1/1     Running   0          53m</span><br><span class="line">kube-scheduler-k8s-master            1/1     Running   1          53m</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>4、查看 k8s 节点</strong></p><blockquote><p>Master 节点执行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl get nodes</span><br><span class="line">NAME         STATUS     ROLES                  AGE    VERSION</span><br><span class="line">k8s-master   NotReady   control-plane,master   8m9s   v1.23.6</span><br></pre></td></tr></table></figure><p>可看到当前只有 k8s-master 节点，而且状态是 NotReady（未就绪），因为我们还没有部署网络插件（<code>kubectl apply -f [podnetwork].yaml</code>），于是接着部署容器网络（CNI）。</p><p><strong>5、容器网络（CNI）部署</strong></p><blockquote><p>Master 节点执行<br>插件地址：<a href="https://kubernetes.io/docs/concepts/cluster-administration/addons/">https://kubernetes.io/docs/concepts/cluster-administration/addons/</a><br>该地址在 k8s-master 初始化成功时打印出来。</p></blockquote><ul><li><p>选择一个主流的容器网络插件部署（Calico）</p><p><img src="https://note.youdao.com/yws/res/17339/WEBRESOURCE2ed933b27228fe02892255f43ca7c0db" alt="image"></p></li><li><p>下载yml文件</p><blockquote><p>github地址：<a href="https://github.com/projectcalico/calico/blob/master/manifests/calico.yaml">https://github.com/projectcalico/calico/blob/master/manifests/calico.yaml</a><br>个人地址：<a href="https://k8s-config-rab.oss-cn-chengdu.aliyuncs.com/calico/v3.15.1/calico.yaml">https://k8s-config-rab.oss-cn-chengdu.aliyuncs.com/calico/v3.15.1/calico.yaml</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://docs.projectcalico.org/manifests/calico.yaml</span><br></pre></td></tr></table></figure></li><li><p>修改yaml配置</p></li></ul><p><img src="https://note.youdao.com/yws/res/17338/WEBRESOURCEc51e5f6651f8c4ab80e769324de2ef9e" alt="image"></p><p><img src="https://note.youdao.com/yws/res/17341/WEBRESOURCE04e66e523573eb30cbac25f3b3e6a974" alt="image"></p><ul><li><p>根据初始化的输出提示执行启动指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl apply -f calico.yaml</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/calico-kube-controllers created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/calico-node created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/calico-node created</span><br><span class="line">daemonset.apps/calico-node created</span><br><span class="line">serviceaccount/calico-node created</span><br><span class="line">deployment.apps/calico-kube-controllers created</span><br><span class="line">serviceaccount/calico-kube-controllers created</span><br><span class="line">Warning: policy/v1beta1 PodDisruptionBudget is deprecated in v1.21+, unavailable in v1.25+; use policy/v1 PodDisruptionBudget</span><br><span class="line">poddisruptionbudget.policy/calico-kube-controllers created</span><br></pre></td></tr></table></figure></li><li><p>看看该yaml文件所需要启动的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# cat calico.yaml |grep image</span><br><span class="line">          image: docker.io/calico/cni:v3.22.2</span><br><span class="line">          image: docker.io/calico/cni:v3.22.2</span><br><span class="line">          image: docker.io/calico/pod2daemon-flexvol:v3.22.2</span><br><span class="line">          image: docker.io/calico/node:v3.22.2</span><br><span class="line">          image: docker.io/calico/kube-controllers:v3.22.2</span><br></pre></td></tr></table></figure></li><li><p>查看容器是否都 Running</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl get pods -n kube-system</span><br><span class="line">NAME                                      READY   STATUS    RESTARTS   AGE</span><br><span class="line">calico-kube-controllers-7c845d499-rh7tb   1/1     Running   0          5m27s</span><br><span class="line">calico-node-fpdjb                         1/1     Running   0          5m28s</span><br><span class="line">calico-node-jsdf4                         1/1     Running   0          5m28s</span><br><span class="line">calico-node-kmpnr                         1/1     Running   0          5m28s</span><br><span class="line">coredns-6d8c4cb4d-85dx9                   1/1     Running   0          98m</span><br><span class="line">coredns-6d8c4cb4d-f7wld                   1/1     Running   0          98m</span><br><span class="line">etcd-k8s-master                           1/1     Running   1          99m</span><br><span class="line">kube-apiserver-k8s-master                 1/1     Running   1          99m</span><br><span class="line">kube-controller-manager-k8s-master        1/1     Running   1          99m</span><br><span class="line">kube-proxy-5mpdp                          1/1     Running   0          58m</span><br><span class="line">kube-proxy-9lp29                          1/1     Running   0          58m</span><br><span class="line">kube-proxy-9ttf6                          1/1     Running   0          98m</span><br><span class="line">kube-scheduler-k8s-master                 1/1     Running   1          99m</span><br></pre></td></tr></table></figure></li></ul><h2 id="三、work-节点"><a href="#三、work-节点" class="headerlink" title="三、work 节点"></a>三、work 节点</h2><p><strong>1、work 节点加入 k8s 集群</strong></p><blockquote><p>所有 work 节点执行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制k8s-master初始化屏幕输出的语句并在work节点执行</span></span><br><span class="line">[root@k8s-work1 ~]# kubeadm join 172.27.0.13:6443 --token hgtxra.fccj35x2szia3r3c --discovery-token-ca-cert-hash sha256:578cf5ca4cf588e3d84005d06f6503bf5d9ee25f63b0cfab4f78677a24b92bdd</span><br><span class="line">[root@k8s-work2 ~]# kubeadm join 172.27.0.13:6443 --token hgtxra.fccj35x2szia3r3c --discovery-token-ca-cert-hash sha256:578cf5ca4cf588e3d84005d06f6503bf5d9ee25f63b0cfab4f78677a24b92bdd</span><br></pre></td></tr></table></figure><p><strong>2、查询集群节点</strong></p><blockquote><p>Master 节点执行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl get nodes</span><br><span class="line">NAME         STATUS   ROLES                  AGE   VERSION</span><br><span class="line">k8s-master   Ready    control-plane,master   99m   v1.23.6</span><br><span class="line">k8s-work1    Ready    &lt;none&gt;                 59m   v1.23.6</span><br><span class="line">k8s-work2    Ready    &lt;none&gt;                 58m   v1.23.6</span><br></pre></td></tr></table></figure><p>都为就绪状态了</p><p>&#x3D;&#x3D;整个 K8s 集群中，就只有 kubelets 没有以容器形式运行，而是通过 systemd 服务运行。&#x3D;&#x3D;</p><h2 id="四、验证"><a href="#四、验证" class="headerlink" title="四、验证"></a>四、验证</h2><p>k8s 集群部署 nginx 服务，并通过浏览器进行访问验证。</p><p><strong>1、创建 pod</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment nginx --image=nginx</span><br><span class="line">kubectl expose deployment nginx --port=80 --type=NodePort</span><br><span class="line">kubectl get pod,svc  # 查看NodeIP</span><br></pre></td></tr></table></figure><p><strong>2、访问 Nginx</strong><br><img src="https://note.youdao.com/yws/res/17340/WEBRESOURCE0759fe5137b7c51c0b0e187d38bd5d21" alt="image.png"></p><p>&#x3D;&#x3D;至此：kubeadm方式的k8s集群已经部署完成。&#x3D;&#x3D;</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p><strong>1、k8s编译报错</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">...</span><br><span class="line">[kubelet-check] It seems like the kubelet isn&#x27;t running or healthy.</span><br><span class="line">[kubelet-check] The HTTP call equal to &#x27;curl -sSL http://localhost:10248/healthz&#x27; failed with error: Get &quot;http://localhost:10248/healthz&quot;: dial tcp [::1]:10248: connect: connection refused.</span><br><span class="line"></span><br><span class="line">Unfortunately, an error has occurred:</span><br><span class="line">timed out waiting for the condition</span><br><span class="line"></span><br><span class="line">This error is likely caused by:</span><br><span class="line">- The kubelet is not running</span><br><span class="line">- The kubelet is unhealthy due to a misconfiguration of the node in some way (required cgroups disabled)</span><br><span class="line"></span><br><span class="line">If you are on a systemd-powered system, you can try to troubleshoot the error with the following commands:</span><br><span class="line">- &#x27;systemctl status kubelet&#x27;</span><br><span class="line">- &#x27;journalctl -xeu kubelet&#x27;</span><br><span class="line"></span><br><span class="line">Additionally, a control plane component may have crashed or exited when started by the container runtime.</span><br><span class="line">To troubleshoot, list all containers using your preferred container runtimes CLI.</span><br><span class="line"></span><br><span class="line">Here is one example how you may list all Kubernetes containers running in docker:</span><br><span class="line">- &#x27;docker ps -a | grep kube | grep -v pause&#x27;</span><br><span class="line">Once you have found the failing container, you can inspect its logs with:</span><br><span class="line">- &#x27;docker logs CONTAINERID&#x27;</span><br><span class="line"></span><br><span class="line">error execution phase wait-control-plane: couldn&#x27;t initialize a Kubernetes cluster</span><br><span class="line">To see the stack trace of this error execute with --v=5 or higher</span><br></pre></td></tr></table></figure><p><strong>查看日志</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Apr 26 20:33:30 test3 kubelet: I0426 20:33:30.588349   21936 docker_service.go:264] &quot;Docker Info&quot; dockerInfo=&amp;&#123;ID:2NSH:KJPQ:XOKI:5XHN:ULL3:L4LG:SXA4:PR6J:DITW:HHCF:2RKL:U2NJ Containers:0 ContainersRunning:0 ContainersPaused:0 ContainersStopped:0 Images:7 Driver:overlay2 DriverStatus:[[Backing Filesystem extfs] [Supports d_type true] [Native Overlay Diff true]] SystemStatus:[] Plugins:&#123;Volume:[local] Network:[bridge host macvlan null overlay] Authorization:[] Log:[awslogs fluentd gcplogs gelf journald json-file logentries splunk syslog]&#125; MemoryLimit:true SwapLimit:true KernelMemory:true KernelMemoryTCP:false CPUCfsPeriod:true CPUCfsQuota:true CPUShares:true CPUSet:true PidsLimit:false IPv4Forwarding:true BridgeNfIptables:true BridgeNfIP6tables:true Debug:false NFd:24 OomKillDisable:true NGoroutines:45 SystemTime:2022-04-26T20:33:30.583063427+08:00 LoggingDriver:json-file CgroupDriver:cgroupfs CgroupVersion: NEventsListener:0 KernelVersion:3.10.0-1160.59.1.el7.x86_64 OperatingSystem:CentOS Linux 7 (Core) OSVersion: OSType:linux Architecture:x86_64 IndexServerAddress:https://index.docker.io/v1/ RegistryConfig:0xc000263340 NCPU:2 MemTotal:3873665024 GenericResources:[] DockerRootDir:/var/lib/docker HTTPProxy: HTTPSProxy: NoProxy: Name:k8s-master Labels:[] ExperimentalBuild:false ServerVersion:18.06.3-ce ClusterStore: ClusterAdvertise: Runtimes:map[runc:&#123;Path:docker-runc Args:[] Shim:&lt;nil&gt;&#125;] DefaultRuntime:runc Swarm:&#123;NodeID: NodeAddr: LocalNodeState:inactive ControlAvailable:false Error: RemoteManagers:[] Nodes:0 Managers:0 Cluster:&lt;nil&gt; Warnings:[]&#125; LiveRestoreEnabled:false Isolation: InitBinary:docker-init ContainerdCommit:&#123;ID:468a545b9edcd5932818eb9de8e72413e616e86e Expected:468a545b9edcd5932818eb9de8e72413e616e86e&#125; RuncCommit:&#123;ID:a592beb5bc4c4092b1b1bac971afed27687340c5 Expected:a592beb5bc4c4092b1b1bac971afed27687340c5&#125; InitCommit:&#123;ID:fec3683 Expected:fec3683&#125; SecurityOptions:[name=seccomp,profile=default] ProductLicense: DefaultAddressPools:[] Warnings:[]&#125;</span><br><span class="line">Apr 26 20:33:30 test3 kubelet: E0426 20:33:30.588383   21936 server.go:302] &quot;Failed to run kubelet&quot; err=&quot;failed to run Kubelet: misconfiguration: kubelet cgroup driver: \&quot;systemd\&quot; is different from docker cgroup driver: \&quot;cgroupfs\&quot;&quot;</span><br></pre></td></tr></table></figure><p>看报错的最后解释<code>kubelet cgroup driver: \&quot;systemd\&quot; is different from docker cgroup driver: \&quot;cgroupfs\&quot;&quot;</code>很明显 kubelet 与 Docker 的 cgroup 驱动程序不同，kubelet 为 systemd，而 Docker 为 cgroupfs。</p><p><code>简单查看一下docker驱动：</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master opt]# docker info |grep Cgroup</span><br><span class="line">Cgroup Driver: cgroupfs</span><br></pre></td></tr></table></figure><p><strong>解决方案</strong><br>重置初始化操作并删除相关文件，然后再修改 Docker 的 cgroup 驱动程序为 systemd 即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重置初始化</span></span><br><span class="line">[root@k8s-master ~]# kubeadm reset</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除相关配置文件</span></span><br><span class="line">[root@k8s-master ~]# rm -rf $HOME/.kube/config  &amp;&amp; rm -rf $HOME/.kube</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改 Docker 驱动为 systemd（即<span class="string">&quot;exec-opts&quot;</span>: [<span class="string">&quot;native.cgroupdriver=systemd&quot;</span>]）</span></span><br><span class="line">[root@k8s-master opt]# cat /etc/docker/daemon.json </span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://q1rw9tzz.mirror.aliyuncs.com&quot;],</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;]</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启 Docker</span></span><br><span class="line">[root@k8s-master opt]# systemctl daemon-reload </span><br><span class="line">[root@k8s-master opt]# systemctl restart docker.service</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再次初始化k8s即可</span></span><br><span class="line">[root@k8s-master ~]# kubeadm init ...</span><br></pre></td></tr></table></figure><p><strong>2、work 节点加入 k8s 集群报错</strong></p><p><em><strong>报错1</strong></em>**：**</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">accepts at most 1 arg(s), received 3</span><br><span class="line">To see the stack trace of this error execute with --v=5 or higher</span><br></pre></td></tr></table></figure><p>原因：命令不对，我是直接复制粘贴 k8s-master 初始化的终端输出结果，导致报错，所以最好先复制到 txt 文本下修改好格式再粘贴执行。<br>查看日志</p><p><em><strong>报错2</strong></em>**：**</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-work1 ~]# kubeadm join 172.27.0.13:6443 --token hgtxra.fccj35x2szia3r3c --discovery-token-ca-cert-hash sha256:578cf5ca4cf588e3d84005d06f6503bf5d9ee25f63b0cfab4f78677a24b92bdd</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">error execution phase preflight: [preflight] Some fatal errors occurred:</span><br><span class="line">[ERROR Port-10250]: Port 10250 is in use</span><br><span class="line">[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`</span><br><span class="line">To see the stack trace of this error execute with --v=5 or higher</span><br></pre></td></tr></table></figure><p>根据提示查看被占端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-work1 ~]# netstat -lntp</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 127.0.0.1:10248         0.0.0.0:*               LISTEN      17616/kubelet       </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1152/sshd           </span><br><span class="line">tcp        0      0 127.0.0.1:36281         0.0.0.0:*               LISTEN      17616/kubelet       </span><br><span class="line">tcp6       0      0 :::10250                :::*                    LISTEN      17616/kubelet       </span><br><span class="line">tcp6       0      0 :::10255                :::*                    LISTEN      17616/kubelet</span><br></pre></td></tr></table></figure><p>原因：10250端口被占用了，kill 掉然后再次 join 即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-work1 ~]#  kill -9 17616</span><br><span class="line">[root@k8s-work1 ~]# netstat -lntp</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1152/sshd</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> K8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8s </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8s 高可用集群架构（二进制）部署及应用</title>
      <link href="/posts/articles/2ac58511.html"/>
      <url>/posts/articles/2ac58511.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/k8s-cert.png" alt="k8s-cert"></p><p>K8s 版本：1.24.4</p><hr><h2 id="一、场景"><a href="#一、场景" class="headerlink" title="一、场景"></a>一、场景</h2><h3 id="1-1-部署演进"><a href="#1-1-部署演进" class="headerlink" title="1.1 部署演进"></a>1.1 部署演进</h3><ul><li>传统部署 ——&gt; 虚拟化部署 ——&gt; 容器化部署</li><li>单体架构 ——&gt; 微服务架构</li></ul><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/container_evolution.svg" alt="部署演进"></p><h3 id="1-2-应用场景"><a href="#1-2-应用场景" class="headerlink" title="1.2 应用场景"></a>1.2 应用场景</h3><ul><li><p>单 K8s 节点 ——&gt; 用于开发测试验证</p></li><li><p>单 K8s-master 集群 ——&gt; 存在 master 单点故障 ——&gt; 一般用于测试环境</p></li><li><p>K8s-master 高可用集群架构（解决单点故障）——&gt; keepalived 高可用 + LB 负载均衡 ——&gt; 企业级 K8s 集群架构 ——&gt; 用于正式环境</p></li></ul><h3 id="1-3-K8s-能做什么？"><a href="#1-3-K8s-能做什么？" class="headerlink" title="1.3 K8s 能做什么？"></a>1.3 K8s 能做什么？</h3><p>在生产环境中， 你需要管理运行着应用程序的容器，并确保服务不会下线。在没有引进 K8s 之前，我们可通过简单的 Docker swarm 集群来实现应用程序下线后自动拉起，保证可用性。而 K8s 能实现的功能却比 Docker swarm 更加丰富，当然也能保证应用程序的可用性，比如一个容器发生故障，那么 K8s 会进行自动修复。它具有以下这些特性：</p><ul><li><p><strong>服务发现和负载均衡</strong></p><p>K8s 可以使用 DNS 名称或自己的 IP 地址来曝露容器。 如果进入容器的流量很大， K8s 可以负载均衡并分配网络流量，从而使部署稳定。</p></li><li><p><strong>存储编排</strong></p><p>K8s 允许你自动挂载你选择的存储系统，例如本地存储、公有云提供商等。</p></li><li><p><strong>自动部署和回滚</strong></p><p>你可以使用 K8s 描述已部署容器的所需状态， 它可以以受控的速率将实际状态更改为期望状态。 例如，你可以自动化 K8s 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。</p></li><li><p><strong>自动完成装箱计算</strong></p><p>你为 K8s 提供许多节点组成的集群，在这个集群上运行容器化的任务。 你告诉 K8s 每个容器需要多少 CPU 和内存 (RAM)。 K8s 可以将这些容器按实际情况调度到你的节点上，以最佳方式利用你的资源。</p></li><li><p><strong>自我修复</strong></p><p>K8s 将重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器， 并且在准备好服务之前不将其通告给客户端。</p></li><li><p><strong>密钥与配置管理</strong></p><p>K8s 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</p></li></ul><h2 id="二、架构"><a href="#二、架构" class="headerlink" title="二、架构"></a>二、架构</h2><h3 id="2-1-官方架构图"><a href="#2-1-官方架构图" class="headerlink" title="2.1 官方架构图"></a>2.1 官方架构图</h3><p>K8s 集群由一组被称为节点（node）的服务器组成，这些节点上会运行由 K8s 所管理的容器化应用，且每个集群至少有一个工作节点。</p><p>工作节点会托管所谓的 Pods，而 Pod 就是作为应用负载的组件。控制平面（就是 Master 管理节点）管理集群中的工作节点和 Pods。 为集群提供故障转移和高可用性， 这些控制平面一般跨多主机运行，而集群也会跨多个节点运行。看下图就够就很清晰了。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/components-of-kubernetes.svg" alt="Components of Kubernetes"></p><h3 id="2-2-生产环境架构"><a href="#2-2-生产环境架构" class="headerlink" title="2.2 生产环境架构"></a>2.2 生产环境架构</h3><blockquote><p>下图仅为大体示意图，具体的组件并没有详细展示。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/K8s.jpg" alt="K8s"></p><h2 id="三、规划"><a href="#三、规划" class="headerlink" title="三、规划"></a>三、规划</h2><h3 id="3-1-主机规划"><a href="#3-1-主机规划" class="headerlink" title="3.1 主机规划"></a>3.1 主机规划</h3><table><thead><tr><th>Host</th><th>Hostname</th><th>Node</th><th>说明</th></tr></thead><tbody><tr><td>192.168.56.171（2C2G）</td><td>k8s-master1</td><td>k8s-master1、ETCD</td><td>k8s主节点、ETCD节点</td></tr><tr><td>192.168.56.172（2C2G）</td><td>k8s-master2</td><td>k8s-master2、ETCD</td><td>k8s主节点、ETCD节点</td></tr><tr><td>192.168.56.173（2C2G）</td><td>k8s-master3</td><td>k8s-master3、ETCD</td><td>k8s主节点、ETCD节点</td></tr><tr><td>192.168.56.174（2C2G）</td><td>k8s-work1</td><td>k8s-work1</td><td>k8s工作节点</td></tr><tr><td>192.168.56.175（2C2G）</td><td>k8s-work2</td><td>k8s-work2</td><td>k8s工作节点</td></tr><tr><td>192.168.56.176（2C2G）</td><td>k8s-ha1</td><td>k8s-ha1、keepalived</td><td>k8s负载均衡（负载master）</td></tr><tr><td>192.168.56.177（2C2G）</td><td>k8s-ha2</td><td>k8s-ha2、keepalived</td><td>k8s负载均衡（负载master）</td></tr><tr><td>192.168.56.178（VIP）</td><td>-</td><td>-</td><td>虚拟 IP，集群统一入口</td></tr></tbody></table><p><mark>说明：</mark>以上为测试演示用，实际生产环境中至少 <code>8C/16G + </code>的服务器配置。公有云的话，VIP 为公有云的负载均衡的 IP。</p><h3 id="3-2-版本规划"><a href="#3-2-版本规划" class="headerlink" title="3.2 版本规划"></a>3.2 版本规划</h3><p>本次部署的 K8s 版本为 <code>1.24.x</code> ，<code>v1.24</code> 之前的 Kubernetes 版本直接集成了 Docker Engine 的一个组件，名为 <strong>dockershim</strong>。  自 <code>1.24</code> 版起，Dockershim 已从 Kubernetes 项目中正式移除。</p><table><thead><tr><th>软件名称</th><th>版本</th></tr></thead><tbody><tr><td>CentOS 7</td><td>kernel：3.10</td></tr><tr><td>K8s（kube-apiserver、kube-controller-manager、kube-scheduler、kubelet、kube-proxy）</td><td>v1.24.4</td></tr><tr><td>etcd</td><td>v3.5.4</td></tr><tr><td>calico</td><td>v3.23</td></tr><tr><td>coredns</td><td>v1.9.3</td></tr><tr><td>docker</td><td>v20.10.17</td></tr><tr><td>haproxy</td><td>v5.18</td></tr><tr><td>keepalived</td><td>v3.5</td></tr></tbody></table><h3 id="3-3-目录规划"><a href="#3-3-目录规划" class="headerlink" title="3.3 目录规划"></a>3.3 目录规划</h3><blockquote><p>在任意一台 k8s-master 节点创建即可，生成的相关文件（证书、私钥等）再通过 scp 等方式进行分发。</p></blockquote><table><thead><tr><th>DIR</th><th>说明</th></tr></thead><tbody><tr><td>&#x2F;data&#x2F;k8s-work&#x2F;</td><td>k8s-master 节点工作目录</td></tr><tr><td>&#x2F;data&#x2F;k8s-work&#x2F;cfssl</td><td>用于创建各种证书文件的目录</td></tr><tr><td>&#x2F;data&#x2F;k8s-work&#x2F;etcd</td><td>ETCD 二进制包存放目录</td></tr><tr><td>&#x2F;data&#x2F;k8s-work&#x2F;k8s</td><td>K8s 二进制包存放目录</td></tr><tr><td>&#x2F;data&#x2F;k8s-work&#x2F;calico</td><td>calico 配置文件</td></tr><tr><td>&#x2F;data&#x2F;k8s-work&#x2F;coredns</td><td>coredns 配置文件</td></tr><tr><td></td><td></td></tr><tr><td>&#x2F;data&#x2F;etcd&#x2F;{conf,data,ssl}</td><td>ETCD 集群服务（配置文件、数据、证书）目录</td></tr><tr><td>&#x2F;data&#x2F;kubernetes&#x2F;{conf,logs,ssl,tokenfile}</td><td>K8s 集群服务（配置文件、数据、证书）目录</td></tr></tbody></table><h3 id="3-4-网络分配"><a href="#3-4-网络分配" class="headerlink" title="3.4 网络分配"></a>3.4 网络分配</h3><table><thead><tr><th>网络名称</th><th>网段</th></tr></thead><tbody><tr><td>Node 节点网络</td><td>192.168.56.0&#x2F;24</td></tr><tr><td>Service 网络</td><td>10.96.0.0&#x2F;16</td></tr><tr><td>Pod 网络</td><td>10.244.0.0&#x2F;16</td></tr></tbody></table><h3 id="3-5-容器引擎"><a href="#3-5-容器引擎" class="headerlink" title="3.5 容器引擎"></a>3.5 容器引擎</h3><p>本次采用 Docker 作为 K8s 的编排对象，但要清楚，从 1.20+ 版本开始，K8s 已不再唯一支持 Docker 作为编排对象，且 1.24+ 版本开始完全移除了 <code>Dockershim</code>，进而支持 Contained 工业级容器，当然我们的 Docker 还是能继续使用的，可通过 <code>cri-docker</code> 接口实现，下文会有详细介绍。</p><h2 id="四、部署"><a href="#四、部署" class="headerlink" title="四、部署"></a>四、部署</h2><h3 id="4-1-服务器初始化"><a href="#4-1-服务器初始化" class="headerlink" title="4.1 服务器初始化"></a>4.1 服务器初始化</h3><h4 id="4-1-1-统一主机名"><a href="#4-1-1-统一主机名" class="headerlink" title="4.1.1 统一主机名"></a>4.1.1 统一主机名</h4><blockquote><p>对应主机执行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl set-hostname k8s-master1</span><br><span class="line">hostnamectl set-hostname k8s-master2</span><br><span class="line">hostnamectl set-hostname k8s-master3</span><br><span class="line">hostnamectl set-hostname k8s-work1</span><br><span class="line">hostnamectl set-hostname k8s-work2</span><br><span class="line">hostnamectl set-hostname k8s-ha1</span><br><span class="line">hostnamectl set-hostname k8s-ha2</span><br></pre></td></tr></table></figure><h4 id="4-1-2-互作本地解析"><a href="#4-1-2-互作本地解析" class="headerlink" title="4.1.2 互作本地解析"></a>4.1.2 互作本地解析</h4><blockquote><p>所有主机均执行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">192.168.56.171 k8s-master1</span><br><span class="line">192.168.56.172 k8s-master2</span><br><span class="line">192.168.56.173 k8s-master3</span><br><span class="line">192.168.56.174 k8s-work1</span><br><span class="line">192.168.56.175 k8s-work2</span><br><span class="line">192.168.56.176 k8s-ha1</span><br><span class="line">192.168.56.177 k8s-ha2</span><br></pre></td></tr></table></figure><h4 id="4-1-3-主机系统优化"><a href="#4-1-3-主机系统优化" class="headerlink" title="4.1.3 主机系统优化"></a>4.1.3 主机系统优化</h4><blockquote><p>所有主机均执行</p></blockquote><p>1、关闭 firewalld</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure><p>2、关闭 Selinux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0</span><br><span class="line">sed -i &#x27;s/enforcing/disabled/&#x27; /etc/selinux/config</span><br></pre></td></tr></table></figure><p>3、停用交互分区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a</span><br><span class="line">sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab</span><br></pre></td></tr></table></figure><p>4、集群系统时间同步</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y ntpdate &amp;&amp; ntpdate time.nist.gov &amp;&amp; hwclock --systohc</span><br></pre></td></tr></table></figure><p>5、加载 br_netfilter 模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确保 br_netfilter 模块被加载</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载模块</span></span><br><span class="line">modprobe br_netfilter</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看加载情况</span></span><br><span class="line">lsmod | grep br_netfilter</span><br><span class="line">br_netfilter           22256  0 </span><br><span class="line">bridge                151336  1 br_netfilter</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久生效</span></span><br><span class="line">cat &lt;&lt;EOF | tee /etc/modules-load.d/k8s.conf</span><br><span class="line">br_netfilter</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>6、允许 iptables 检查桥接流量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置所需的 sysctl 参数，参数在重新启动后保持不变</span></span><br><span class="line">cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-iptables  = 1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.ipv4.ip_forward                 = 1</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">应用 sysctl 参数而不重新启动</span></span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure><p>7、文件描述符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt;&gt; /etc/security/limits.conf</span><br><span class="line">* soft nofile 655360</span><br><span class="line">* hard nofile 655360</span><br><span class="line">* soft nproc 655350</span><br><span class="line">* hard nproc 655350</span><br><span class="line">* soft memlock unlimited</span><br><span class="line">* hard memlock unlimited</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>9、修改虚拟内存最大限制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt;&gt; /etc/sysctl.conf</span><br><span class="line">vm.max_map_count = 655360</span><br><span class="line">fs.file-max=655360</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><blockquote><p>系统级别</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt;&gt; /etc/systemd/system.conf</span><br><span class="line">DefaultLimitNOFILE=655360</span><br><span class="line">DefaultLimitNPROC=655360</span><br><span class="line">DefaultLimitMEMLOCK=infinity</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><blockquote><p>使生效</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>10、MAC 地址和 product_uuid 的唯一性</p><p>一般来讲，硬件设备会拥有唯一的地址，但是有些虚拟机的地址可能会重复。 Kubernetes 使用这些值来唯一确定集群中的节点。 如果这些值在每个节点上不唯一，可能会导致安装失败。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以使用命令 ip link 或 ifconfig -a 来获取网络接口的 MAC 地址</span><br><span class="line">可以使用 sudo cat /sys/class/dmi/id/product_uuid 命令对 product_uuid 校验</span><br></pre></td></tr></table></figure><h4 id="4-1-4-配置免密登录"><a href="#4-1-4-配置免密登录" class="headerlink" title="4.1.4 配置免密登录"></a>4.1.4 配置免密登录</h4><p>k8s-master1 节点免密钥登录其他节点，安装过程中生成配置文件和证书均在 k8s-master1 上操作，集群管理也在 k8s-master1 上操作，阿里云或者 AWS 上需要单独一台 kubectl 服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一路回车即可</span></span><br><span class="line">ssh-keygen</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">免密登录</span></span><br><span class="line">ssh-copy-id k8s-master2</span><br><span class="line">ssh-copy-id k8s-master3</span><br><span class="line">ssh-copy-id k8s-work1</span><br><span class="line">ssh-copy-id k8s-work2</span><br></pre></td></tr></table></figure><h3 id="4-2-K8s-负载均衡配置"><a href="#4-2-K8s-负载均衡配置" class="headerlink" title="4.2 K8s 负载均衡配置"></a>4.2 K8s 负载均衡配置</h3><blockquote><p>在 k8s-ha1、k8s-ha2 服务器上执行</p></blockquote><h4 id="4-2-1-Haproxy"><a href="#4-2-1-Haproxy" class="headerlink" title="4.2.1 Haproxy"></a>4.2.1 Haproxy</h4><p>1、安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install haproxy</span><br></pre></td></tr></table></figure><p>2、配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;/etc/haproxy/haproxy.cfg&lt;&lt;&quot;EOF&quot;</span><br><span class="line">global</span><br><span class="line"> maxconn 2000</span><br><span class="line"> ulimit-n 16384</span><br><span class="line"> log 127.0.0.1 local0 err</span><br><span class="line"> stats timeout 30s</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line"> log global</span><br><span class="line"> mode http</span><br><span class="line"> option httplog</span><br><span class="line"> timeout connect 5000</span><br><span class="line"> timeout client 50000</span><br><span class="line"> timeout server 50000</span><br><span class="line"> timeout http-request 15s</span><br><span class="line"> timeout http-keep-alive 15s</span><br><span class="line"></span><br><span class="line">frontend monitor-in</span><br><span class="line"> bind *:33305</span><br><span class="line"> mode http</span><br><span class="line"> option httplog</span><br><span class="line"> monitor-uri /monitor</span><br><span class="line"></span><br><span class="line">frontend k8s-master</span><br><span class="line"> bind 0.0.0.0:6443</span><br><span class="line"> bind 127.0.0.1:6443</span><br><span class="line"> mode tcp</span><br><span class="line"> option tcplog</span><br><span class="line"> tcp-request inspect-delay 5s</span><br><span class="line"> default_backend k8s-master</span><br><span class="line"></span><br><span class="line">backend k8s-master</span><br><span class="line"> mode tcp</span><br><span class="line"> option tcplog</span><br><span class="line"> option tcp-check</span><br><span class="line"> balance roundrobin</span><br><span class="line"> default-server inter 10s downinter 5s rise 2 fall 2 slowstart 60s maxconn 250 maxqueue 256 weight 100</span><br><span class="line"> server  k8s-master1  192.168.56.171:6443 check</span><br><span class="line"> server  k8s-master2  192.168.56.172:6443 check</span><br><span class="line"> server  k8s-master3  192.168.56.173:6443 check</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>3、启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start haproxy.service</span><br><span class="line">systemctl enable haproxy.service</span><br></pre></td></tr></table></figure><h4 id="4-2-2-Keepalived"><a href="#4-2-2-Keepalived" class="headerlink" title="4.2.2 Keepalived"></a>4.2.2 Keepalived</h4><p>1、安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y keepalived</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置文件路径：/etc/keepalived/keepalived.conf</span></span><br></pre></td></tr></table></figure><p>2、配置</p><ul><li>k8s-ha1（主）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;/etc/keepalived/keepalived.conf&lt;&lt;&quot;EOF&quot;</span><br><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id k8s-master</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script check_k8s-master &#123;</span><br><span class="line">    script &quot;/etc/keepalived/check_k8s-master_status.sh&quot;</span><br><span class="line">    interval 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    mcast_src_ip 192.168.56.176</span><br><span class="line">    virtual_router_id 90</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass K8S_PASSWD</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.56.178/24</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        check_k8s-master</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li>k8s-ha2（备）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;/etc/keepalived/keepalived.conf&lt;&lt;&quot;EOF&quot;</span><br><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id k8s-master</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script check_k8s-master &#123;</span><br><span class="line">    script &quot;/etc/keepalived/check_k8s-master_status.sh&quot;</span><br><span class="line">    interval 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_2 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    mcast_src_ip 192.168.56.177</span><br><span class="line">    virtual_router_id 90</span><br><span class="line">    priority 50</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass K8S_PASSWD</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.56.178/24</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        check_k8s-master</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>3、K8s-master 健康检测脚本</p><blockquote><p>主备均创建该文件</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/keepalived/check_k8s-master_status.sh &lt;&lt;&quot;EOF&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">err=0</span><br><span class="line">for k in $(seq 1 3)</span><br><span class="line">do</span><br><span class="line">   check_code=$(pgrep haproxy)</span><br><span class="line">   if [[ $check_code == &quot;&quot; ]]; then</span><br><span class="line">       err=$(expr $err + 1)</span><br><span class="line">       sleep 1</span><br><span class="line">       continue</span><br><span class="line">   else</span><br><span class="line">       err=0</span><br><span class="line">       break</span><br><span class="line">   fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">if [[ $err != &quot;0&quot; ]]; then</span><br><span class="line">   echo &quot;systemctl stop keepalived&quot;</span><br><span class="line">   /usr/bin/systemctl stop keepalived</span><br><span class="line">   exit 1</span><br><span class="line">else</span><br><span class="line">   exit 0</span><br><span class="line">fi</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>4、启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start keepalived.service</span><br><span class="line">systemctl enable keepalived.service</span><br></pre></td></tr></table></figure><h3 id="4-3-K8s-集群组件部署"><a href="#4-3-K8s-集群组件部署" class="headerlink" title="4.3 K8s 集群组件部署"></a>4.3 K8s 集群组件部署</h3><h4 id="4-3-1-ETCD-集群"><a href="#4-3-1-ETCD-集群" class="headerlink" title="4.3.1 ETCD 集群"></a>4.3.1 ETCD 集群</h4><h5 id="4-3-1-1-部署-cfssl-工具"><a href="#4-3-1-1-部署-cfssl-工具" class="headerlink" title="4.3.1.1 部署 cfssl 工具"></a>4.3.1.1 部署 cfssl 工具</h5><blockquote><p>包下载地址：<a href="https://github.com/cloudflare/cfssl/">https://github.com/cloudflare/cfssl/</a></p></blockquote><p>1、创建工作目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/k8s-work/cfssl</span><br></pre></td></tr></table></figure><p>2、安装 cfssl 工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我用的版本是1.6.1（大家根据实际选择）</span></span><br><span class="line">cd /data/k8s-work/cfssl</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上传文件到当前目录下（这里用到了三个文件）</span></span><br><span class="line">[root@k8s-master1 cfssl]# ll</span><br><span class="line">total 40232</span><br><span class="line">-rw-r--r-- 1 root root 16659824 May 31 22:12 cfssl_1.6.1_linux_amd64</span><br><span class="line">-rw-r--r-- 1 root root 13502544 May 31 21:49 cfssl-certinfo_1.6.1_linux_amd64</span><br><span class="line">-rw-r--r-- 1 root root 11029744 May 31 21:50 cfssljson_1.6.1_linux_amd64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">说明</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cfssl文件：命令行工具</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cfssljson文件：用来从cfssl程序获取JSON输出，并将证书，密钥，CSR和bundle写入文件中</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cfssl-certinfo文件：证书相关信息查看工具</span></span><br></pre></td></tr></table></figure><p>3、软链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./cfssl*</span><br><span class="line">ln -s /data/k8s-work/cfssl/cfssl_1.6.1_linux_amd64 /usr/sbin/cfssl</span><br><span class="line">ln -s /data/k8s-work/cfssl/cfssl-certinfo_1.6.1_linux_amd64 /usr/sbin/cfssl-certinfo</span><br><span class="line">ln -s /data/k8s-work/cfssl/cfssljson_1.6.1_linux_amd64 /usr/sbin/cfssljson</span><br></pre></td></tr></table></figure><p>4、验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master1 cfssl]# cfssl version</span><br><span class="line">Version: 1.6.1</span><br><span class="line">Runtime: go1.12.12</span><br></pre></td></tr></table></figure><h5 id="4-3-1-2-生成-CA-证书"><a href="#4-3-1-2-生成-CA-证书" class="headerlink" title="4.3.1.2 生成 CA 证书"></a>4.3.1.2 生成 CA 证书</h5><p>1、配置 CA 证书请求文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cd /data/k8s-work/cfssl</span><br><span class="line"></span><br><span class="line">cat &gt; ca-csr.json &lt;&lt;&quot;EOF&quot;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;kubernetes&quot;,</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">      &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">      &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;names&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">      &quot;ST&quot;: &quot;Beijing&quot;,</span><br><span class="line">      &quot;L&quot;: &quot;Beijing&quot;,</span><br><span class="line">      &quot;O&quot;: &quot;xgxy&quot;,</span><br><span class="line">      &quot;OU&quot;: &quot;ops&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;ca&quot;: &#123;</span><br><span class="line">          &quot;expiry&quot;: &quot;87600h&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>2、创建 ca 证书</p><blockquote><p>会生成三个文件：ca.csr 请求文件、ca-key.pem请求 key、ca.pem 证书</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220828220937384.png" alt="image-20220828220937384"></p><p>3、CA 证书策略</p><p>你可以通过 cfssl 命令行工具来默认生成，然后再修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl print-defaults config &gt; ca-config.json</span><br></pre></td></tr></table></figure><p>生成后，修改为下面案例即可（或就直接使用下面的示例配置即可）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; ca-config.json &lt;&lt;&quot;EOF&quot;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;signing&quot;: &#123;</span><br><span class="line">      &quot;default&quot;: &#123;</span><br><span class="line">          &quot;expiry&quot;: &quot;87600h&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">      &quot;profiles&quot;: &#123;</span><br><span class="line">          &quot;kubernetes&quot;: &#123;</span><br><span class="line">              &quot;usages&quot;: [</span><br><span class="line">                  &quot;signing&quot;,</span><br><span class="line">                  &quot;key encipherment&quot;,</span><br><span class="line">                  &quot;server auth&quot;,</span><br><span class="line">                  &quot;client auth&quot;</span><br><span class="line">              ],</span><br><span class="line">              &quot;expiry&quot;: &quot;87600h&quot;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">说明</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">server auth：表示client客户端可以使用ca对server提供的证书进行验证</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">client auth：表示server客户端可以使用ca对client提供的证书进行验证</span></span><br></pre></td></tr></table></figure><h5 id="4-3-1-3-生成-ETCD-证书"><a href="#4-3-1-3-生成-ETCD-证书" class="headerlink" title="4.3.1.3 生成 ETCD 证书"></a>4.3.1.3 生成 ETCD 证书</h5><p>1、配置 ETCD 证书请求文件</p><blockquote><p>为了方便后期扩容可以多写几个预留的 IP</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; etcd-csr.json &lt;&lt;&quot;EOF&quot;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;etcd&quot;,</span><br><span class="line">  &quot;hosts&quot;: [</span><br><span class="line">    &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;192.168.56.171&quot;,</span><br><span class="line">    &quot;192.168.56.172&quot;,</span><br><span class="line">    &quot;192.168.56.173&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;names&quot;: [&#123;</span><br><span class="line">    &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">    &quot;ST&quot;: &quot;Beijing&quot;,</span><br><span class="line">    &quot;L&quot;: &quot;Beijing&quot;,</span><br><span class="line">    &quot;O&quot;: &quot;xgxy&quot;,</span><br><span class="line">    &quot;OU&quot;: &quot;ops&quot;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>2、生成 ETCD 证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes etcd-csr.json | cfssljson -bare etcd</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220829141739248.png" alt="image-20220829141739248"></p><h5 id="4-3-1-4-部署-ETCD-集群"><a href="#4-3-1-4-部署-ETCD-集群" class="headerlink" title="4.3.1.4 部署 ETCD 集群"></a>4.3.1.4 部署 ETCD 集群</h5><blockquote><p>包下载地址：<a href="https://github.com/etcd-io/etcd">https://github.com/etcd-io/etcd</a></p></blockquote><p>1、下载 ETCD 软件包并上传至服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/k8s-work/etcd</span><br><span class="line">tar xzf etcd-v3.5.4-linux-amd64.tar.gz</span><br><span class="line">mv etcd-v3.5.4-linux-amd64 etcd-v3.5.4</span><br></pre></td></tr></table></figure><p>2、做软链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /data/k8s-work/etcd/etcd-v3.5.4/etcd* /usr/bin/</span><br></pre></td></tr></table></figure><p>3、版本验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master1 etcd]# etcd --version</span><br><span class="line">etcd Version: 3.5.4</span><br><span class="line">Git SHA: 08407ff76</span><br><span class="line">Go Version: go1.16.15</span><br><span class="line">Go OS/Arch: linux/amd64</span><br></pre></td></tr></table></figure><p>4、分发 ETCD 二进制工具至其他 ETCD 集群节点主机上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp etcd-v3.5.4/etcd* k8s-master2:/usr/bin/</span><br><span class="line">scp etcd-v3.5.4/etcd* k8s-master3:/usr/bin/</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220829143435683.png" alt="image-20220829143435683"></p><p>5、新建 ETCD 集群相关目录</p><blockquote><p>所有 ETCD 集群节点均操作</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/etcd/&#123;conf,data,ssl&#125;</span><br></pre></td></tr></table></figure><p>6、创建 ETCD 配置文件</p><blockquote><p>所有 ETCD 集群节点均操作</p></blockquote><ul><li><p>k8s-master1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /data/etcd/conf/etcd.conf &lt;&lt;&quot;EOF&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[Member]</span></span><br><span class="line">ETCD_NAME=&quot;etcd-1&quot;</span><br><span class="line">ETCD_DATA_DIR=&quot;/data/etcd/data&quot;</span><br><span class="line">ETCD_LISTEN_PEER_URLS=&quot;https://192.168.56.171:2380&quot;</span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=&quot;https://192.168.56.171:2379,http://127.0.0.1:2379&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[Clustering]</span></span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=&quot;https://192.168.56.171:2380&quot;</span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=&quot;https://192.168.56.171:2379&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER=&quot;etcd-1=https://192.168.56.171:2380,etcd-2=https://192.168.56.172:2380,etcd-3=https://192.168.56.173:2380&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN=&quot;etcd-cluster&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE=&quot;new&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[Security]</span></span><br><span class="line">ETCD_CERT_FILE=&quot;/data/etcd/ssl/etcd.pem&quot;</span><br><span class="line">ETCD_KEY_FILE=&quot;/data/etcd/ssl/etcd-key.pem&quot;</span><br><span class="line">ETCD_TRUSTED_CA_FILE=&quot;/data/etcd/ssl/ca.pem&quot;</span><br><span class="line">ETCD_CLIENT_CERT_AUTH=&quot;true&quot;</span><br><span class="line">ETCD_PEER_CERT_FILE=&quot;/data/etcd/ssl/etcd.pem&quot;</span><br><span class="line">ETCD_PEER_KEY_FILE=&quot;/data/etcd/ssl/etcd-key.pem&quot;</span><br><span class="line">ETCD_PEER_TRUSTED_CA_FILE=&quot;/data/etcd/ssl/ca.pem&quot;</span><br><span class="line">ETCD_PEER_CLIENT_CERT_AUTH=&quot;true&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>k8s-master2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /data/etcd/conf/etcd.conf &lt;&lt;&quot;EOF&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[Member]</span></span><br><span class="line">ETCD_NAME=&quot;etcd-2&quot;</span><br><span class="line">ETCD_DATA_DIR=&quot;/data/etcd/data&quot;</span><br><span class="line">ETCD_LISTEN_PEER_URLS=&quot;https://192.168.56.172:2380&quot;</span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=&quot;https://192.168.56.172:2379,http://127.0.0.1:2379&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[Clustering]</span></span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=&quot;https://192.168.56.172:2380&quot;</span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=&quot;https://192.168.56.172:2379&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER=&quot;etcd-1=https://192.168.56.171:2380,etcd-2=https://192.168.56.172:2380,etcd-3=https://192.168.56.173:2380&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN=&quot;etcd-cluster&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE=&quot;new&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[Security]</span></span><br><span class="line">ETCD_CERT_FILE=&quot;/data/etcd/ssl/etcd.pem&quot;</span><br><span class="line">ETCD_KEY_FILE=&quot;/data/etcd/ssl/etcd-key.pem&quot;</span><br><span class="line">ETCD_TRUSTED_CA_FILE=&quot;/data/etcd/ssl/ca.pem&quot;</span><br><span class="line">ETCD_CLIENT_CERT_AUTH=&quot;true&quot;</span><br><span class="line">ETCD_PEER_CERT_FILE=&quot;/data/etcd/ssl/etcd.pem&quot;</span><br><span class="line">ETCD_PEER_KEY_FILE=&quot;/data/etcd/ssl/etcd-key.pem&quot;</span><br><span class="line">ETCD_PEER_TRUSTED_CA_FILE=&quot;/data/etcd/ssl/ca.pem&quot;</span><br><span class="line">ETCD_PEER_CLIENT_CERT_AUTH=&quot;true&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>k8s-master3</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /data/etcd/conf/etcd.conf &lt;&lt;&quot;EOF&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[Member]</span></span><br><span class="line">ETCD_NAME=&quot;etcd-3&quot;</span><br><span class="line">ETCD_DATA_DIR=&quot;/data/etcd/data&quot;</span><br><span class="line">ETCD_LISTEN_PEER_URLS=&quot;https://192.168.56.173:2380&quot;</span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=&quot;https://192.168.56.173:2379,http://127.0.0.1:2379&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[Clustering]</span></span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=&quot;https://192.168.56.173:2380&quot;</span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=&quot;https://192.168.56.173:2379&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER=&quot;etcd-1=https://192.168.56.171:2380,etcd-2=https://192.168.56.172:2380,etcd-3=https://192.168.56.173:2380&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN=&quot;etcd-cluster&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE=&quot;new&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[Security]</span></span><br><span class="line">ETCD_CERT_FILE=&quot;/data/etcd/ssl/etcd.pem&quot;</span><br><span class="line">ETCD_KEY_FILE=&quot;/data/etcd/ssl/etcd-key.pem&quot;</span><br><span class="line">ETCD_TRUSTED_CA_FILE=&quot;/data/etcd/ssl/ca.pem&quot;</span><br><span class="line">ETCD_CLIENT_CERT_AUTH=&quot;true&quot;</span><br><span class="line">ETCD_PEER_CERT_FILE=&quot;/data/etcd/ssl/etcd.pem&quot;</span><br><span class="line">ETCD_PEER_KEY_FILE=&quot;/data/etcd/ssl/etcd-key.pem&quot;</span><br><span class="line">ETCD_PEER_TRUSTED_CA_FILE=&quot;/data/etcd/ssl/ca.pem&quot;</span><br><span class="line">ETCD_PEER_CLIENT_CERT_AUTH=&quot;true&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">说明：</span><br><span class="line">ETCD_NAME：节点名称，集群中唯一</span><br><span class="line">ETCD_DATA_DIR：数据目录（自定义）</span><br><span class="line">ETCD_LISTEN_PEER_URLS：集群通信监听地址</span><br><span class="line">ETCD_LISTEN_CLIENT_URLS：客户端访问监听地址</span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS：集群通告地址</span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS：客户端通告地址</span><br><span class="line">ETCD_INITIAL_CLUSTER：集群节点地址（所有ETCD节点地址）</span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN：集群Token（ETCD集群节点统一口令）</span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE：加入集群的当前状态，new是新集群，existing 表示加入已有集群</span><br><span class="line">ETCD_CERT_FILE：etcd.pem文件</span><br><span class="line">ETCD_KEY_FILE：etcd<span class="literal">-key</span>.pem文件</span><br><span class="line">ETCD_TRUSTED_CA_FILE：ca.pem文件</span><br><span class="line">ETCD_CLIENT_CERT_AUTH=<span class="string">&quot;true&quot;</span></span><br><span class="line">ETCD_PEER_CERT_FILE：etcd.pem文件</span><br><span class="line">ETCD_PEER_KEY_FILE：etcd<span class="literal">-key</span>.pem文件</span><br><span class="line">ETCD_PEER_TRUSTED_CA_FILE：ca.pem文件</span><br><span class="line">ETCD_PEER_CLIENT_CERT_AUTH=<span class="string">&quot;true&quot;</span></span><br></pre></td></tr></table></figure></li></ul><p>7、复制 ETCD 证书至刚创建对应的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">k8s-master1</span></span><br><span class="line">cd /data/k8s-work/cfssl</span><br><span class="line">cp ca*.pem etcd*.pem /data/etcd/ssl/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">k8s-master2</span></span><br><span class="line">scp ca*.pem etcd*.pem k8s-master2:/data/etcd/ssl/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">k8s-master3</span></span><br><span class="line">scp ca*.pem etcd*.pem k8s-master3:/data/etcd/ssl/</span><br></pre></td></tr></table></figure><p>8、配置 systemd 管理</p><blockquote><p>ETCD 三台集群节点均操作</p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt; EOF | <span class="built_in">tee</span> /usr/lib/systemd/system/etcd.service</span><br><span class="line">[<span class="type">Unit</span>]</span><br><span class="line">Description=Etcd Server</span><br><span class="line">After=network.target</span><br><span class="line">After=network<span class="literal">-online</span>.target</span><br><span class="line">Wants=network<span class="literal">-online</span>.target</span><br><span class="line"></span><br><span class="line">[<span class="type">Service</span>]</span><br><span class="line"><span class="built_in">Type</span>=notify</span><br><span class="line">EnvironmentFile=-/<span class="keyword">data</span>/etcd/conf/etcd.conf</span><br><span class="line">ExecStart=/usr/bin/etcd</span><br><span class="line">Restart=on<span class="literal">-failure</span></span><br><span class="line">RestartSec=<span class="number">5</span></span><br><span class="line">LimitNOFILE=<span class="number">65536</span></span><br><span class="line"></span><br><span class="line">[<span class="type">Install</span>]</span><br><span class="line">WantedBy=multi<span class="literal">-user</span>.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>9、启动 ETCD 集群</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon<span class="literal">-reload</span></span><br><span class="line">systemctl <span class="built_in">start</span> etcd.service</span><br><span class="line">systemctl enable etcd.service</span><br><span class="line"></span><br><span class="line">这里注意：启动第一个ETCD节点后，它就会等待其他集群节点加入，如果特定时间内其他节点未加入，则启动会失败</span><br><span class="line">因此，我们需要在特定时间内启动ETCD集群，避免超时启动失败</span><br></pre></td></tr></table></figure><p>10、集群验证</p><ul><li><p>节点可用性验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETCDCTL_API=3 /usr/bin/etcdctl --cacert=/data/etcd/ssl/ca.pem --cert=/data/etcd/ssl/etcd.pem --key=/data/etcd/ssl/etcd-key.pem --endpoints=&quot;https://192.168.56.171:2379,https://192.168.56.172:2379,https://192.168.56.173:2379&quot; endpoint health --write-out=table</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220829161255754.png" alt="image-20220829161255754"></p></li><li><p>ETCD 数据库性能验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETCDCTL_API=3 /usr/bin/etcdctl --write-out=table --cacert=/data/etcd/ssl/ca.pem --cert=/data/etcd/ssl/etcd.pem --key=/data/etcd/ssl/etcd-key.pem --endpoints=https://192.168.56.171:2379,https://192.168.56.172:2379,https://192.168.56.173:2379 check perf</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220829161833128.png" alt="image-20220829161833128"></p></li><li><p>集群节点成员列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETCDCTL_API=3 /usr/bin/etcdctl --write-out=table --cacert=/data/etcd/ssl/ca.pem --cert=/data/etcd/ssl/etcd.pem --key=/data/etcd/ssl/etcd-key.pem --endpoints=https://192.168.56.171:2379,https://192.168.56.172:2379,https://192.168.56.173:2379 member list</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220829162029485.png" alt="image-20220829162029485"></p><p>这里看不了谁是 Leader，继续看下一条测试命令。</p></li><li><p>查看集群 Leader</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETCDCTL_API=3 /usr/bin/etcdctl --write-out=table --cacert=/data/etcd/ssl/ca.pem --cert=/data/etcd/ssl/etcd.pem --key=/data/etcd/ssl/etcd-key.pem --endpoints=https://192.168.56.171:2379,https://192.168.56.172:2379,https://192.168.56.173:2379 endpoint status</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220829162425388.png" alt="image-20220829162425388"></p></li></ul><h4 id="4-3-2-K8s-集群部署"><a href="#4-3-2-K8s-集群部署" class="headerlink" title="4.3.2 K8s 集群部署"></a>4.3.2 K8s 集群部署</h4><blockquote><p>包下载地址：<a href="https://github.com/kubernetes/kubernetes">https://github.com/kubernetes/kubernetes</a></p></blockquote><h5 id="4-3-2-1-Master-节点"><a href="#4-3-2-1-Master-节点" class="headerlink" title="4.3.2.1 Master 节点"></a>4.3.2.1 Master 节点</h5><blockquote><p>k8s-master 必须的节点：kube-apiserver、kube-controller-manager、kube-scheduler、kubectl（k8s-master 客户端工具）</p></blockquote><h6 id="4-3-2-1-1-kubernetes"><a href="#4-3-2-1-1-kubernetes" class="headerlink" title="4.3.2.1.1 kubernetes"></a>4.3.2.1.1 kubernetes</h6><blockquote><p>K8s 二进制包下载并分发</p></blockquote><p>1、创建工作目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/k8s-work/k8s</span><br></pre></td></tr></table></figure><p>2、下载并上传 K8s 包至服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar xzf kubernetes-server-linux-amd64.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个二进制包包含了master、work的所有组件，所以下载一个二进制包即可</span></span><br></pre></td></tr></table></figure><p>3、做软链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ln -s /data/k8s-work/k8s/kubernetes/server/bin/kube-apiserver /usr/bin/</span><br><span class="line">ln -s /data/k8s-work/k8s/kubernetes/server/bin/kube-controller-manager /usr/bin/</span><br><span class="line">ln -s /data/k8s-work/k8s/kubernetes/server/bin/kube-scheduler /usr/bin/</span><br><span class="line">ln -s /data/k8s-work/k8s/kubernetes/server/bin/kubectl /usr/bin/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果你希望将你的 k8s-master 节点也用于工作负载，那还需要分发以下二进制组件。本次我不希望在master节点上进行工作负载</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ln</span> -s /data/k8s-work/k8s/kubernetes/server/bin/kubelet /usr/bin/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ln</span> -s /data/k8s-work/k8s/kubernetes/server/bin/kube-proxy /usr/bin/</span></span><br></pre></td></tr></table></figure><p>4、二进制组件分发</p><blockquote><p>分发二进制命令至其他 k8s-master 节点，这是 k8s-master 必须的二进制组件。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp kube-apiserver kube-controller-manager kube-scheduler kubectl k8s-master2:/usr/bin/</span><br><span class="line">scp kube-apiserver kube-controller-manager kube-scheduler kubectl k8s-master3:/usr/bin/</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220829170425953.png" alt="image-20220829170425953"></p><blockquote><p>如果你希望将你的 k8s-master 节点也用于<code>工作负载</code>，那还需要分发这几个二进制组件。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp kubelet kube-proxy k8s-master2:/usr/bin/</span><br><span class="line">scp kubelet kube-proxy k8s-master3:/usr/bin/</span><br></pre></td></tr></table></figure><h6 id="4-3-2-1-2-apiserver"><a href="#4-3-2-1-2-apiserver" class="headerlink" title="4.3.2.1.2 apiserver"></a>4.3.2.1.2 apiserver</h6><p>1、配置 apiserver 证书请求文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同样，进入到我们的cfssl目录下创建</span></span><br><span class="line">cd /data/k8s-work/cfssl</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; kube-apiserver-csr.json &lt;&lt; &quot;EOF&quot;</span><br><span class="line">&#123;</span><br><span class="line">&quot;CN&quot;: &quot;kubernetes&quot;,</span><br><span class="line">  &quot;hosts&quot;: [</span><br><span class="line">    &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;192.168.56.171&quot;,</span><br><span class="line">    &quot;192.168.56.172&quot;,</span><br><span class="line">    &quot;192.168.56.173&quot;,</span><br><span class="line">    &quot;192.168.56.174&quot;,</span><br><span class="line">    &quot;192.168.56.175&quot;,</span><br><span class="line">    &quot;192.168.56.176&quot;,</span><br><span class="line">    &quot;192.168.56.177&quot;,</span><br><span class="line">    &quot;192.168.56.178&quot;,</span><br><span class="line">    &quot;192.168.56.179&quot;,</span><br><span class="line">    &quot;192.168.56.180&quot;,</span><br><span class="line">    &quot;10.96.0.1&quot;,</span><br><span class="line">    &quot;kubernetes&quot;,</span><br><span class="line">    &quot;kubernetes.default&quot;,</span><br><span class="line">    &quot;kubernetes.default.svc&quot;,</span><br><span class="line">    &quot;kubernetes.default.svc.cluster&quot;,</span><br><span class="line">    &quot;kubernetes.default.svc.cluster.local&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;names&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">      &quot;ST&quot;: &quot;Beijing&quot;,</span><br><span class="line">      &quot;L&quot;: &quot;Beijing&quot;,</span><br><span class="line">      &quot;O&quot;: &quot;xgxy&quot;,</span><br><span class="line">      &quot;OU&quot;: &quot;ops&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><blockquote><p>以上 IP 为我们的 k8s-master 节点 IP、k8s-work 节点 IP、k8s-ha 节点 IP、VIP，且这些 IP 都是必要的。</p><p>为了方便后期扩容可以多写几个预留的 IP，方便 master 或 work 的加入。</p><p>注意：hosts 字段不仅可写 IP，也可写域名。</p></blockquote><p>2、生成 apiserver 证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-apiserver-csr.json | cfssljson -bare kube-apiserver</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220829173940350.png" alt="image-20220829173940350"></p><p>3、配置 token文件</p><blockquote><p>其目的是为了实现自动签发证书，因为 Master apiserver 启用 TLS 认证后，work 节点的 kubelet、kube-proxy 与 kube-apiserver 进行通信时必须使用 CA 签发的有效证书，如果我有几百上千台 work 节点，那每次进行通信无疑都会增加工作量。</p><p>为了简化流程，Kubernetes 引入了 TLS bootstraping 机制来实现动态颁发客户端证书。目前主要用于kubelet，kube-proxy 还是由我们统一颁发一个证书。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; token.csv &lt;&lt; EOF</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(<span class="built_in">head</span> -c 16 /dev/urandom | <span class="built_in">od</span> -An -t x | <span class="built_in">tr</span> -d <span class="string">&#x27; &#x27;</span>),kubelet-bootstrap,10001,<span class="string">&quot;system:kubelet-bootstrap&quot;</span></span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>4、创建 apiserver 配置文件</p><blockquote><p>其实你会发现，流程与部署 ETCD 集群类似</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/kubernetes/&#123;conf,tokenfile,ssl,logs/kube-apiserver&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /data/kubernetes/conf</span><br></pre></td></tr></table></figure><ul><li><p>k8s-master1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /data/kubernetes/conf/kube-apiserver.conf &lt;&lt; &quot;EOF&quot;</span><br><span class="line">KUBE_APISERVER_OPTS=&quot;--enable-admission-plugins=NamespaceLifecycle,NodeRestriction,LimitRanger,ServiceAccount,DefaultStorageClass,ResourceQuota \</span><br><span class="line">  --anonymous-auth=false \</span><br><span class="line">  --bind-address=192.168.56.171 \</span><br><span class="line">  --secure-port=6443 \</span><br><span class="line">  --advertise-address=192.168.56.171 \</span><br><span class="line">  --authorization-mode=Node,RBAC \</span><br><span class="line">  --runtime-config=api/all=true \</span><br><span class="line">  --enable-bootstrap-token-auth \</span><br><span class="line">  --service-cluster-ip-range=10.96.0.0/16 \</span><br><span class="line">  --token-auth-file=/data/kubernetes/tokenfile/token.csv \</span><br><span class="line">  --service-node-port-range=30000-50000 \</span><br><span class="line">  --tls-cert-file=/data/kubernetes/ssl/kube-apiserver.pem  \</span><br><span class="line">  --tls-private-key-file=/data/kubernetes/ssl/kube-apiserver-key.pem \</span><br><span class="line">  --client-ca-file=/data/kubernetes/ssl/ca.pem \</span><br><span class="line">  --kubelet-client-certificate=/data/kubernetes/ssl/kube-apiserver.pem \</span><br><span class="line">  --kubelet-client-key=/data/kubernetes/ssl/kube-apiserver-key.pem \</span><br><span class="line">  --service-account-key-file=/data/kubernetes/ssl/ca-key.pem \</span><br><span class="line">  --service-account-signing-key-file=/data/kubernetes/ssl/ca-key.pem  \</span><br><span class="line">  --service-account-issuer=api \</span><br><span class="line">  --etcd-cafile=/data/etcd/ssl/ca.pem \</span><br><span class="line">  --etcd-certfile=/data/etcd/ssl/etcd.pem \</span><br><span class="line">  --etcd-keyfile=/data/etcd/ssl/etcd-key.pem \</span><br><span class="line">  --etcd-servers=https://192.168.56.171:2379,https://192.168.56.172:2379,https://192.168.56.173:2379 \</span><br><span class="line">  --allow-privileged=true \</span><br><span class="line">  --apiserver-count=3 \</span><br><span class="line">  --audit-log-maxage=30 \</span><br><span class="line">  --audit-log-maxbackup=3 \</span><br><span class="line">  --audit-log-maxsize=100 \</span><br><span class="line">  --audit-log-path=/data/kubernetes/logs/kube-apiserver/kube-apiserver-audit.log \</span><br><span class="line">  --event-ttl=1h \</span><br><span class="line">  --alsologtostderr=true \</span><br><span class="line">  --logtostderr=false \</span><br><span class="line">  --log-dir=/data/kubernetes/logs/kube-apiserver \</span><br><span class="line">  --v=4&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>k8s-master2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /data/kubernetes/conf/kube-apiserver.conf &lt;&lt; &quot;EOF&quot;</span><br><span class="line">KUBE_APISERVER_OPTS=&quot;--enable-admission-plugins=NamespaceLifecycle,NodeRestriction,LimitRanger,ServiceAccount,DefaultStorageClass,ResourceQuota \</span><br><span class="line">  --anonymous-auth=false \</span><br><span class="line">  --bind-address=192.168.56.172 \</span><br><span class="line">  --secure-port=6443 \</span><br><span class="line">  --advertise-address=192.168.56.172 \</span><br><span class="line">  --authorization-mode=Node,RBAC \</span><br><span class="line">  --runtime-config=api/all=true \</span><br><span class="line">  --enable-bootstrap-token-auth \</span><br><span class="line">  --service-cluster-ip-range=10.96.0.0/16 \</span><br><span class="line">  --token-auth-file=/data/kubernetes/tokenfile/token.csv \</span><br><span class="line">  --service-node-port-range=30000-50000 \</span><br><span class="line">  --tls-cert-file=/data/kubernetes/ssl/kube-apiserver.pem  \</span><br><span class="line">  --tls-private-key-file=/data/kubernetes/ssl/kube-apiserver-key.pem \</span><br><span class="line">  --client-ca-file=/data/kubernetes/ssl/ca.pem \</span><br><span class="line">  --kubelet-client-certificate=/data/kubernetes/ssl/kube-apiserver.pem \</span><br><span class="line">  --kubelet-client-key=/data/kubernetes/ssl/kube-apiserver-key.pem \</span><br><span class="line">  --service-account-key-file=/data/kubernetes/ssl/ca-key.pem \</span><br><span class="line">  --service-account-signing-key-file=/data/kubernetes/ssl/ca-key.pem  \</span><br><span class="line">  --service-account-issuer=api \</span><br><span class="line">  --etcd-cafile=/data/etcd/ssl/ca.pem \</span><br><span class="line">  --etcd-certfile=/data/etcd/ssl/etcd.pem \</span><br><span class="line">  --etcd-keyfile=/data/etcd/ssl/etcd-key.pem \</span><br><span class="line">  --etcd-servers=https://192.168.56.171:2379,https://192.168.56.172:2379,https://192.168.56.173:2379 \</span><br><span class="line">  --allow-privileged=true \</span><br><span class="line">  --apiserver-count=3 \</span><br><span class="line">  --audit-log-maxage=30 \</span><br><span class="line">  --audit-log-maxbackup=3 \</span><br><span class="line">  --audit-log-maxsize=100 \</span><br><span class="line">  --audit-log-path=/data/kubernetes/logs/kube-apiserver/kube-apiserver-audit.log \</span><br><span class="line">  --event-ttl=1h \</span><br><span class="line">  --alsologtostderr=true \</span><br><span class="line">  --logtostderr=false \</span><br><span class="line">  --log-dir=/data/kubernetes/logs/kube-apiserver \</span><br><span class="line">  --v=4&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>k8s-master3</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /data/kubernetes/conf/kube-apiserver.conf &lt;&lt; &quot;EOF&quot;</span><br><span class="line">KUBE_APISERVER_OPTS=&quot;--enable-admission-plugins=NamespaceLifecycle,NodeRestriction,LimitRanger,ServiceAccount,DefaultStorageClass,ResourceQuota \</span><br><span class="line">  --anonymous-auth=false \</span><br><span class="line">  --bind-address=192.168.56.173 \</span><br><span class="line">  --secure-port=6443 \</span><br><span class="line">  --advertise-address=192.168.56.173 \</span><br><span class="line">  --authorization-mode=Node,RBAC \</span><br><span class="line">  --runtime-config=api/all=true \</span><br><span class="line">  --enable-bootstrap-token-auth \</span><br><span class="line">  --service-cluster-ip-range=10.96.0.0/16 \</span><br><span class="line">  --token-auth-file=/data/kubernetes/tokenfile/token.csv \</span><br><span class="line">  --service-node-port-range=30000-50000 \</span><br><span class="line">  --tls-cert-file=/data/kubernetes/ssl/kube-apiserver.pem  \</span><br><span class="line">  --tls-private-key-file=/data/kubernetes/ssl/kube-apiserver-key.pem \</span><br><span class="line">  --client-ca-file=/data/kubernetes/ssl/ca.pem \</span><br><span class="line">  --kubelet-client-certificate=/data/kubernetes/ssl/kube-apiserver.pem \</span><br><span class="line">  --kubelet-client-key=/data/kubernetes/ssl/kube-apiserver-key.pem \</span><br><span class="line">  --service-account-key-file=/data/kubernetes/ssl/ca-key.pem \</span><br><span class="line">  --service-account-signing-key-file=/data/kubernetes/ssl/ca-key.pem  \</span><br><span class="line">  --service-account-issuer=api \</span><br><span class="line">  --etcd-cafile=/data/etcd/ssl/ca.pem \</span><br><span class="line">  --etcd-certfile=/data/etcd/ssl/etcd.pem \</span><br><span class="line">  --etcd-keyfile=/data/etcd/ssl/etcd-key.pem \</span><br><span class="line">  --etcd-servers=https://192.168.56.171:2379,https://192.168.56.172:2379,https://192.168.56.173:2379 \</span><br><span class="line">  --allow-privileged=true \</span><br><span class="line">  --apiserver-count=3 \</span><br><span class="line">  --audit-log-maxage=30 \</span><br><span class="line">  --audit-log-maxbackup=3 \</span><br><span class="line">  --audit-log-maxsize=100 \</span><br><span class="line">  --audit-log-path=/data/kubernetes/logs/kube-apiserver/kube-apiserver-audit.log \</span><br><span class="line">  --event-ttl=1h \</span><br><span class="line">  --alsologtostderr=true \</span><br><span class="line">  --logtostderr=false \</span><br><span class="line">  --log-dir=/data/kubernetes/logs/kube-apiserver \</span><br><span class="line">  --v=4&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li></ul><p>5、配置 systemd 管理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /usr/lib/systemd/system/kube-apiserver.service &lt;&lt; &quot;EOF&quot;</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes API Server</span><br><span class="line">Documentation=https://github.com/kubernetes/kubernetes</span><br><span class="line">After=etcd.service</span><br><span class="line">Wants=etcd.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=-/data/kubernetes/conf/kube-apiserver.conf</span><br><span class="line">ExecStart=/usr/bin/kube-apiserver $KUBE_APISERVER_OPTS</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">Type=notify</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>6、根据配置文件中的配置，复制相关文件到指定目录中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">k8s-master1</span></span><br><span class="line">cd /data/k8s-work/cfssl/</span><br><span class="line">cp ca*.pem kube-apiserver*.pem /data/kubernetes/ssl/</span><br><span class="line">cp token.csv /data/kubernetes/tokenfile/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分发至k8s-master2</span></span><br><span class="line">cd /data/k8s-work/cfssl/</span><br><span class="line">scp ca*.pem kube-apiserver*.pem k8s-master2:/data/kubernetes/ssl/</span><br><span class="line">scp token.csv k8s-master2:/data/kubernetes/tokenfile/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分发至k8s-master3</span></span><br><span class="line">cd /data/k8s-work/cfssl/</span><br><span class="line">scp ca*.pem kube-apiserver*.pem k8s-master3:/data/kubernetes/ssl/</span><br><span class="line">scp token.csv k8s-master3:/data/kubernetes/tokenfile/</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220829183321945.png" alt="image-20220829183321945"></p><p>7、启动 apiserver</p><blockquote><p>三台 k8s-master 均启动</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kube-apiserver.service</span><br><span class="line">systemctl enable kube-apiserver.service</span><br></pre></td></tr></table></figure><p>8、验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl --insecure https://192.168.56.171:6443/</span><br><span class="line">curl --insecure https://192.168.56.172:6443/</span><br><span class="line">curl --insecure https://192.168.56.173:6443/</span><br><span class="line">curl --insecure https://192.168.56.178:6443/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">均为验证，401，通过curl没有通过身份验证，所以是正常</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220830100749696.png" alt="image-20220830100749696"></p><h6 id="4-3-2-1-3-kubectl"><a href="#4-3-2-1-3-kubectl" class="headerlink" title="4.3.2.1.3 kubectl"></a>4.3.2.1.3 kubectl</h6><p>严格意义上来讲，kubectl 并不是 k8s-master 的组件，而是一个客户端工具，也就是说没有 kubectl，那我的 K8s 集群也是可以正常运行的。</p><p>1、配置 kubectl 证书请求文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /data/k8s-work/cfssl</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; kubectl-csr.json &lt;&lt; &quot;EOF&quot;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;admin&quot;,</span><br><span class="line">  &quot;hosts&quot;: [],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;names&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">      &quot;ST&quot;: &quot;Beijing&quot;,</span><br><span class="line">      &quot;L&quot;: &quot;Beijing&quot;,</span><br><span class="line">      &quot;O&quot;: &quot;system:masters&quot;,             </span><br><span class="line">      &quot;OU&quot;: &quot;system&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个admin 证书，是将来生成管理员用的kubeconfig 配置文件用的</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">现在我们一般建议使用RBAC 来对kubernetes 进行角色权限控制</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubernetes 将证书中的CN 字段 作为User， O 字段作为 Group；</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&quot;O&quot;</span>: <span class="string">&quot;system:masters&quot;</span>, 必须是system:masters，否则后面kubectl create clusterrolebinding报错。</span></span><br></pre></td></tr></table></figure><p>2、生成 kubectl 证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kubectl-csr.json | cfssljson -bare kubectl</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220830103602218.png" alt="image-20220830103602218"></p><p>3、复制相关证书到 k8s-master 目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">k8s-master1</span></span><br><span class="line">cp kubectl*.pem /data/kubernetes/ssl/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分发至k8s-master2</span></span><br><span class="line">scp kubectl*.pem k8s-master2:/data/kubernetes/ssl/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分发至k8s-master3</span></span><br><span class="line">scp kubectl*.pem k8s-master3:/data/kubernetes/ssl/</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220830103919560.png" alt="image-20220830103919560"></p><p>4、生成 kubeconfig 配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /data/k8s-work/cfssl</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">192.168.56.178 为VIP，如果没有做master高可用，则为master节点IP</span></span><br><span class="line">kubectl config set-cluster kubernetes --certificate-authority=ca.pem --embed-certs=true --server=https://192.168.56.178:6443 --kubeconfig=kube.config</span><br><span class="line"></span><br><span class="line">kubectl config set-credentials admin --client-certificate=kubectl.pem --client-key=kubectl-key.pem --embed-certs=true --kubeconfig=kube.config</span><br><span class="line"></span><br><span class="line">kubectl config set-context kubernetes --cluster=kubernetes --user=admin --kubeconfig=kube.config</span><br><span class="line"></span><br><span class="line">kubectl config use-context kubernetes --kubeconfig=kube.config</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kube.config为kubectl的配置文件，包含访问apiserver的所有信息，如apiserver地址、CA证书和自身使用的证书等</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220830104838097.png" alt="image-20220830104838097"></p><p>5、对 kubeconfig 配置文件进行角色绑定</p><p>也就是说我当前 centos 操作系统的登录用户为 root，那我们一般会将该 kube.config 复制到当前用户家目录下进行管理，以此来管理我整个 K8s 集群。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /data/k8s-work/cfssl</span><br><span class="line">mkdir ~/.kube</span><br><span class="line">cp kube.config ~/.kube/config</span><br><span class="line">kubectl create clusterrolebinding kube-apiserver:kubelet-apis --clusterrole=system:kubelet-api-admin --user kubernetes --kubeconfig=/root/.kube/config</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220830105627119.png" alt="image-20220830105627119"></p><p>6、kubectl 命令验证</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">查看集群信息</span><br><span class="line">kubectl cluster<span class="literal">-info</span></span><br><span class="line"></span><br><span class="line">查看集群组件状态，可看到警告提示：ComponentStatu在<span class="number">1.19</span>+版本已经被弃用了（我当前为<span class="number">1.24</span>.<span class="number">4</span>）</span><br><span class="line">kubectl get componentstatuses</span><br><span class="line"></span><br><span class="line">查看命名空间中资源对象</span><br><span class="line">kubectl get all <span class="literal">--all-namespaces</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220830105928998.png" alt="image-20220830105928998"></p><p>&#x3D;&#x3D;如果你也希望其他 k8s-master 节点也具备管理能力，那你需要复制相关证书文件至其他 k8s-master 节点&#x3D;&#x3D;</p><p>证书在上面已经分发到 k8s-master 的其他节点了，接下来只需要在其他 k8s-master 节点家目录创建相关文件，并将 k8s-master1 上配置好的 config 配置文件分发至其他 k8s-master 节点对应目录下即可。</p><ul><li><p>先在其他 k8s-master 节点创建目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">k8s-master2:</span></span><br><span class="line">mkdir /root/.kube</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">k8s-master3:</span></span><br><span class="line">mkdir /root/.kube</span><br></pre></td></tr></table></figure></li><li><p>在 k8s-master1 分发配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp /root/.kube/config k8s-master2:/root/.kube/config</span><br><span class="line">scp /root/.kube/config k8s-master3:/root/.kube/config</span><br></pre></td></tr></table></figure></li></ul><p>&#x3D;&#x3D;这样的话，所有 k8s-master 节点都具备 K8s 集群的管理能力了。&#x3D;&#x3D;</p><p>kubectl 命令补全（所有 k8s-master 节点执行）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum install -y bash-completion</span><br><span class="line">source /usr/share/bash-completion/bash_completion</span><br><span class="line">source &lt;(kubectl completion bash)</span><br><span class="line">kubectl completion bash &gt; ~/.kube/completion.bash.inc</span><br><span class="line">source &#x27;/root/.kube/completion.bash.inc&#x27;  </span><br><span class="line">source $HOME/.bash_profile</span><br></pre></td></tr></table></figure><h6 id="4-3-2-1-4-kube-controller-manager"><a href="#4-3-2-1-4-kube-controller-manager" class="headerlink" title="4.3.2.1.4 kube-controller-manager"></a>4.3.2.1.4 kube-controller-manager</h6><p>1、配置 kube-controller-manager 证书请求文件</p><blockquote><p>因为我们部署的是 k8s-master 的高可用，所以 kube-controller-manager 也是配置的高可用</p><p>同理，也是统一在 k8s-master 节点 cfssl 目录下执行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /data/k8s-work/cfssl</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; kube-controller-manager-csr.json &lt;&lt; &quot;EOF&quot;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;CN&quot;: &quot;system:kube-controller-manager&quot;,</span><br><span class="line">    &quot;key&quot;: &#123;</span><br><span class="line">        &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">        &quot;size&quot;: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;hosts&quot;: [</span><br><span class="line">      &quot;127.0.0.1&quot;,</span><br><span class="line">      &quot;192.168.56.171&quot;,</span><br><span class="line">      &quot;192.168.56.172&quot;,</span><br><span class="line">      &quot;192.168.56.173&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;names&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">        &quot;ST&quot;: &quot;Beijing&quot;,</span><br><span class="line">        &quot;L&quot;: &quot;Beijing&quot;,</span><br><span class="line">        &quot;O&quot;: &quot;system:kube-controller-manager&quot;,</span><br><span class="line">        &quot;OU&quot;: &quot;system&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hosts列表包含所有kube-controller-manager节点IP</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CN为system:kube-controller-manager</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">O为system:kube-controller-manager，其为kubernetes内置的ClusterRoleBindings</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">system:kube-controller-manager赋予kube-controller-manager工作所需的权限</span></span><br></pre></td></tr></table></figure><p>2、生成 kube-controller-manager 证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-controller-manager-csr.json | cfssljson -bare kube-controller-manager</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220830112802956.png" alt="image-20220830112802956"></p><p>3、生成 kube-controller-manager 的 .kubeconfig 配置文件</p><blockquote><p>与 kubectl 类似，想要进行 k8s 集群控制，就需要进行相关配置。</p><p>同样是在 k8s-master1 的 cfssl 目录下执行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl config set-cluster kubernetes --certificate-authority=ca.pem --embed-certs=true --server=https://192.168.56.178:6443 --kubeconfig=kube-controller-manager.kubeconfig</span><br><span class="line"></span><br><span class="line">kubectl config set-credentials system:kube-controller-manager --client-certificate=kube-controller-manager.pem --client-key=kube-controller-manager-key.pem --embed-certs=true --kubeconfig=kube-controller-manager.kubeconfig</span><br><span class="line"></span><br><span class="line">kubectl config set-context system:kube-controller-manager --cluster=kubernetes --user=system:kube-controller-manager --kubeconfig=kube-controller-manager.kubeconfig</span><br><span class="line"></span><br><span class="line">kubectl config use-context system:kube-controller-manager --kubeconfig=kube-controller-manager.kubeconfig</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220830113733447.png" alt="image-20220830113733447"></p><p>4、创建 kube-controller-manager 的 .conf 配置文件</p><blockquote><p>同样是在 k8s-master1 的 cfssl 目录下执行。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; kube-controller-manager.conf &lt;&lt; &quot;EOF&quot;</span><br><span class="line">KUBE_CONTROLLER_MANAGER_OPTS=&quot;--secure-port=10257 \</span><br><span class="line">  --bind-address=127.0.0.1 \</span><br><span class="line">  --kubeconfig=/data/kubernetes/conf/kube-controller-manager.kubeconfig \</span><br><span class="line">  --service-cluster-ip-range=10.96.0.0/16 \</span><br><span class="line">  --cluster-name=kubernetes \</span><br><span class="line">  --cluster-signing-cert-file=/data/kubernetes/ssl/ca.pem \</span><br><span class="line">  --cluster-signing-key-file=/data/kubernetes/ssl/ca-key.pem \</span><br><span class="line">  --allocate-node-cidrs=true \</span><br><span class="line">  --cluster-cidr=10.244.0.0/16 \</span><br><span class="line">  --experimental-cluster-signing-duration=87600h \</span><br><span class="line">  --root-ca-file=/data/kubernetes/ssl/ca.pem \</span><br><span class="line">  --service-account-private-key-file=/data/kubernetes/ssl/ca-key.pem \</span><br><span class="line">  --leader-elect=true \</span><br><span class="line">  --feature-gates=RotateKubeletServerCertificate=true \</span><br><span class="line">  --controllers=*,bootstrapsigner,tokencleaner \</span><br><span class="line">  --tls-cert-file=/data/kubernetes/ssl/kube-controller-manager.pem \</span><br><span class="line">  --tls-private-key-file=/data/kubernetes/ssl/kube-controller-manager-key.pem \</span><br><span class="line">  --use-service-account-credentials=true \</span><br><span class="line">  --alsologtostderr=true \</span><br><span class="line">  --logtostderr=false \</span><br><span class="line">  --log-dir=/data/kubernetes/logs/kube-controller-manager \</span><br><span class="line">  --v=2&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建kube-controller-manager日志目录（所有k8s-master节点均执行）</span></span><br><span class="line">mkdir /data/kubernetes/logs/kube-controller-manager</span><br></pre></td></tr></table></figure><p>5、复制相关证书文件至配置文件中的指定目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">k8s-master1</span></span><br><span class="line">cd /data/k8s-work/cfssl</span><br><span class="line">cp kube-controller-manager*.pem /data/kubernetes/ssl/</span><br><span class="line">cp kube-controller-manager.kubeconfig /data/kubernetes/conf/</span><br><span class="line">cp kube-controller-manager.conf /data/kubernetes/conf/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分发至k8s-master2</span></span><br><span class="line">scp kube-controller-manager*.pem k8s-master2:/data/kubernetes/ssl/</span><br><span class="line">scp kube-controller-manager.kubeconfig k8s-master2:/data/kubernetes/conf/</span><br><span class="line">scp kube-controller-manager.conf k8s-master2:/data/kubernetes/conf/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分发至k8s-master3</span></span><br><span class="line">scp kube-controller-manager*.pem k8s-master3:/data/kubernetes/ssl/</span><br><span class="line">scp kube-controller-manager.kubeconfig k8s-master3:/data/kubernetes/conf/</span><br><span class="line">scp kube-controller-manager.conf k8s-master3:/data/kubernetes/conf/</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220830115607487.png" alt="image-20220830115607487"></p><p>6、配置 systemd 管理</p><blockquote><p>k8s-master 所有节点均执行，或者在 k8s-master1 上执行完成后再分发至其他 master 节点</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /usr/lib/systemd/system/kube-controller-manager.service &lt;&lt; &quot;EOF&quot;</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Controller Manager</span><br><span class="line">Documentation=https://github.com/kubernetes/kubernetes</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=-/data/kubernetes/conf/kube-controller-manager.conf</span><br><span class="line">ExecStart=/usr/bin/kube-controller-manager $KUBE_CONTROLLER_MANAGER_OPTS</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>7、启动 kube-controller-manager 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kube-controller-manager.service</span><br><span class="line">systemctl enable kube-controller-manager.service</span><br></pre></td></tr></table></figure><p>8、验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get componentstatuses</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220830125423606.png" alt="image-20220830125423606"></p><h6 id="4-3-2-1-5-kube-scheduler"><a href="#4-3-2-1-5-kube-scheduler" class="headerlink" title="4.3.2.1.5 kube-scheduler"></a>4.3.2.1.5 kube-scheduler</h6><p>1、配置 kube-scheduler 证书请求文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /data/k8s-work/cfssl</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; kube-scheduler-csr.json &lt;&lt; &quot;EOF&quot;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;CN&quot;: &quot;system:kube-scheduler&quot;,</span><br><span class="line">    &quot;hosts&quot;: [</span><br><span class="line">      &quot;127.0.0.1&quot;,</span><br><span class="line">      &quot;192.168.56.171&quot;,</span><br><span class="line">      &quot;192.168.56.172&quot;,</span><br><span class="line">      &quot;192.168.56.173&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;key&quot;: &#123;</span><br><span class="line">        &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">        &quot;size&quot;: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;names&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">        &quot;ST&quot;: &quot;Beijing&quot;,</span><br><span class="line">        &quot;L&quot;: &quot;Beijing&quot;,</span><br><span class="line">        &quot;O&quot;: &quot;system:kube-scheduler&quot;,</span><br><span class="line">        &quot;OU&quot;: &quot;system&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>2、生成 kube-scheduler 证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-scheduler-csr.json | cfssljson -bare kube-scheduler</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220830130500777.png" alt="image-20220830130500777"></p><p>3、生成 kube-scheduler 的 .kubeconfig 配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl config set-cluster kubernetes --certificate-authority=ca.pem --embed-certs=true --server=https://192.168.56.178:6443 --kubeconfig=kube-scheduler.kubeconfig</span><br><span class="line"></span><br><span class="line">kubectl config set-credentials system:kube-scheduler --client-certificate=kube-scheduler.pem --client-key=kube-scheduler-key.pem --embed-certs=true --kubeconfig=kube-scheduler.kubeconfig</span><br><span class="line"></span><br><span class="line">kubectl config set-context system:kube-scheduler --cluster=kubernetes --user=system:kube-scheduler --kubeconfig=kube-scheduler.kubeconfig</span><br><span class="line"></span><br><span class="line">kubectl config use-context system:kube-scheduler --kubeconfig=kube-scheduler.kubeconfig</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220830130910387.png" alt="image-20220830130910387"></p><p>4、创建 kube-scheduler 的 .conf 配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /data/k8s-work/cfssl</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; kube-scheduler.conf &lt;&lt; &quot;EOF&quot;</span><br><span class="line">KUBE_SCHEDULER_OPTS=&quot;--kubeconfig=/data/kubernetes/conf/kube-scheduler.kubeconfig \</span><br><span class="line">--leader-elect=true \</span><br><span class="line">--alsologtostderr=true \</span><br><span class="line">--logtostderr=false \</span><br><span class="line">--log-dir=/data/kubernetes/logs/kube-scheduler \</span><br><span class="line">--v=2&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建kube-scheduler日志目录（所有k8s-master节点均执行）</span></span><br><span class="line">mkdir /data/kubernetes/logs/kube-scheduler</span><br></pre></td></tr></table></figure><p>5、复制相关证书文件至配置文件中的指定目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">k8s-master1</span></span><br><span class="line">cd /data/k8s-work/cfssl</span><br><span class="line">cp kube-scheduler*.pem /data/kubernetes/ssl/</span><br><span class="line">cp kube-scheduler.kubeconfig /data/kubernetes/conf/</span><br><span class="line">cp kube-scheduler.conf /data/kubernetes/conf/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分发至k8s-master2</span></span><br><span class="line">scp kube-scheduler*.pem k8s-master2:/data/kubernetes/ssl/</span><br><span class="line">scp kube-scheduler.kubeconfig k8s-master2:/data/kubernetes/conf/</span><br><span class="line">scp kube-scheduler.conf k8s-master2:/data/kubernetes/conf/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分发至k8s-master3</span></span><br><span class="line">scp kube-scheduler*.pem k8s-master3:/data/kubernetes/ssl/</span><br><span class="line">scp kube-scheduler.kubeconfig k8s-master3:/data/kubernetes/conf/</span><br><span class="line">scp kube-scheduler.conf k8s-master3:/data/kubernetes/conf/</span><br></pre></td></tr></table></figure><p>6、配置 systemd 管理</p><blockquote><p>k8s-master 所有节点均执行，或者在 k8s-master1 上执行完成后再分发至其他 master 节点</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /usr/lib/systemd/system/kube-scheduler.service &lt;&lt; &quot;EOF&quot;</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Scheduler</span><br><span class="line">Documentation=https://github.com/kubernetes/kubernetes</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=-/data/kubernetes/conf/kube-scheduler.conf</span><br><span class="line">ExecStart=/usr/bin/kube-scheduler $KUBE_SCHEDULER_OPTS</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>7、启动 kube-controller-manager 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kube-scheduler.service</span><br><span class="line">systemctl enable kube-scheduler.service</span><br></pre></td></tr></table></figure><p>8、验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get componentstatuses</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220830133247786.png" alt="image-20220830133247786"></p><p>&#x3D;&#x3D;至此，k8s-master 节点的所有组件已经部署完成，并已成功在运行。接下来就是部署 k8s-work 节点组件了。&#x3D;&#x3D;</p><h5 id="4-3-2-2-Work-节点"><a href="#4-3-2-2-Work-节点" class="headerlink" title="4.3.2.2 Work 节点"></a>4.3.2.2 Work 节点</h5><blockquote><p>k8s-master 必须的组件：kubelet、kube-proxy</p><p>k8s 在 1.20+ 开始，不再唯一支持 docker，而且也支持 Containerd，而 1.24+ 版本开始，完全移除 dockershim（不代表不可用，而是以其他方式进行使用 docker），对于 work 节点来说，容器化引擎是必须的。</p></blockquote><h6 id="4-3-2-2-1-部署说明"><a href="#4-3-2-2-1-部署说明" class="headerlink" title="4.3.2.2.1 部署说明"></a>4.3.2.2.1 部署说明</h6><blockquote><p>看看官方的解释</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220830135059526.png" alt="image-20220830135059526"></p><p>&#x3D;&#x3D;本次我将采用 Docker 的方式部署&#x3D;&#x3D;</p><h6 id="4-3-2-2-2-组件分发"><a href="#4-3-2-2-2-组件分发" class="headerlink" title="4.3.2.2.2 组件分发"></a>4.3.2.2.2 组件分发</h6><blockquote><p>在上面，我们下载了 kubernetes 的二进制包，里面包含了 master 节点和 work 节点的所有组件，因此在 k8s-master 节点上分发到 work 节点上即可。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /data/k8s-work/k8s/kubernetes/server/bin</span><br><span class="line">scp kubelet kube-proxy k8s-work1:/usr/bin/</span><br><span class="line">scp kubelet kube-proxy k8s-work2:/usr/bin/</span><br></pre></td></tr></table></figure><h6 id="4-3-2-2-3-docker"><a href="#4-3-2-2-3-docker" class="headerlink" title="4.3.2.2.3 docker"></a>4.3.2.2.3 docker</h6><p>1、安装 docker 引擎</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh docker_install.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要安装脚本的私信</span></span><br></pre></td></tr></table></figure><p>2、修改 cgroup</p><blockquote><p>k8s 和 docker 的 cgroup 必须保持一致，这里官方推荐为 systemd。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/docker/daemon.json </span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://q1rw9tzz.mirror.aliyuncs.com&quot;],</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-3-2-2-4-cri-dockerd"><a href="#4-3-2-2-4-cri-dockerd" class="headerlink" title="4.3.2.2.4 cri-dockerd"></a>4.3.2.2.4 cri-dockerd</h6><blockquote><p>想要使用 docker 作为 k8s 的编排对象，那需要安装 cri-docker 来作为 dockershim。</p><p>cri-docker 源码安装地址：<a href="https://github.com/Mirantis/cri-dockerd">https://github.com/Mirantis/cri-dockerd</a></p></blockquote><p>1、安装 Go 环境</p><blockquote><p>k8s-work 节点执行</p></blockquote><p>因为 cri-dockerd 由 go 编写，所以 k8s-work 主机需具备 go 环境。go 二进制包下载地址：<a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220830144911203.png" alt="image-20220830144911203"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">k8s-work1</span></span><br><span class="line">tar xzf go1.18.5.linux-amd64.tar.gz -C /opt/</span><br><span class="line">ln -s /opt/go/bin/* /usr/bin/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">k8s-work2</span></span><br><span class="line">tar xzf go1.18.5.linux-amd64.tar.gz -C /opt/</span><br><span class="line">ln -s /opt/go/bin/* /usr/bin/</span><br></pre></td></tr></table></figure><p>2、clone 源码项目并编译</p><blockquote><p>安装官方文档来部署即可</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220830151256425.png" alt="image-20220830151256425"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">GO环境我们已经有了</span></span><br><span class="line">git clone https://github.com/Mirantis/cri-dockerd.git</span><br><span class="line">cd cri-dockerd</span><br><span class="line">mkdir bin</span><br><span class="line">go build -o bin/cri-dockerd</span><br><span class="line">mkdir -p /usr/local/bin</span><br><span class="line">install -o root -g root -m 0755 bin/cri-dockerd /usr/local/bin/cri-dockerd</span><br><span class="line">cp -a packaging/systemd/* /etc/systemd/system</span><br><span class="line">sed -i -e &#x27;s,/usr/bin/cri-dockerd,/usr/local/bin/cri-dockerd,&#x27; /etc/systemd/system/cri-docker.service</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable cri-docker.service</span><br><span class="line">systemctl enable --now cri-docker.socket</span><br></pre></td></tr></table></figure><blockquote><p>最后看看是否启动成功（下图，成功启动并正在监听）</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220830152319042.png" alt="image-20220830152319042"></p><p>3、修改 cri-docker 的 systemd 文件</p><ul><li><p>修改前</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=CRI Interface for Docker Application Container Engine</span><br><span class="line">Documentation=https://docs.mirantis.com</span><br><span class="line">After=network-online.target firewalld.service docker.service</span><br><span class="line">Wants=network-online.target</span><br><span class="line">Requires=cri-docker.socket</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">ExecStart=/usr/local/bin/cri-dockerd --container-runtime-endpoint fd://</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">TimeoutSec=0</span><br><span class="line">RestartSec=2</span><br><span class="line">Restart=always</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Note that StartLimit* options were moved from <span class="string">&quot;Service&quot;</span> to <span class="string">&quot;Unit&quot;</span> <span class="keyword">in</span> systemd 229.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Both the old, and new location are accepted by systemd 229 and up, so using the old location</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">to make them work <span class="keyword">for</span> either version of systemd.</span></span><br><span class="line">StartLimitBurst=3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Note that StartLimitInterval was renamed to StartLimitIntervalSec <span class="keyword">in</span> systemd 230.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Both the old, and new name are accepted by systemd 230 and up, so using the old name to make</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">this option work <span class="keyword">for</span> either version of systemd.</span></span><br><span class="line">StartLimitInterval=60s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Having non-zero Limit*s causes performance problems due to accounting overhead</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">in</span> the kernel. We recommend using cgroups to <span class="keyword">do</span> container-local accounting.</span></span><br><span class="line">LimitNOFILE=infinity</span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Comment TasksMax <span class="keyword">if</span> your systemd version does not support it.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Only systemd 226 and above support this option.</span></span><br><span class="line">TasksMax=infinity</span><br><span class="line">Delegate=yes</span><br><span class="line">KillMode=process</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></li><li><p>修改后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=CRI Interface for Docker Application Container Engine</span><br><span class="line">Documentation=https://docs.mirantis.com</span><br><span class="line">After=network-online.target firewalld.service docker.service</span><br><span class="line">Wants=network-online.target</span><br><span class="line">Requires=cri-docker.socket</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">ExecStart=/usr/local/bin/cri-dockerd --container-runtime-endpoint fd:// --network-plugin=cni --pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.7</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">TimeoutSec=0</span><br><span class="line">RestartSec=2</span><br><span class="line">Restart=always</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Note that StartLimit* options were moved from <span class="string">&quot;Service&quot;</span> to <span class="string">&quot;Unit&quot;</span> <span class="keyword">in</span> systemd 229.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Both the old, and new location are accepted by systemd 229 and up, so using the old location</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">to make them work <span class="keyword">for</span> either version of systemd.</span></span><br><span class="line">StartLimitBurst=3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Note that StartLimitInterval was renamed to StartLimitIntervalSec <span class="keyword">in</span> systemd 230.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Both the old, and new name are accepted by systemd 230 and up, so using the old name to make</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">this option work <span class="keyword">for</span> either version of systemd.</span></span><br><span class="line">StartLimitInterval=60s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Having non-zero Limit*s causes performance problems due to accounting overhead</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">in</span> the kernel. We recommend using cgroups to <span class="keyword">do</span> container-local accounting.</span></span><br><span class="line">LimitNOFILE=infinity</span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Comment TasksMax <span class="keyword">if</span> your systemd version does not support it.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Only systemd 226 and above support this option.</span></span><br><span class="line">TasksMax=infinity</span><br><span class="line">Delegate=yes</span><br><span class="line">KillMode=process</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></li></ul><h6 id="4-3-2-2-5-kubelet"><a href="#4-3-2-2-5-kubelet" class="headerlink" title="4.3.2.2.5 kubelet"></a>4.3.2.2.5 kubelet</h6><blockquote><p>同样在 k8s-master1 上执行</p></blockquote><p>1、创建 kubelet 的 .kubeconfig 配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /data/k8s-work/cfssl/</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BOOTSTRAP_TOKEN=$(awk -F &quot;,&quot; &#x27;&#123;print $1&#125;&#x27; /data/kubernetes/tokenfile/token.csv)</span><br><span class="line"></span><br><span class="line">kubectl config set-cluster kubernetes --certificate-authority=ca.pem --embed-certs=true --server=https://192.168.56.178:6443 --kubeconfig=kubelet-bootstrap.kubeconfig</span><br><span class="line"></span><br><span class="line">kubectl config set-credentials kubelet-bootstrap --token=$&#123;BOOTSTRAP_TOKEN&#125; --kubeconfig=kubelet-bootstrap.kubeconfig</span><br><span class="line"></span><br><span class="line">kubectl config set-context default --cluster=kubernetes --user=kubelet-bootstrap --kubeconfig=kubelet-bootstrap.kubeconfig</span><br><span class="line"></span><br><span class="line">kubectl config use-context default --kubeconfig=kubelet-bootstrap.kubeconfig</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220830155243172.png" alt="image-20220830155243172"></p><blockquote><p>指定角色</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl create clusterrolebinding cluster-system-anonymous --clusterrole=cluster-admin --user=kubelet-bootstrap</span><br><span class="line"></span><br><span class="line">kubectl create clusterrolebinding kubelet-bootstrap --clusterrole=system:node-bootstrapper --user=kubelet-bootstrap --kubeconfig=kubelet-bootstrap.kubeconfig</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220830155351265.png" alt="image-20220830155351265"></p><blockquote><p>基础验证</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe clusterrolebinding cluster-system-anonymous</span><br><span class="line">kubectl describe clusterrolebinding kubelet-bootstrap</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220830155445682.png" alt="image-20220830155445682"></p><p>4、创建 kubelet 的 .conf 配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; kubelet.json &lt;&lt; &quot;EOF&quot;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;kind&quot;: &quot;KubeletConfiguration&quot;,</span><br><span class="line">  &quot;apiVersion&quot;: &quot;kubelet.config.k8s.io/v1beta1&quot;,</span><br><span class="line">  &quot;authentication&quot;: &#123;</span><br><span class="line">    &quot;x509&quot;: &#123;</span><br><span class="line">      &quot;clientCAFile&quot;: &quot;/data/kubernetes/ssl/ca.pem&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;webhook&quot;: &#123;</span><br><span class="line">      &quot;enabled&quot;: true,</span><br><span class="line">      &quot;cacheTTL&quot;: &quot;2m0s&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;anonymous&quot;: &#123;</span><br><span class="line">      &quot;enabled&quot;: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;authorization&quot;: &#123;</span><br><span class="line">    &quot;mode&quot;: &quot;Webhook&quot;,</span><br><span class="line">    &quot;webhook&quot;: &#123;</span><br><span class="line">      &quot;cacheAuthorizedTTL&quot;: &quot;5m0s&quot;,</span><br><span class="line">      &quot;cacheUnauthorizedTTL&quot;: &quot;30s&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;address&quot;: &quot;192.168.56.174&quot;,</span><br><span class="line">  &quot;port&quot;: 10250,</span><br><span class="line">  &quot;readOnlyPort&quot;: 10255,</span><br><span class="line">  &quot;cgroupDriver&quot;: &quot;systemd&quot;,                    </span><br><span class="line">  &quot;hairpinMode&quot;: &quot;promiscuous-bridge&quot;,</span><br><span class="line">  &quot;serializeImagePulls&quot;: false,</span><br><span class="line">  &quot;clusterDomain&quot;: &quot;cluster.local.&quot;,</span><br><span class="line">  &quot;clusterDNS&quot;: [&quot;10.96.0.2&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">address：work节点对应的IP（分发至其他work节点后记得修改IP地址）</span></span><br></pre></td></tr></table></figure><p>5、复制相关证书文件至配置文件中的指定 work 节点目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先在k8s-work节点创建相关目录</span></span><br><span class="line">mkdir -p /data/kubernetes/&#123;conf,ssl,logs/kubelet&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分发至k8s-work1</span></span><br><span class="line">scp kubelet-bootstrap.kubeconfig kubelet.json k8s-work1:/data/kubernetes/conf/</span><br><span class="line">scp ca.pem k8s-work1:/data/kubernetes/ssl/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分发至k8s-work2</span></span><br><span class="line">scp kubelet-bootstrap.kubeconfig kubelet.json k8s-work2:/data/kubernetes/conf/</span><br><span class="line">scp ca.pem k8s-work2:/data/kubernetes/ssl/</span><br></pre></td></tr></table></figure><p>6、配置 systemd 管理</p><blockquote><p>k8s-work 所有节点均执行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /usr/lib/systemd/system/kubelet.service &lt;&lt; &quot;EOF&quot;</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Kubelet</span><br><span class="line">Documentation=https://github.com/kubernetes/kubernetes</span><br><span class="line">After=docker.service</span><br><span class="line">Requires=docker.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/bin/kubelet \</span><br><span class="line">  --bootstrap-kubeconfig=/data/kubernetes/conf/kubelet-bootstrap.kubeconfig \</span><br><span class="line">  --cert-dir=/data/kubernetes/ssl \</span><br><span class="line">  --kubeconfig=/data/kubernetes/conf/kubelet.kubeconfig \</span><br><span class="line">  --config=/data/kubernetes/conf/kubelet.json \</span><br><span class="line">  --container-runtime=remote \</span><br><span class="line">  --container-runtime-endpoint=unix:///var/run/cri-dockerd.sock \</span><br><span class="line">  --rotate-certificates \</span><br><span class="line">  --alsologtostderr=true \</span><br><span class="line">  --logtostderr=false \</span><br><span class="line">  --log-dir=/data/kubernetes/logs/kubelet \</span><br><span class="line">  --v=2</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>7、启动 kubelet 组件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kubelet.service</span><br><span class="line">systemctl enable kubelet.service</span><br></pre></td></tr></table></figure><p>8、验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意：我的master节点并没有进工作负载</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220830180454193.png" alt="image-20220830180454193"></p><h6 id="4-3-2-2-6-kube-proxy"><a href="#4-3-2-2-6-kube-proxy" class="headerlink" title="4.3.2.2.6 kube-proxy"></a>4.3.2.2.6 kube-proxy</h6><p>1、配置 kube-proxy 证书请求文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /data/k8s-work/cfssl</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; kube-proxy-csr.json &lt;&lt; &quot;EOF&quot;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;system:kube-proxy&quot;,</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;names&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">      &quot;ST&quot;: &quot;Beijing&quot;,</span><br><span class="line">      &quot;L&quot;: &quot;Beijing&quot;,</span><br><span class="line">      &quot;O&quot;: &quot;xgxy&quot;,</span><br><span class="line">      &quot;OU&quot;: &quot;ops&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>2、生成 kube-proxy 证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220830181238980.png" alt="image-20220830181238980"></p><p>3、生成 kube-proxy 的 .kubeconfig 配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl config set-cluster kubernetes --certificate-authority=ca.pem --embed-certs=true --server=https://192.168.56.178:6443 --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line"></span><br><span class="line">kubectl config set-credentials kube-proxy --client-certificate=kube-proxy.pem --client-key=kube-proxy-key.pem --embed-certs=true --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line"></span><br><span class="line">kubectl config set-context default --cluster=kubernetes --user=kube-proxy --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line"></span><br><span class="line">kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220830181512383.png" alt="image-20220830181512383"></p><p>4、创建 kube-proxy 的 .yaml 配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /data/k8s-work/cfssl</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; kube-proxy.yaml &lt;&lt; &quot;EOF&quot;</span><br><span class="line">apiVersion: kubeproxy.config.k8s.io/v1alpha1</span><br><span class="line">bindAddress: 192.168.56.174</span><br><span class="line">clientConnection:</span><br><span class="line">  kubeconfig: /data/kubernetes/conf/kube-proxy.kubeconfig</span><br><span class="line">clusterCIDR: 10.244.0.0/16</span><br><span class="line">healthzBindAddress: 192.168.56.174:10256</span><br><span class="line">kind: KubeProxyConfiguration</span><br><span class="line">metricsBindAddress: 192.168.56.174:10249</span><br><span class="line">mode: &quot;ipvs&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>5、复制相关证书文件至配置文件中的指定目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分发至k8s-work1</span></span><br><span class="line">scp kube-proxy*.pem k8s-work1:/data/kubernetes/ssl/</span><br><span class="line">scp kube-proxy.kubeconfig kube-proxy.yaml k8s-work1:/data/kubernetes/conf/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分发至k8s-work2</span></span><br><span class="line">scp kube-proxy*.pem k8s-work2:/data/kubernetes/ssl/</span><br><span class="line">scp kube-proxy.kubeconfig kube-proxy.yaml k8s-work2:/data/kubernetes/conf/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分发后记得修改IP</span></span><br></pre></td></tr></table></figure><p>6、配置 systemd 管理</p><blockquote><p>k8s-work 所有节点均执行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /usr/lib/systemd/system/kube-proxy.service &lt;&lt; &quot;EOF&quot;</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Kube-Proxy Server</span><br><span class="line">Documentation=https://github.com/kubernetes/kubernetes</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/bin/kube-proxy \</span><br><span class="line">  --config=/data/kubernetes/conf/kube-proxy.yaml \</span><br><span class="line">  --alsologtostderr=true \</span><br><span class="line">  --logtostderr=false \</span><br><span class="line">  --log-dir=/data/kubernetes/logs/kube-proxy \</span><br><span class="line">  --v=2</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建kube-proxy日志目录（所有k8s-work节点均执行）</span></span><br><span class="line">mkdir /data/kubernetes/logs/kube-proxy</span><br></pre></td></tr></table></figure><p>7、启动 kube-proxy 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kube-proxy.service</span><br><span class="line">systemctl enable kube-proxy.service</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;至此，k8s-work 节点的所有组件已经部署完成，并已成功在运行。接下来就是部署 k8s 网络组件了。&#x3D;&#x3D;</p><h3 id="4-4-网络组件部署（Calico）"><a href="#4-4-网络组件部署（Calico）" class="headerlink" title="4.4 网络组件部署（Calico）"></a>4.4 网络组件部署（Calico）</h3><blockquote><p>对于高可用集群架构来说，在任意一台 master 节点上执行即可，因为Calico会以容器的方式部署于 work 节点上</p></blockquote><p>Calico是一个纯三层的数据中心网络方案，是目前Kubernetes主流的网络方案。在 3.4 小节的网络规划中，说到了 pod 的网络规划，那 Calico 就是用来分配该网络（IP）的。</p><h4 id="4-4-1-下载-yaml-文件"><a href="#4-4-1-下载-yaml-文件" class="headerlink" title="4.4.1 下载 yaml 文件"></a>4.4.1 下载 yaml 文件</h4><blockquote><p>yaml 文件下载地址：<a href="https://docs.projectcalico.org/">https://docs.projectcalico.org/</a></p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220831095736333.png" alt="image-20220831095736333"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同样在k8s-master1执行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先创建一个工作目录，用于存放yaml文件</span></span><br><span class="line">mkdir /data/k8s-work/calico &amp;&amp; cd /data/k8s-work/calico</span><br><span class="line">curl https://projectcalico.docs.tigera.io/archive/v3.23/manifests/calico-etcd.yaml -o calico.yaml</span><br></pre></td></tr></table></figure><h4 id="4-4-2-修改文件配置"><a href="#4-4-2-修改文件配置" class="headerlink" title="4.4.2 修改文件配置"></a>4.4.2 修改文件配置</h4><blockquote><p>在 391 行处，修改配置 value 值为上面定义的 10.244.0.0&#x2F;16</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220831100505327.png" alt="image-20220831100505327"></p><blockquote><p>修改后</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220831100747852.png" alt="image-20220831100747852"></p><h4 id="4-4-3-应用配置文件"><a href="#4-4-3-应用配置文件" class="headerlink" title="4.4.3 应用配置文件"></a>4.4.3 应用配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f calico.yaml</span><br></pre></td></tr></table></figure><h4 id="4-4-4-验证-Calico-网络"><a href="#4-4-4-验证-Calico-网络" class="headerlink" title="4.4.4  验证 Calico 网络"></a>4.4.4  验证 Calico 网络</h4><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220831101123441.png" alt="image-20220831101123441"></p><blockquote><p>包括之前未就绪的 work 节点，现在已经就绪了（Ready）</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220831101215397.png" alt="image-20220831101215397"></p><p>&#x3D;&#x3D;如果以上 calico 版本的不能成功运行，建议降低版本，使用以下版本&#x3D;&#x3D;</p><p><a href="https://docs.projectcalico.org/v3.19/manifests/calico.yaml">https://docs.projectcalico.org/v3.19/manifests/calico.yaml</a></p><h3 id="4-5-CoreDNS-部署"><a href="#4-5-CoreDNS-部署" class="headerlink" title="4.5 CoreDNS 部署"></a>4.5 CoreDNS 部署</h3><blockquote><p>对于高可用集群架构来说，在任意一台 master 节点上执行即可，因为 CoreDNS 会以容器的方式部署于 work 节点上</p></blockquote><h4 id="4-5-1-下载-yaml-文件"><a href="#4-5-1-下载-yaml-文件" class="headerlink" title="4.5.1 下载 yaml 文件"></a>4.5.1 下载 yaml 文件</h4><blockquote><p>参考：<a href="https://github.com/coredns/deployment/blob/master/kubernetes/coredns.yaml.sed">https://github.com/coredns/deployment/blob/master/kubernetes/coredns.yaml.sed</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: coredns</span><br><span class="line">  namespace: kube-system</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    kubernetes.io/bootstrapping: rbac-defaults</span><br><span class="line">  name: system:coredns</span><br><span class="line">rules:</span><br><span class="line">  - apiGroups:</span><br><span class="line">    - &quot;&quot;</span><br><span class="line">    resources:</span><br><span class="line">    - endpoints</span><br><span class="line">    - services</span><br><span class="line">    - pods</span><br><span class="line">    - namespaces</span><br><span class="line">    verbs:</span><br><span class="line">    - list</span><br><span class="line">    - watch</span><br><span class="line">  - apiGroups:</span><br><span class="line">    - discovery.k8s.io</span><br><span class="line">    resources:</span><br><span class="line">    - endpointslices</span><br><span class="line">    verbs:</span><br><span class="line">    - list</span><br><span class="line">    - watch</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    rbac.authorization.kubernetes.io/autoupdate: &quot;true&quot;</span><br><span class="line">  labels:</span><br><span class="line">    kubernetes.io/bootstrapping: rbac-defaults</span><br><span class="line">  name: system:coredns</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: system:coredns</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: coredns</span><br><span class="line">  namespace: kube-system</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: coredns</span><br><span class="line">  namespace: kube-system</span><br><span class="line">data:</span><br><span class="line">  Corefile: |</span><br><span class="line">    .:53 &#123;</span><br><span class="line">        errors</span><br><span class="line">        health &#123;</span><br><span class="line">          lameduck 5s</span><br><span class="line">        &#125;</span><br><span class="line">        ready</span><br><span class="line">        kubernetes CLUSTER_DOMAIN REVERSE_CIDRS &#123;</span><br><span class="line">          fallthrough in-addr.arpa ip6.arpa</span><br><span class="line">        &#125;</span><br><span class="line">        prometheus :9153</span><br><span class="line">        forward . UPSTREAMNAMESERVER &#123;</span><br><span class="line">          max_concurrent 1000</span><br><span class="line">        &#125;</span><br><span class="line">        cache 30</span><br><span class="line">        loop</span><br><span class="line">        reload</span><br><span class="line">        loadbalance</span><br><span class="line">    &#125;STUBDOMAINS</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: coredns</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kube-dns</span><br><span class="line">    kubernetes.io/name: &quot;CoreDNS&quot;</span><br><span class="line">spec:</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">replicas: not specified here:</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">1. Default is 1.</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">2. Will be tuned <span class="keyword">in</span> real time <span class="keyword">if</span> DNS horizontal auto-scaling is turned on.</span></span><br><span class="line">  strategy:</span><br><span class="line">    type: RollingUpdate</span><br><span class="line">    rollingUpdate:</span><br><span class="line">      maxUnavailable: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      k8s-app: kube-dns</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        k8s-app: kube-dns</span><br><span class="line">    spec:</span><br><span class="line">      priorityClassName: system-cluster-critical</span><br><span class="line">      serviceAccountName: coredns</span><br><span class="line">      tolerations:</span><br><span class="line">        - key: &quot;CriticalAddonsOnly&quot;</span><br><span class="line">          operator: &quot;Exists&quot;</span><br><span class="line">      nodeSelector:</span><br><span class="line">        kubernetes.io/os: linux</span><br><span class="line">      affinity:</span><br><span class="line">         podAntiAffinity:</span><br><span class="line">           requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">           - labelSelector:</span><br><span class="line">               matchExpressions:</span><br><span class="line">               - key: k8s-app</span><br><span class="line">                 operator: In</span><br><span class="line">                 values: [&quot;kube-dns&quot;]</span><br><span class="line">             topologyKey: kubernetes.io/hostname</span><br><span class="line">      containers:</span><br><span class="line">      - name: coredns</span><br><span class="line">        image: coredns/coredns:1.9.3</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        resources:</span><br><span class="line">          limits:</span><br><span class="line">            memory: 170Mi</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 100m</span><br><span class="line">            memory: 70Mi</span><br><span class="line">        args: [ &quot;-conf&quot;, &quot;/etc/coredns/Corefile&quot; ]</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: config-volume</span><br><span class="line">          mountPath: /etc/coredns</span><br><span class="line">          readOnly: true</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 53</span><br><span class="line">          name: dns</span><br><span class="line">          protocol: UDP</span><br><span class="line">        - containerPort: 53</span><br><span class="line">          name: dns-tcp</span><br><span class="line">          protocol: TCP</span><br><span class="line">        - containerPort: 9153</span><br><span class="line">          name: metrics</span><br><span class="line">          protocol: TCP</span><br><span class="line">        securityContext:</span><br><span class="line">          allowPrivilegeEscalation: false</span><br><span class="line">          capabilities:</span><br><span class="line">            add:</span><br><span class="line">            - NET_BIND_SERVICE</span><br><span class="line">            drop:</span><br><span class="line">            - all</span><br><span class="line">          readOnlyRootFilesystem: true</span><br><span class="line">        livenessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /health</span><br><span class="line">            port: 8080</span><br><span class="line">            scheme: HTTP</span><br><span class="line">          initialDelaySeconds: 60</span><br><span class="line">          timeoutSeconds: 5</span><br><span class="line">          successThreshold: 1</span><br><span class="line">          failureThreshold: 5</span><br><span class="line">        readinessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /ready</span><br><span class="line">            port: 8181</span><br><span class="line">            scheme: HTTP</span><br><span class="line">      dnsPolicy: Default</span><br><span class="line">      volumes:</span><br><span class="line">        - name: config-volume</span><br><span class="line">          configMap:</span><br><span class="line">            name: coredns</span><br><span class="line">            items:</span><br><span class="line">            - key: Corefile</span><br><span class="line">              path: Corefile</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kube-dns</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  annotations:</span><br><span class="line">    prometheus.io/port: &quot;9153&quot;</span><br><span class="line">    prometheus.io/scrape: &quot;true&quot;</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kube-dns</span><br><span class="line">    kubernetes.io/cluster-service: &quot;true&quot;</span><br><span class="line">    kubernetes.io/name: &quot;CoreDNS&quot;</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kube-dns</span><br><span class="line">  clusterIP: CLUSTER_DNS_IP</span><br><span class="line">  ports:</span><br><span class="line">  - name: dns</span><br><span class="line">    port: 53</span><br><span class="line">    protocol: UDP</span><br><span class="line">  - name: dns-tcp</span><br><span class="line">    port: 53</span><br><span class="line">    protocol: TCP</span><br><span class="line">  - name: metrics</span><br><span class="line">    port: 9153</span><br><span class="line">    protocol: TCP</span><br></pre></td></tr></table></figure><h4 id="4-5-2-修改文件配置"><a href="#4-5-2-修改文件配置" class="headerlink" title="4.5.2 修改文件配置"></a>4.5.2 修改文件配置</h4><blockquote><p>修改部分：</p><p>forward . UPSTREAMNAMESERVER ——&gt; forward . &#x2F;etc&#x2F;resolv.conf</p><p>clusterIP: CLUSTER_DNS_IP ——&gt; clusterIP: 10.96.0.2</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;  coredns.yaml &lt;&lt; &quot;EOF&quot;</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: coredns</span><br><span class="line">  namespace: kube-system</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    kubernetes.io/bootstrapping: rbac-defaults</span><br><span class="line">  name: system:coredns</span><br><span class="line">rules:</span><br><span class="line">  - apiGroups:</span><br><span class="line">    - &quot;&quot;</span><br><span class="line">    resources:</span><br><span class="line">    - endpoints</span><br><span class="line">    - services</span><br><span class="line">    - pods</span><br><span class="line">    - namespaces</span><br><span class="line">    verbs:</span><br><span class="line">    - list</span><br><span class="line">    - watch</span><br><span class="line">  - apiGroups:</span><br><span class="line">    - discovery.k8s.io</span><br><span class="line">    resources:</span><br><span class="line">    - endpointslices</span><br><span class="line">    verbs:</span><br><span class="line">    - list</span><br><span class="line">    - watch</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    rbac.authorization.kubernetes.io/autoupdate: &quot;true&quot;</span><br><span class="line">  labels:</span><br><span class="line">    kubernetes.io/bootstrapping: rbac-defaults</span><br><span class="line">  name: system:coredns</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: system:coredns</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: coredns</span><br><span class="line">  namespace: kube-system</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: coredns</span><br><span class="line">  namespace: kube-system</span><br><span class="line">data:</span><br><span class="line">  Corefile: |</span><br><span class="line">    .:53 &#123;</span><br><span class="line">        errors</span><br><span class="line">        health &#123;</span><br><span class="line">          lameduck 5s</span><br><span class="line">        &#125;</span><br><span class="line">        ready</span><br><span class="line">        kubernetes cluster.local  in-addr.arpa ip6.arpa &#123;</span><br><span class="line">          fallthrough in-addr.arpa ip6.arpa</span><br><span class="line">        &#125;</span><br><span class="line">        prometheus :9153</span><br><span class="line">        forward . /etc/resolv.conf &#123;</span><br><span class="line">          max_concurrent 1000</span><br><span class="line">        &#125;</span><br><span class="line">        cache 30</span><br><span class="line">        loop</span><br><span class="line">        reload</span><br><span class="line">        loadbalance</span><br><span class="line">    &#125;</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: coredns</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kube-dns</span><br><span class="line">    kubernetes.io/name: &quot;CoreDNS&quot;</span><br><span class="line">spec:</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">replicas: not specified here:</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">1. Default is 1.</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">2. Will be tuned <span class="keyword">in</span> real time <span class="keyword">if</span> DNS horizontal auto-scaling is turned on.</span></span><br><span class="line">  strategy:</span><br><span class="line">    type: RollingUpdate</span><br><span class="line">    rollingUpdate:</span><br><span class="line">      maxUnavailable: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      k8s-app: kube-dns</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        k8s-app: kube-dns</span><br><span class="line">    spec:</span><br><span class="line">      priorityClassName: system-cluster-critical</span><br><span class="line">      serviceAccountName: coredns</span><br><span class="line">      tolerations:</span><br><span class="line">        - key: &quot;CriticalAddonsOnly&quot;</span><br><span class="line">          operator: &quot;Exists&quot;</span><br><span class="line">      nodeSelector:</span><br><span class="line">        kubernetes.io/os: linux</span><br><span class="line">      affinity:</span><br><span class="line">         podAntiAffinity:</span><br><span class="line">           preferredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">           - weight: 100</span><br><span class="line">             podAffinityTerm:</span><br><span class="line">               labelSelector:</span><br><span class="line">                 matchExpressions:</span><br><span class="line">                   - key: k8s-app</span><br><span class="line">                     operator: In</span><br><span class="line">                     values: [&quot;kube-dns&quot;]</span><br><span class="line">               topologyKey: kubernetes.io/hostname</span><br><span class="line">      containers:</span><br><span class="line">      - name: coredns</span><br><span class="line">        image: coredns/coredns:1.9.3</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        resources:</span><br><span class="line">          limits:</span><br><span class="line">            memory: 170Mi</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 100m</span><br><span class="line">            memory: 70Mi</span><br><span class="line">        args: [ &quot;-conf&quot;, &quot;/etc/coredns/Corefile&quot; ]</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: config-volume</span><br><span class="line">          mountPath: /etc/coredns</span><br><span class="line">          readOnly: true</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 53</span><br><span class="line">          name: dns</span><br><span class="line">          protocol: UDP</span><br><span class="line">        - containerPort: 53</span><br><span class="line">          name: dns-tcp</span><br><span class="line">          protocol: TCP</span><br><span class="line">        - containerPort: 9153</span><br><span class="line">          name: metrics</span><br><span class="line">          protocol: TCP</span><br><span class="line">        securityContext:</span><br><span class="line">          allowPrivilegeEscalation: false</span><br><span class="line">          capabilities:</span><br><span class="line">            add:</span><br><span class="line">            - NET_BIND_SERVICE</span><br><span class="line">            drop:</span><br><span class="line">            - all</span><br><span class="line">          readOnlyRootFilesystem: true</span><br><span class="line">        livenessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /health</span><br><span class="line">            port: 8080</span><br><span class="line">            scheme: HTTP</span><br><span class="line">          initialDelaySeconds: 60</span><br><span class="line">          timeoutSeconds: 5</span><br><span class="line">          successThreshold: 1</span><br><span class="line">          failureThreshold: 5</span><br><span class="line">        readinessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /ready</span><br><span class="line">            port: 8181</span><br><span class="line">            scheme: HTTP</span><br><span class="line">      dnsPolicy: Default</span><br><span class="line">      volumes:</span><br><span class="line">        - name: config-volume</span><br><span class="line">          configMap:</span><br><span class="line">            name: coredns</span><br><span class="line">            items:</span><br><span class="line">            - key: Corefile</span><br><span class="line">              path: Corefile</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kube-dns</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  annotations:</span><br><span class="line">    prometheus.io/port: &quot;9153&quot;</span><br><span class="line">    prometheus.io/scrape: &quot;true&quot;</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kube-dns</span><br><span class="line">    kubernetes.io/cluster-service: &quot;true&quot;</span><br><span class="line">    kubernetes.io/name: &quot;CoreDNS&quot;</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kube-dns</span><br><span class="line">  clusterIP: 10.96.0.2</span><br><span class="line">  ports:</span><br><span class="line">  - name: dns</span><br><span class="line">    port: 53</span><br><span class="line">    protocol: UDP</span><br><span class="line">  - name: dns-tcp</span><br><span class="line">    port: 53</span><br><span class="line">    protocol: TCP</span><br><span class="line">  - name: metrics</span><br><span class="line">    port: 9153</span><br><span class="line">    protocol: TCP</span><br><span class="line"> </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="4-5-3-应用配置文件"><a href="#4-5-3-应用配置文件" class="headerlink" title="4.5.3 应用配置文件"></a>4.5.3 应用配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f calico.yaml</span><br></pre></td></tr></table></figure><h4 id="4-5-4-验证-CoreDNS"><a href="#4-5-4-验证-CoreDNS" class="headerlink" title="4.5.4 验证 CoreDNS"></a>4.5.4 验证 CoreDNS</h4><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220831112825416.png" alt="image-20220831112825416"></p><p>看看是否能正常解析：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master2 ~]# kubectl run -it --rm dns-test --image=busybox:1.28.4 sh</span><br><span class="line">If you don&#x27;t see a command prompt, try pressing enter.</span><br><span class="line">/ # nslookup kubernetes </span><br><span class="line">Server:    10.96.0.2</span><br><span class="line">Address 1: 10.96.0.2 kube-dns.kube-system.svc.cluster.local</span><br><span class="line"></span><br><span class="line">Name:      kubernetes</span><br><span class="line">Address 1: 10.96.0.1 kubernetes.default.svc.cluster.local</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220831132451319.png" alt="image-20220831132451319"></p><p>&#x3D;&#x3D;如果以上 coredns yaml 配置文件中的镜像版本的不能成功运行，建议降低版本，使用以下版本&#x3D;&#x3D;</p><p>image: coredns&#x2F;coredns:1.8.4</p><h2 id="五、验证"><a href="#五、验证" class="headerlink" title="五、验证"></a>五、验证</h2><h3 id="5-1-部署-Nginx"><a href="#5-1-部署-Nginx" class="headerlink" title="5.1 部署 Nginx"></a>5.1 部署 Nginx</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;  /data/k8s-work/server/nginx.yaml  &lt;&lt; &quot;EOF&quot;</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ReplicationController</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-web</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    name: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: nginx</span><br><span class="line">          image: nginx:1.19.6</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 80</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-service-nodeport</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - port: 80</span><br><span class="line">      targetPort: 80</span><br><span class="line">      nodePort: 30001</span><br><span class="line">      protocol: TCP</span><br><span class="line">  type: NodePort</span><br><span class="line">  selector:</span><br><span class="line">    name: nginx</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="5-2-Host-访问验证"><a href="#5-2-Host-访问验证" class="headerlink" title="5.2 Host 访问验证"></a>5.2 Host 访问验证</h3><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220831131507658.png" alt="image-20220831131507658"></p><p>&#x3D;&#x3D;至此，K8s 高可用集群架构部署完毕！！&#x3D;&#x3D;</p><h2 id="六、FAQ"><a href="#六、FAQ" class="headerlink" title="六、FAQ"></a>六、FAQ</h2><h3 id="6-1-ETCD-启动报错"><a href="#6-1-ETCD-启动报错" class="headerlink" title="6.1 ETCD 启动报错"></a>6.1 ETCD 启动报错</h3><h4 id="6-1-1-报错类型"><a href="#6-1-1-报错类型" class="headerlink" title="6.1.1 报错类型"></a>6.1.1 报错类型</h4><p>当我配置完 ETCD 的 systemd 管理后，启动包如下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conflicting environment variable is shadowed by corresponding command-line flag</span><br></pre></td></tr></table></figure><p>大概意思就是 ETCD 的环境变量冲突问题，查阅了一番资料，再 ETCD3.4+ 版本中已经可以自动读取配置文件。</p><p>原始的 systemd 管理文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt; EOF | tee /usr/lib/systemd/system/etcd.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=Etcd Server</span><br><span class="line">After=network.target</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">EnvironmentFile=/data/etcd/conf/etcd.conf</span><br><span class="line">ExecStart=/usr/bin/etcd \</span><br><span class="line">  --name=\$&#123;ETCD_NAME&#125; \</span><br><span class="line">  --data-dir=\$&#123;ETCD_DATA_DIR&#125; \</span><br><span class="line">  --listen-peer-urls=\$&#123;ETCD_LISTEN_PEER_URLS&#125; \</span><br><span class="line">  --listen-client-urls=\$&#123;ETCD_LISTEN_CLIENT_URLS&#125; \</span><br><span class="line">  --advertise-client-urls=\$&#123;ETCD_ADVERTISE_CLIENT_URLS&#125; \</span><br><span class="line">  --initial-advertise-peer-urls=\$&#123;ETCD_INITIAL_ADVERTISE_PEER_URLS&#125; \</span><br><span class="line">  --initial-cluster=\$&#123;ETCD_INITIAL_CLUSTER&#125; \</span><br><span class="line">  --initial-cluster-token=\$&#123;ETCD_INITIAL_CLUSTER_TOKEN&#125; \</span><br><span class="line">  --initial-cluster-state=\$&#123;ETCD_INITIAL_CLUSTER_STATE&#125;  \</span><br><span class="line">  --cert-file=\$&#123;ETCD_CERT_FILE&#125; \</span><br><span class="line">  --key-file=\$&#123;ETCD_KEY_FILE&#125; \</span><br><span class="line">  --peer-cert-file=\$&#123;ETCD_PEER_CERT_FILE&#125; \</span><br><span class="line">  --peer-key-file=\$&#123;ETCD_PEER_KEY_FILE&#125; \</span><br><span class="line">  --trusted-ca-file=\$&#123;ETCD_TRUSTED_CA_FILE&#125; \</span><br><span class="line">  --client-cert-auth=\$&#123;ETCD_CLIENT_CERT_AUTH&#125; \</span><br><span class="line">  --peer-client-cert-auth=\$&#123;ETCD_PEER_CLIENT_CERT_AUTH&#125; \</span><br><span class="line">  --peer-trusted-ca-file=\$&#123;ETCD_PEER_TRUSTED_CA_FILE&#125;</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="6-2-1-解决方案"><a href="#6-2-1-解决方案" class="headerlink" title="6.2.1 解决方案"></a>6.2.1 解决方案</h4><ul><li><p>方案一：去掉 systemd 管理文件中的 <code>EnvironmentFile</code> 参数，<code>ExecStart</code> 部分就可以使用 <code>--xxx=xxx</code> 参数了</p></li><li><p>方案二：去掉 <code>ExecStart</code> 部分后的 <code>--xxx=xxx</code> 参数，因为该 ETCD 版本会自动读取。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt; EOF | tee /usr/lib/systemd/system/etcd.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=Etcd Server</span><br><span class="line">After=network.target</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">EnvironmentFile=-/data/etcd/conf/etcd.conf</span><br><span class="line">ExecStart=/usr/bin/etcd</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-2-apiserver-启动报错"><a href="#6-2-apiserver-启动报错" class="headerlink" title="6.2 apiserver 启动报错"></a>6.2 apiserver 启动报错</h3><h4 id="6-2-1-报错类型"><a href="#6-2-1-报错类型" class="headerlink" title="6.2.1 报错类型"></a>6.2.1 报错类型</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kube-apiserver[1706]: Error: unknown flag: --insecure-port</span><br><span class="line">kube-apiserver[2196]: Error: unknown flag: --enable-swagger-ui</span><br></pre></td></tr></table></figure><p>大致意思就是 kube-apiserver 不知道这些变量，看了一下官方文档，在 1.24+ 版本中已经遗弃了 –insecure-port、–enable-swagger-ui 这两个参数了。</p><h4 id="6-2-2-解决方案"><a href="#6-2-2-解决方案" class="headerlink" title="6.2.2 解决方案"></a>6.2.2 解决方案</h4><blockquote><p>修改 .conf 配置文件</p></blockquote><p>修改前：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /data/kubernetes/conf/kube-apiserver.conf &lt;&lt; &quot;EOF&quot;</span><br><span class="line">KUBE_APISERVER_OPTS=&quot;--enable-admission-plugins=NamespaceLifecycle,NodeRestriction,LimitRanger,ServiceAccount,DefaultStorageClass,ResourceQuota \</span><br><span class="line">  --anonymous-auth=false \</span><br><span class="line">  --bind-address=192.168.56.171 \</span><br><span class="line">  --secure-port=6443 \</span><br><span class="line">  --advertise-address=192.168.56.171 \</span><br><span class="line">  --insecure-port=8080 \</span><br><span class="line">  --authorization-mode=Node,RBAC \</span><br><span class="line">  --runtime-config=api/all=true \</span><br><span class="line">  --enable-bootstrap-token-auth \</span><br><span class="line">  --service-cluster-ip-range=10.96.0.0/16 \</span><br><span class="line">  --token-auth-file=/data/kubernetes/tokenfile/token.csv \</span><br><span class="line">  --service-node-port-range=30000-50000 \</span><br><span class="line">  --tls-cert-file=/data/kubernetes/ssl/kube-apiserver.pem  \</span><br><span class="line">  --tls-private-key-file=/data/kubernetes/ssl/kube-apiserver-key.pem \</span><br><span class="line">  --client-ca-file=/data/kubernetes/ssl/ca.pem \</span><br><span class="line">  --kubelet-client-certificate=/data/kubernetes/ssl/kube-apiserver.pem \</span><br><span class="line">  --kubelet-client-key=/data/kubernetes/ssl/kube-apiserver-key.pem \</span><br><span class="line">  --service-account-key-file=/data/kubernetes/ssl/ca-key.pem \</span><br><span class="line">  --service-account-signing-key-file=/data/kubernetes/ssl/ca-key.pem  \</span><br><span class="line">  --service-account-issuer=api \</span><br><span class="line">  --etcd-cafile=/data/etcd/ssl/ca.pem \</span><br><span class="line">  --etcd-certfile=/data/etcd/ssl/etcd.pem \</span><br><span class="line">  --etcd-keyfile=/data/etcd/ssl/etcd-key.pem \</span><br><span class="line">  --etcd-servers=https://192.168.56.171:2379,https://192.168.56.172:2379,https://192.168.56.173:2379 \</span><br><span class="line">  --enable-swagger-ui=true \</span><br><span class="line">  --allow-privileged=true \</span><br><span class="line">  --apiserver-count=3 \</span><br><span class="line">  --audit-log-maxage=30 \</span><br><span class="line">  --audit-log-maxbackup=3 \</span><br><span class="line">  --audit-log-maxsize=100 \</span><br><span class="line">  --audit-log-path=/data/kubernetes/logs/kube-apiserver/kube-apiserver-audit.log \</span><br><span class="line">  --event-ttl=1h \</span><br><span class="line">  --alsologtostderr=true \</span><br><span class="line">  --logtostderr=false \</span><br><span class="line">  --log-dir=/data/kubernetes/logs/kube-apiserver \</span><br><span class="line">  --v=4&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>修改后：去掉 –insecure-port、–enable-swagger-ui 选项参数即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /data/kubernetes/conf/kube-apiserver.conf &lt;&lt; &quot;EOF&quot;</span><br><span class="line">KUBE_APISERVER_OPTS=&quot;--enable-admission-plugins=NamespaceLifecycle,NodeRestriction,LimitRanger,ServiceAccount,DefaultStorageClass,ResourceQuota \</span><br><span class="line">  --anonymous-auth=false \</span><br><span class="line">  --bind-address=192.168.56.171 \</span><br><span class="line">  --secure-port=6443 \</span><br><span class="line">  --advertise-address=192.168.56.171 \</span><br><span class="line">  --authorization-mode=Node,RBAC \</span><br><span class="line">  --runtime-config=api/all=true \</span><br><span class="line">  --enable-bootstrap-token-auth \</span><br><span class="line">  --service-cluster-ip-range=10.96.0.0/16 \</span><br><span class="line">  --token-auth-file=/data/kubernetes/tokenfile/token.csv \</span><br><span class="line">  --service-node-port-range=30000-50000 \</span><br><span class="line">  --tls-cert-file=/data/kubernetes/ssl/kube-apiserver.pem  \</span><br><span class="line">  --tls-private-key-file=/data/kubernetes/ssl/kube-apiserver-key.pem \</span><br><span class="line">  --client-ca-file=/data/kubernetes/ssl/ca.pem \</span><br><span class="line">  --kubelet-client-certificate=/data/kubernetes/ssl/kube-apiserver.pem \</span><br><span class="line">  --kubelet-client-key=/data/kubernetes/ssl/kube-apiserver-key.pem \</span><br><span class="line">  --service-account-key-file=/data/kubernetes/ssl/ca-key.pem \</span><br><span class="line">  --service-account-signing-key-file=/data/kubernetes/ssl/ca-key.pem  \</span><br><span class="line">  --service-account-issuer=api \</span><br><span class="line">  --etcd-cafile=/data/etcd/ssl/ca.pem \</span><br><span class="line">  --etcd-certfile=/data/etcd/ssl/etcd.pem \</span><br><span class="line">  --etcd-keyfile=/data/etcd/ssl/etcd-key.pem \</span><br><span class="line">  --etcd-servers=https://192.168.56.171:2379,https://192.168.56.172:2379,https://192.168.56.173:2379 \</span><br><span class="line">  --allow-privileged=true \</span><br><span class="line">  --apiserver-count=3 \</span><br><span class="line">  --audit-log-maxage=30 \</span><br><span class="line">  --audit-log-maxbackup=3 \</span><br><span class="line">  --audit-log-maxsize=100 \</span><br><span class="line">  --audit-log-path=/data/kubernetes/logs/kube-apiserver/kube-apiserver-audit.log \</span><br><span class="line">  --event-ttl=1h \</span><br><span class="line">  --alsologtostderr=true \</span><br><span class="line">  --logtostderr=false \</span><br><span class="line">  --log-dir=/data/kubernetes/logs/kube-apiserver \</span><br><span class="line">  --v=4&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="6-3-controller-manager-启动报错"><a href="#6-3-controller-manager-启动报错" class="headerlink" title="6.3 controller-manager 启动报错"></a>6.3 controller-manager 启动报错</h3><blockquote><p>与 apiserver 启动报错类似，在该 k8s 版本中，有些选项参数已经被遗弃了，根据提示去掉即可。</p></blockquote><h4 id="6-3-1-报错类型"><a href="#6-3-1-报错类型" class="headerlink" title="6.3.1 报错类型"></a>6.3.1 报错类型</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kube-controller-manager[3505]: Error: unknown flag: --port</span><br><span class="line">kube-controller-manager[4159]: Error: unknown flag: --horizontal-pod-autoscaler-use-rest-clients</span><br></pre></td></tr></table></figure><h4 id="6-3-2-解决方案"><a href="#6-3-2-解决方案" class="headerlink" title="6.3.2 解决方案"></a>6.3.2 解决方案</h4><blockquote><p>修改 .conf 配置文件</p></blockquote><p>修改前：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /data/kubernetes/conf/kube-controller-manager.conf &lt;&lt; &quot;EOF&quot;</span><br><span class="line">KUBE_CONTROLLER_MANAGER_OPTS=&quot;--port=10252 \</span><br><span class="line">  --secure-port=10257 \</span><br><span class="line">  --bind-address=127.0.0.1 \</span><br><span class="line">  --kubeconfig=/data/kubernetes/conf/kube-controller-manager.kubeconfig \</span><br><span class="line">  --service-cluster-ip-range=10.96.0.0/16 \</span><br><span class="line">  --cluster-name=kubernetes \</span><br><span class="line">  --cluster-signing-cert-file=/data/kubernetes/ssl/ca.pem \</span><br><span class="line">  --cluster-signing-key-file=/data/kubernetes/ssl/ca-key.pem \</span><br><span class="line">  --allocate-node-cidrs=true \</span><br><span class="line">  --cluster-cidr=10.244.0.0/16 \</span><br><span class="line">  --experimental-cluster-signing-duration=87600h \</span><br><span class="line">  --root-ca-file=/data/kubernetes/ssl/ca.pem \</span><br><span class="line">  --service-account-private-key-file=/data/kubernetes/ssl/ca-key.pem \</span><br><span class="line">  --leader-elect=true \</span><br><span class="line">  --feature-gates=RotateKubeletServerCertificate=true \</span><br><span class="line">  --controllers=*,bootstrapsigner,tokencleaner \</span><br><span class="line">  --horizontal-pod-autoscaler-use-rest-clients=true \</span><br><span class="line">  --horizontal-pod-autoscaler-sync-period=10s \</span><br><span class="line">  --tls-cert-file=/data/kubernetes/ssl/kube-controller-manager.pem \</span><br><span class="line">  --tls-private-key-file=/data/kubernetes/ssl/kube-controller-manager-key.pem \</span><br><span class="line">  --use-service-account-credentials=true \</span><br><span class="line">  --alsologtostderr=true \</span><br><span class="line">  --logtostderr=false \</span><br><span class="line">  --log-dir=/data/kubernetes/logs/kube-controller-manager \</span><br><span class="line">  --v=2&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>修改后：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /data/kubernetes/conf/kube-controller-manager.conf &lt;&lt; &quot;EOF&quot;</span><br><span class="line">KUBE_CONTROLLER_MANAGER_OPTS=&quot;--secure-port=10257 \</span><br><span class="line">  --bind-address=127.0.0.1 \</span><br><span class="line">  --kubeconfig=/data/kubernetes/conf/kube-controller-manager.kubeconfig \</span><br><span class="line">  --service-cluster-ip-range=10.96.0.0/16 \</span><br><span class="line">  --cluster-name=kubernetes \</span><br><span class="line">  --cluster-signing-cert-file=/data/kubernetes/ssl/ca.pem \</span><br><span class="line">  --cluster-signing-key-file=/data/kubernetes/ssl/ca-key.pem \</span><br><span class="line">  --allocate-node-cidrs=true \</span><br><span class="line">  --cluster-cidr=10.244.0.0/16 \</span><br><span class="line">  --experimental-cluster-signing-duration=87600h \</span><br><span class="line">  --root-ca-file=/data/kubernetes/ssl/ca.pem \</span><br><span class="line">  --service-account-private-key-file=/data/kubernetes/ssl/ca-key.pem \</span><br><span class="line">  --leader-elect=true \</span><br><span class="line">  --feature-gates=RotateKubeletServerCertificate=true \</span><br><span class="line">  --controllers=*,bootstrapsigner,tokencleaner \</span><br><span class="line">  --tls-cert-file=/data/kubernetes/ssl/kube-controller-manager.pem \</span><br><span class="line">  --tls-private-key-file=/data/kubernetes/ssl/kube-controller-manager-key.pem \</span><br><span class="line">  --use-service-account-credentials=true \</span><br><span class="line">  --alsologtostderr=true \</span><br><span class="line">  --logtostderr=false \</span><br><span class="line">  --log-dir=/data/kubernetes/logs/kube-controller-manager \</span><br><span class="line">  --v=2&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="6-4-scheduler-启动报错"><a href="#6-4-scheduler-启动报错" class="headerlink" title="6.4 scheduler 启动报错"></a>6.4 scheduler 启动报错</h3><h4 id="6-4-1-报错类型"><a href="#6-4-1-报错类型" class="headerlink" title="6.4.1 报错类型"></a>6.4.1 报错类型</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kube-scheduler[5036]: Error: unknown flag: --address</span><br></pre></td></tr></table></figure><h4 id="6-4-2-解决方案"><a href="#6-4-2-解决方案" class="headerlink" title="6.4.2 解决方案"></a>6.4.2 解决方案</h4><p>修改前：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /data/kubernetes/conf/kube-scheduler.conf &lt;&lt; &quot;EOF&quot;</span><br><span class="line">KUBE_SCHEDULER_OPTS=&quot;--address=127.0.0.1 \</span><br><span class="line">--kubeconfig=/data/kubernetes/conf/kube-scheduler.kubeconfig \</span><br><span class="line">--leader-elect=true \</span><br><span class="line">--alsologtostderr=true \</span><br><span class="line">--logtostderr=false \</span><br><span class="line">--log-dir=/data/kubernetes/logs/kube-scheduler \</span><br><span class="line">--v=2&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>修改后：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /data/kubernetes/conf/kube-scheduler.conf &lt;&lt; &quot;EOF&quot;</span><br><span class="line">KUBE_SCHEDULER_OPTS=&quot;--kubeconfig=/data/kubernetes/conf/kube-scheduler.kubeconfig \</span><br><span class="line">--leader-elect=true \</span><br><span class="line">--alsologtostderr=true \</span><br><span class="line">--logtostderr=false \</span><br><span class="line">--log-dir=/data/kubernetes/logs/kube-scheduler \</span><br><span class="line">--v=2&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="6-5-kubelet-启动报错"><a href="#6-5-kubelet-启动报错" class="headerlink" title="6.5 kubelet 启动报错"></a>6.5 kubelet 启动报错</h3><h4 id="6-5-1-报错类型"><a href="#6-5-1-报错类型" class="headerlink" title="6.5.1 报错类型"></a>6.5.1 报错类型</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubelet[5036]: Error: unknown flag: --network-plugin</span><br></pre></td></tr></table></figure><h4 id="6-5-2-解决方案"><a href="#6-5-2-解决方案" class="headerlink" title="6.5.2 解决方案"></a>6.5.2 解决方案</h4><p>修改前：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /usr/lib/systemd/system/kubelet.service &lt;&lt; &quot;EOF&quot;</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Kubelet</span><br><span class="line">Documentation=https://github.com/kubernetes/kubernetes</span><br><span class="line">After=docker.service</span><br><span class="line">Requires=docker.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/bin/kubelet \</span><br><span class="line">  --bootstrap-kubeconfig=/data/kubernetes/conf/kubelet-bootstrap.kubeconfig \</span><br><span class="line">  --cert-dir=/data/kubernetes/ssl \</span><br><span class="line">  --kubeconfig=/data/kubernetes/conf/kubelet.kubeconfig \</span><br><span class="line">  --config=/data/kubernetes/conf/kubelet.json \</span><br><span class="line">  --container-runtime=remote \</span><br><span class="line">  --container-runtime-endpoint=unix:///var/run/cri-dockerd.sock \</span><br><span class="line">  --network-plugin=cni \</span><br><span class="line">  --rotate-certificates \</span><br><span class="line">  --pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.2 \</span><br><span class="line">  --alsologtostderr=true \</span><br><span class="line">  --logtostderr=false \</span><br><span class="line">  --log-dir=/data/kubernetes/logs/kubelet \</span><br><span class="line">  --v=2</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>修改后：去掉 <code>--network-plugin</code> 和 <code>--pod-infra-container-image</code> 因为，cri-docker 的 systemd 文件已经指定了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /usr/lib/systemd/system/kubelet.service &lt;&lt; &quot;EOF&quot;</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Kubelet</span><br><span class="line">Documentation=https://github.com/kubernetes/kubernetes</span><br><span class="line">After=docker.service</span><br><span class="line">Requires=docker.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/bin/kubelet \</span><br><span class="line">  --bootstrap-kubeconfig=/data/kubernetes/conf/kubelet-bootstrap.kubeconfig \</span><br><span class="line">  --cert-dir=/data/kubernetes/ssl \</span><br><span class="line">  --kubeconfig=/data/kubernetes/conf/kubelet.kubeconfig \</span><br><span class="line">  --config=/data/kubernetes/conf/kubelet.json \</span><br><span class="line">  --container-runtime=remote \</span><br><span class="line">  --container-runtime-endpoint=unix:///var/run/cri-dockerd.sock \</span><br><span class="line">  --rotate-certificates \</span><br><span class="line">  --alsologtostderr=true \</span><br><span class="line">  --logtostderr=false \</span><br><span class="line">  --log-dir=/data/kubernetes/logs/kubelet \</span><br><span class="line">  --v=2</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> K8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8s </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 Linux 的 Docker Swarm 集群部署及应用</title>
      <link href="/posts/articles/3717b6ec.html"/>
      <url>/posts/articles/3717b6ec.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/docker-docs.webp" alt="docker-docs"></p><p><font color="Brown"><strong>Author</strong>：rab</font> </p><p><font color="Brown"><strong>Date</strong>：2022&#x2F;08&#x2F;01</font> </p><p><font color="Brown"><strong>Blog</strong>：<a href="https://blog.csdn.net/IT_ZRS?type=blog"><font color="Brown">https://blog.csdn.net/IT_ZRS?type&#x3D;blog</font></a></font></p><hr><h2 id="一、规划"><a href="#一、规划" class="headerlink" title="一、规划"></a>一、规划</h2><h3 id="1-1-主机规划"><a href="#1-1-主机规划" class="headerlink" title="1.1 主机规划"></a>1.1 主机规划</h3><table><thead><tr><th>OS</th><th>Service</th><th>角色</th></tr></thead><tbody><tr><td>192.168.56.161（2C&#x2F;2G）</td><td>Docker</td><td>Docker_Swarm_Manager（Work）</td></tr><tr><td>192.168.56.162（2C&#x2F;2G）</td><td>Docker</td><td>Docker_Swarm_Work1</td></tr><tr><td>192.168.56.163（2C&#x2F;2G）</td><td>Docker</td><td>Docker_Swarm_Work2</td></tr></tbody></table><p>⚠注意：如果你是正式环境下进行部署，Manager 必须大于等于 3 台且为奇数（因为在 Manager 挂掉后要进行新 Manager 选举）。该文档的内容结合官方来进行简单测试使用，生成环境中最低服务器数量为（3主+3从）。</p><h3 id="1-2-版本规划"><a href="#1-2-版本规划" class="headerlink" title="1.2 版本规划"></a>1.2 版本规划</h3><ul><li><strong>Linux</strong>：CentOS 7.9</li><li><strong>Docker</strong>：18.06.3</li></ul><p>&#x3D;&#x3D;更加具体资料请参考官方文档&#x3D;&#x3D;（<a href="https://docs.docker.com/">官方参考文档</a>）</p><h2 id="二、部署"><a href="#二、部署" class="headerlink" title="二、部署"></a>二、部署</h2><h3 id="2-1-Docker-服务部署"><a href="#2-1-Docker-服务部署" class="headerlink" title="2.1 Docker 服务部署"></a>2.1 Docker 服务部署</h3><p>直接执行我下面给的安装脚本即可，安装路径你可以安装完成后再自行更改，我这是一个快速自动化安装脚本，不存再路径优化项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">！/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">@Default version：18.06.3</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">@Auth：rab</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">@Date：2021/12/11</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">@适用版本：CentOS 7/8</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看是否安装</span></span><br><span class="line">rpm -qa | grep docker &amp;&gt; /dev/null</span><br><span class="line">if [ $? -eq 0 ];then</span><br><span class="line">v=`rpm -qa |grep docker |awk -F &#x27;-&#x27; &#x27;&#123;print $3&#125;&#x27;`</span><br><span class="line">echo &quot;docker-ce已经安装，版本为：$v&quot;</span><br><span class="line">read -p &quot;是否卸载原docker版本并安装其他版本？[y/n] &quot; r</span><br><span class="line">    if [ $r = &quot;y&quot; ];then</span><br><span class="line">        yum remove -y `rpm -qa | grep docker` &amp;&gt; /dev/null</span><br><span class="line">        rpm -qa | grep docker &amp;&gt; /dev/null</span><br><span class="line">        if [ $? -ne 0 ]; then</span><br><span class="line">    echo &quot;原docker卸载成功！！&quot;</span><br><span class="line">    else</span><br><span class="line">    echo &quot;原docker卸载失败！！&quot;</span><br><span class="line">    exit 1</span><br><span class="line">    fi</span><br><span class="line">    # step 1: 安装必要的一些系统工具</span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2 &amp;&gt; /dev/null</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Step 2: 添加软件源信息</span></span><br><span class="line">yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo &amp;&gt; /dev/null</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Step 3</span></span><br><span class="line">sed -i &#x27;s+download.docker.com+mirrors.aliyun.com/docker-ce+&#x27; /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Step 4: 更新并安装Docker-CE</span></span><br><span class="line">       echo &quot;正在建立docker-ce缓存&quot;</span><br><span class="line">yum makecache       </span><br><span class="line">    zz=`yum list docker-ce.x86_64 --showduplicates | sort -r |grep docker-ce.x86_64 |awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">    for rr in $zz</span><br><span class="line">        do</span><br><span class="line">            echo &quot;可选安装版本：$rr&quot;</span><br><span class="line">        done</span><br><span class="line">        read -p &quot;选择要安装的docker版本[如18.06.3.ce-3.el7]: &quot; o</span><br><span class="line">        echo &quot;&quot;</span><br><span class="line">        echo &quot;正在安装 docker-ce-$o，请耐心等待.....&quot;                         </span><br><span class="line">        yum -y install docker-ce-$o</span><br><span class="line">        if [ $? -eq 0 ]; then</span><br><span class="line">            echo &quot;docker-ce-$&#123;o&#125;安装成功！！&quot;</span><br><span class="line">        else</span><br><span class="line">            echo &quot;docker-ce-$&#123;o&#125;安装失败！！&quot;</span><br><span class="line">            exit 2</span><br><span class="line">        fi</span><br><span class="line">        # 启动docker</span><br><span class="line">        systemctl enable docker.service</span><br><span class="line">        systemctl start docker.service</span><br><span class="line">        if [ $? -eq 0 ]; then</span><br><span class="line">            echo &quot;docker-ce-$&#123;o&#125;启动成功！！&quot;</span><br><span class="line">        else</span><br><span class="line">            echo &quot;docker-ce-$&#123;o&#125;启动失败！！&quot;</span><br><span class="line">            exit 2</span><br><span class="line">        fi</span><br><span class="line">        # 配置加速器</span><br><span class="line">        touch /etc/docker/daemon.json</span><br><span class="line">        tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://q1rw9tzz.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">            echo &quot;docker-ce-$&#123;o&#125;阿里加速器配置成功！！&quot;</span><br><span class="line">        else</span><br><span class="line">            echo &quot;docker-ce-$&#123;o&#125;阿里加速器配置失败！！&quot;</span><br><span class="line">            exit 2</span><br><span class="line">        fi</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启docker</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">            echo &quot;docker-ce-$&#123;o&#125;重启成功！！&quot;</span><br><span class="line">        else</span><br><span class="line">            echo &quot;docker-ce-$&#123;o&#125;重启失败！！&quot;</span><br><span class="line">            exit 2</span><br><span class="line">        fi</span><br><span class="line">else</span><br><span class="line">    echo &quot;继续使用原版本，退出执行脚本！！&quot; &amp;&amp; exit 1</span><br><span class="line">fi</span><br><span class="line">else</span><br><span class="line">echo &quot;docker未安装，将继续执行安装脚本！！&quot;</span><br><span class="line">        echo &quot;正在搜索可安装的 Docker 版本，请耐心等待.....&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">step 1: 安装必要的一些系统工具</span></span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2 &amp;&gt; /dev/null</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Step 2: 添加软件源信息</span></span><br><span class="line">yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo &amp;&gt; /dev/null</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Step 3</span></span><br><span class="line">sed -i &#x27;s+download.docker.com+mirrors.aliyun.com/docker-ce+&#x27; /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Step 4: 更新并安装Docker-CE</span></span><br><span class="line">   echo &quot;正在建立docker-ce缓存&quot;</span><br><span class="line">yum makecache</span><br><span class="line">zz=`yum list docker-ce.x86_64 --showduplicates | sort -r |grep docker-ce.x86_64 |awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">for rr in $zz</span><br><span class="line">    do</span><br><span class="line">        echo &quot;可选安装版本：$rr&quot;</span><br><span class="line">    done</span><br><span class="line">    read -p &quot;选择要安装的docker版本[如18.06.3.ce-3.el7]: &quot; o</span><br><span class="line">    echo &quot;&quot;</span><br><span class="line">    echo &quot;正在安装 docker-ce-$o，请耐心等待.....&quot;</span><br><span class="line"></span><br><span class="line">    yum -y install docker-ce-$o &amp;&gt; /dev/null</span><br><span class="line">    if [ $? -eq 0 ]; then</span><br><span class="line">        echo &quot;docker-ce-$&#123;o&#125;安装成功！！&quot;</span><br><span class="line">    else</span><br><span class="line">        echo &quot;docker-ce-$&#123;o&#125;安装失败！！&quot;</span><br><span class="line">        exit 2</span><br><span class="line">    fi</span><br><span class="line">    # 启动docker</span><br><span class="line">    systemctl enable docker.service</span><br><span class="line">    systemctl start docker.service</span><br><span class="line">    if [ $? -eq 0 ]; then</span><br><span class="line">echo &quot;docker-ce-$&#123;o&#125;启动成功！！&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;docker-ce-$&#123;o&#125;启动失败！！&quot;</span><br><span class="line">exit 2</span><br><span class="line">fi</span><br><span class="line">    # 配置加速器</span><br><span class="line">    touch /etc/docker/daemon.json</span><br><span class="line">tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://q1rw9tzz.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">echo &quot;docker-ce-$&#123;o&#125;阿里加速器配置成功！！&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;docker-ce-$&#123;o&#125;阿里加速器配置失败！！&quot;</span><br><span class="line">exit 2</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启docker</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">echo &quot;docker-ce-$&#123;o&#125;重启成功！！&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;docker-ce-$&#123;o&#125;重启失败！！&quot;</span><br><span class="line">        exit 2</span><br><span class="line">fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如脚本名为docker_install.sh</span></span><br><span class="line">sudo chmod +x docker_install.sh</span><br><span class="line">./docker_install.sh</span><br></pre></td></tr></table></figure><blockquote><p>执行结果如下图所示。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801113214240.png" alt="image-20220801113214240"></p><h3 id="2-2-Docker-Swarm-集群部署"><a href="#2-2-Docker-Swarm-集群部署" class="headerlink" title="2.2 Docker Swarm 集群部署"></a>2.2 Docker Swarm 集群部署</h3><p>其实 Docker Swarm 集群很简单，一条命令即可完成。</p><p>1、初始化 Linux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改主机名</span></span><br><span class="line">hostnamectl set-hostname Docker_Swarm_Manager</span><br><span class="line">hostnamectl set-hostname Docker_Swarm_Work1</span><br><span class="line">hostnamectl set-hostname Docker_Swarm_Work2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">互作本地解析（三台均执行）</span></span><br><span class="line">192.168.56.161 Docker_Swarm_Manager</span><br><span class="line">192.168.56.162 Docker_Swarm_Work1</span><br><span class="line">192.168.56.163 Docker_Swarm_Work2</span><br></pre></td></tr></table></figure><p>2、初始化 Manager</p><blockquote><p>在其中一台 Manager 节点执行（其他 Manager 节点按命令并入即可）</p><p>Manager 节点也可作为 work 节点使用。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化swarm集群，创建主管理节点</span></span><br><span class="line">docker swarm init \</span><br><span class="line">--advertise-addr 192.168.56.161:2377 \</span><br><span class="line">--listen-addr 192.168.56.161:2377</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明</span></span><br><span class="line">--advertise-addr：其他节点并入集群的入口地址</span><br><span class="line">--listen-addr：该参数是默认的，如果不添加也是默认IP:2377，它的作用主要是安全问题（如你只希望您的 swarm 管理界面只能在管理网络上访问）</span><br></pre></td></tr></table></figure><blockquote><p>如果已经执行过该命令了，但是又忘记了相关Token信息，可以重新执行；</p><p>注意，该命令在管理节点执行后，则 Docker Swarm 集群将会被解散。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先删除之前生成的相关信息</span></span><br><span class="line">docker swarm leave --force</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再次初始化新的Manager节点</span></span><br><span class="line">docker swarm init \</span><br><span class="line">--advertise-addr 192.168.56.161:2377 \</span><br><span class="line">--listen-addr 192.168.56.161:2377</span><br></pre></td></tr></table></figure></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801120658124.png" alt="image-20220801120658124"></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801120754165.png" alt="image-20220801120754165"></p><p>3、节点如何并入集群</p><ul><li><p>Manager 节点并入集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先在已有的Manager管理节点上生成其他Manager节点并入集群的IP+Token信息</span></span><br><span class="line">docker swarm join-token manager</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801120840144.png" alt="image-20220801120840144"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果我有其他想要成为manager的docker节点</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先在已有的manager节点上生成相关接入信息</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行生成的命令即可加入集群并成为manager角色</span></span><br><span class="line">docker swarm join --token SWMTKN-1-17fmka1c0l9e6hr66i5ksrl6wreworhx2gwte0644yaij5agvh-4z5yn1vvlvjzghhg1k36bg81k 192.168.56.161:2377</span><br></pre></td></tr></table></figure></li><li><p>Work 节点并入集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先在已有的Manager管理节点上生成其他Manager节点并入集群的IP+Token信息</span></span><br><span class="line">docker swarm join-token worker</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801121406755.png" alt="image-20220801121406755"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果我有其他想要加入Docker-Swarm集群的work节点</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先在已有的manager节点上生成相关接入信息</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行生成的命令即可加入集群并成为work角色</span></span><br><span class="line">docker swarm join --token SWMTKN-1-17fmka1c0l9e6hr66i5ksrl6wreworhx2gwte0644yaij5agvh-cbfo8i5ubyp4j80y9sqzam9tj 192.168.56.161:2377</span><br></pre></td></tr></table></figure></li></ul><p>&#x3D;&#x3D;以上两种角色的 Token 信息都生成完毕后，就可以将对应的服务器加入集群了&#x3D;&#x3D;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">work1</span></span><br><span class="line">docker swarm join --token SWMTKN-1-17fmka1c0l9e6hr66i5ksrl6wreworhx2gwte0644yaij5agvh-cbfo8i5ubyp4j80y9sqzam9tj 192.168.56.161:2377</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">work2</span></span><br><span class="line">docker swarm join --token SWMTKN-1-17fmka1c0l9e6hr66i5ksrl6wreworhx2gwte0644yaij5agvh-cbfo8i5ubyp4j80y9sqzam9tj 192.168.56.161:2377</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801121743804.png" alt="image-20220801121743804"></p><p>4、查看 Docker Swarm 集群状态</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801121931133.png" alt="image-20220801121931133"></p><p>5、集群可用性验证</p><blockquote><p>官方案例：Docker Swarm 集群上部署服务</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">部署应用</span></span><br><span class="line">docker service create --replicas 1 --name helloworld alpine ping docker.com</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看部署情况</span></span><br><span class="line">docker service ls</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--name helloworld：指定服务名为helloworld</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">alpine：为指定的镜像名</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ping docker.com：启动服务后执行的命令</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801122924054.png" alt="image-20220801122924054"></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801123016151.png" alt="image-20220801123016151"></p><p>&#x3D;&#x3D;至此 Docker Swarm 集群部署完毕！&#x3D;&#x3D;</p><h2 id="三、集群基本用法"><a href="#三、集群基本用法" class="headerlink" title="三、集群基本用法"></a>三、集群基本用法</h2><blockquote><p>根据上面的官方案例来演示。</p><p>除非特别说明，否则所有操作均在管理节点执行（操作）。</p><p>更多命令请参考<a href="https://docs.docker.com/engine/reference/commandline/node/">官方文档</a></p></blockquote><h3 id="3-1-运行服务"><a href="#3-1-运行服务" class="headerlink" title="3.1 运行服务"></a>3.1 运行服务</h3><p>1、创建服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">部署应用</span></span><br><span class="line">docker service create \</span><br><span class="line">  --replicas 1 \</span><br><span class="line">  --name helloworld \</span><br><span class="line">  --update-parallelism 2 \</span><br><span class="line">  alpine \</span><br><span class="line">  ping docker.com</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看部署情况</span></span><br><span class="line">docker service ls</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--replicas 1：指定运行的服务数（也就是你要启动几个容器）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--name helloworld：指定服务名为helloworld</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--update-parallelism：同时更新的服务数（默认为1--也就是其策略是一个服务一个服务的更新的）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">alpine：为指定的镜像名</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ping docker.com：启动服务后执行的命令</span></span><br></pre></td></tr></table></figure><blockquote><p>通过私有容器镜像仓库进行部署</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker login registry.example.com</span><br><span class="line">docker service  create \</span><br><span class="line">  --with-registry-auth \</span><br><span class="line">  --name my_service \</span><br><span class="line">  registry.example.com/acme/my_image:latest</span><br></pre></td></tr></table></figure><p>2、运行环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker service create --name helloworld \</span><br><span class="line">  --env MYVAR=myvalue \</span><br><span class="line">  --workdir /tmp \</span><br><span class="line">  --user my_user \</span><br><span class="line">  --hostname=&quot;&#123;&#123;.Node.ID&#125;&#125;-&#123;&#123;.Service.Name&#125;&#125;&quot; \</span><br><span class="line">  alpine ping docker.com</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--<span class="built_in">env</span>：自定义环境变量</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--workdir：指定容器的工作目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--user：以什么用户运行容器（用户名/UID）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--hostname：指定容器主机名</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">alpine：镜像名（不指定版本默认最新版本）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ping docker.com：启动服务后执行的命令</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220805114025744.png" alt="image-20220805114025744"></p><p>设置容器主机名案例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">  --replicas 2 \</span><br><span class="line">  --name redis \</span><br><span class="line">  --hostname=&quot;redis-3&quot; \</span><br><span class="line">  --update-delay 10s \</span><br><span class="line">  --update-parallelism 2 \</span><br><span class="line">  redis:3.0.6</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220805114429641.png" alt="image-20220805114429641"></p><h3 id="3-2-查看服务详情"><a href="#3-2-查看服务详情" class="headerlink" title="3.2 查看服务详情"></a>3.2 查看服务详情</h3><p>1、简要信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service inspect --pretty helloworld</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801123156070.png" alt="image-20220801123156070"></p><p>2、详细信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service inspect helloworld</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801123224388.png" alt="image-20220801123224388"></p><p>管理节点会通过相关调度，在集群节点中启动对应的容器，容器名以集群启动的服务名为基础随机生成。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801144334563.png" alt="image-20220801144334563"></p><h3 id="3-3-动态扩-缩-容"><a href="#3-3-动态扩-缩-容" class="headerlink" title="3.3 动态扩(缩)容"></a>3.3 动态扩(缩)容</h3><h4 id="3-3-1-扩容"><a href="#3-3-1-扩容" class="headerlink" title="3.3.1 扩容"></a>3.3.1 扩容</h4><blockquote><p>上面的测试实例为1，没有副本数，我们可以在集群中动态扩展副本数。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方法1</span></span><br><span class="line">docker service scale &lt;SERVICE-ID/SERVICE-NAME&gt;=&lt;NUMBER-OF-TASKS&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方法2</span></span><br><span class="line">docker service update --replicas &lt;NUMBER-OF-TASKS&gt; &lt;SERVICE-ID/SERVICE-NAME&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">案例（这两种方法都可以实现动态扩/缩容，选其一即可）</span></span><br><span class="line">docker service scale helloworld=2</span><br><span class="line">docker service update --replicas 2 helloworld</span><br></pre></td></tr></table></figure><blockquote><p>查看 swarm 集群运行服务的基本状态</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801145037815.png" alt="image-20220801145037815"></p><blockquote><p>查看 swarm 集群运行服务在哪个节点上运行（在哪个节点运行，就在哪个节点启动容器）</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801145215249.png" alt="image-20220801145215249"></p><h4 id="3-3-2-缩容"><a href="#3-3-2-缩容" class="headerlink" title="3.3.2 缩容"></a>3.3.2 缩容</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其实扩容和缩容的标准就是想对scale和--replicas而言的，如果指定的数值大于当前运行的服务数就是扩容，反之为缩容。</span><br></pre></td></tr></table></figure><h3 id="3-4-删除运行的服务"><a href="#3-4-删除运行的服务" class="headerlink" title="3.4 删除运行的服务"></a>3.4 删除运行的服务</h3><p>1、删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service rm helloworld</span><br></pre></td></tr></table></figure><p>2、验证是否删除成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service ls</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801150310996.png" alt="image-20220801150310996"></p><h3 id="3-5-服务滚动升级"><a href="#3-5-服务滚动升级" class="headerlink" title="3.5 服务滚动升级"></a>3.5 服务滚动升级</h3><p>1、升级步骤（假设运行了三个服务）</p><ul><li>先停止第一个服务；</li><li>为已停止的服务进行升级；</li><li>执行更新任务（如镜像版本升级）；</li><li>若升级完成后返回 <code>RUNNING</code>，则进入自定义的等待时间，等待时间完成后开始下一个服务的升级；</li><li>若更新期间（不管何时），更新返回结果为 <code>FAILED</code>，则停止更新。</li></ul><p>&#x3D;&#x3D;接下来开始实际案例演示&#x3D;&#x3D;</p><p>2、运行 redis 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">集群启动一个3.0.6版本的redis服务</span></span><br><span class="line">docker service create \</span><br><span class="line">  --replicas 3 \</span><br><span class="line">  --name redis \</span><br><span class="line">  --update-delay 10s \</span><br><span class="line">  --update-parallelism 2 \</span><br><span class="line">  redis:3.0.6</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--replicas 3：服务数为3</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--name redis：运行的服务名（自定义）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--update-delay 10s：更新完成后等待下一个服务跟新的时间（也就是服务间更的间隔时间）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--update-parallelism：同时更新的服务数（默认为1--也就是其策略是一个服务一个服务的更新的）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">redis:3.0.6：指定镜像名</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801153827618.png" alt="image-20220801153827618"></p><p>3、redis 版本更新</p><blockquote><p>Manager 根据 <code>UpdateConfig</code> 策略将更新应用到节点</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将redis镜像版本更新至3.0.7（管理节点执行）</span></span><br><span class="line">docker service update --image redis:3.0.7 redis</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801154553547.png" alt="image-20220801154553547"></p><p>下图是官方更新成功与失败的案例截图：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801154427672.png" alt="image-20220801154427672"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新失败后，可尝试重新更新</span></span><br><span class="line">docker service update redis</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;看看滚动更新效果&#x3D;&#x3D;</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801154926148.png" alt="image-20220801154926148"></p><h3 id="3-6-集群服务回滚"><a href="#3-6-集群服务回滚" class="headerlink" title="3.6 集群服务回滚"></a>3.6 集群服务回滚</h3><blockquote><p>如果升级失败，可进行回滚操作，会回滚到你上一个版本。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker service update \</span><br><span class="line">  --rollback \</span><br><span class="line">  --update-delay 0s \</span><br><span class="line">  my_web</span><br></pre></td></tr></table></figure><h3 id="3-7-节点脱离集群"><a href="#3-7-节点脱离集群" class="headerlink" title="3.7 节点脱离集群"></a>3.7 节点脱离集群</h3><blockquote><p>以下方法二选一即可</p></blockquote><p>1、节点脱离集群</p><blockquote><p>工作节点自己主动脱离集群</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使work1脱离集群</span></span><br><span class="line">[root@docker_swarm_work1 opt]# docker swarm leave</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制脱离</span></span><br><span class="line">[root@docker_swarm_work1 opt]# docker swarm leave --force</span><br></pre></td></tr></table></figure><blockquote><p>查看集群状态</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801143327408.png" alt="image-20220801143327408"></p><p>2、管理节点移除节点</p><blockquote><p>管理节点强制使节点脱离集群</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从管理节点中移除以停止或失效的节点</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除管理节点：</span></span><br><span class="line">docker node demote &lt;节点ID/HOSTNAME&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除work节点：</span></span><br><span class="line">docker node rm -f &lt;节点ID/HOSTNAME&gt;</span><br></pre></td></tr></table></figure><blockquote><p>通过管理节点使其他节点脱离集群时，如果被移除的这个集群想再次并入集群时，需要做如下操作</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在要并入集群的节点（被管理节点移除的节点）操作</span></span><br><span class="line">docker swarm leave --force</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始加入集群</span></span><br><span class="line">docker swarm join --token SWMTKN-1-17fmka1c0l9e6hr66i5ksrl6wreworhx2gwte0644yaij5agvh-cbfo8i5ubyp4j80y9sqzam9tj 192.168.56.161:2377</span><br></pre></td></tr></table></figure><h3 id="3-8-节点资源耗尽"><a href="#3-8-节点资源耗尽" class="headerlink" title="3.8 节点资源耗尽"></a>3.8 节点资源耗尽</h3><p>如果集群中某节点资源耗尽，那运行在该节点的服务将会发生什么？停止或是转移，答案是会通过管理节点进行相关调度将资源耗尽的节点上的服务进行转移，使其保持正常提供服务。</p><p>1、如下，我运行了三个服务</p><blockquote><p>每个节点都起了一个 redis 服务</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801160542727.png" alt="image-20220801160542727"></p><p>2、故意将 work1 节点置为资源耗尽状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node update --availability drain docker_swarm_work1</span><br></pre></td></tr></table></figure><p>3、查看节点是否可用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node inspect --pretty docker_swarm_work1</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801160908128.png" alt="image-20220801160908128"></p><p>4、看其上的 redis 服务是否转移了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">已经转移到管理节点上了</span></span><br><span class="line">docker service ps redis</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801161011290.png" alt="image-20220801161011290"></p><p>5、恢复至可用状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node update --availability active docker_swarm_work1</span><br></pre></td></tr></table></figure><blockquote><p>在看看节点可用状态</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801161244932.png" alt="image-20220801161244932"></p><p>&#x3D;&#x3D;但是要注意，恢复后，原来运行的服务不会因为它再次可用而还原到原来的状态。但是此时该节点可以接收管理节点的正常资源调度。&#x3D;&#x3D;</p><h3 id="3-9-节点角色管理"><a href="#3-9-节点角色管理" class="headerlink" title="3.9 节点角色管理"></a>3.9 节点角色管理</h3><p>1、升级角色</p><blockquote><p>将节点提升为管理节点</p><p>由 work 节点 —&gt;  manage 节点。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node promote &lt;node_name&gt;</span><br></pre></td></tr></table></figure><p>2、降级角色</p><blockquote><p>将节点降为工作节点</p><p>由 manage 节点 —&gt;  work 节点。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node demote &lt;node_name&gt;</span><br></pre></td></tr></table></figure><h3 id="3-10-节点标签管理"><a href="#3-10-节点标签管理" class="headerlink" title="3.10 节点标签管理"></a>3.10 节点标签管理</h3><p>标签有什么用？当你想部署服务某服务到指定的 work 节点时，可以使用标签的方式来实现。当你的节点没有定义标签，而你又以指定标签来创建服务，那服务是起不来的，如果此时你在其他节点打上刚刚你创建服务时指定的标签，那你之前创建的服务（带标签）就会在你正在打标签的这台节点上运行。</p><p>1、添加标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker node update docker_swarm_work1 --label-add label=filebeat1</span><br><span class="line">docker node update docker_swarm_work2 --label-add label=filebeat2</span><br><span class="line">docker node update docker_swarm_manager --label-add label=filebeat-m</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">说明：label=filebeat1是一个可以自定义的键值对</span></span><br></pre></td></tr></table></figure><p>2、修改标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker node update docker_swarm_work1 --label-add label=filebeat1-new</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其实就是同添加标签命令一样，保证 key 相同就会覆盖原 key 的值。</span></span><br></pre></td></tr></table></figure><p>3、删除标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node update docker_swarm_manager --label-rm label</span><br></pre></td></tr></table></figure><p>4、查看节点标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node inspect docker_swarm_work1</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220808161747515.png" alt="image-20220808161747515"></p><p>5、标签应用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">  --replicas 1 \</span><br><span class="line">  --name filebeat \</span><br><span class="line">  --network my-network \</span><br><span class="line">  --hostname=&quot;filebeat&quot; \</span><br><span class="line">  --constraint &#x27;node.labels.label == filebeat1&#x27; \</span><br><span class="line">  --mount type=bind,src=/data/docker_container/filebeat,dst=/usr/share/filebeat \</span><br><span class="line">  --mount type=bind,src=/data/nginx/logs,dst=/data/nginx/logs \</span><br><span class="line">  --mount type=bind,src=/etc/localtime,dst=/etc/localtime \</span><br><span class="line">  docker.elastic.co/beats/filebeat:6.8.23</span><br></pre></td></tr></table></figure><blockquote><p>运行后，报错了，错误日志显示为文件权限问题，按照提示修改即可</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220808162208549.png" alt="image-20220808162208549"></p><h3 id="3-11-资源限制"><a href="#3-11-资源限制" class="headerlink" title="3.11 资源限制"></a>3.11 资源限制</h3><p><code>docker run</code> 针对限制容器资源有许多设置选项，但 Swarm 中的 <code>docker service</code> 目前只有 cpu 和 memory 的选项可以操作。</p><p>如果 docker 找不到足够的资源來部署 service，则该 service 会进入 Pending 的狀態，然后持续 kill、recreate 的流程直到找到资源为止。</p><ul><li><strong>reserve</strong>：预定资源，是一种承诺，例如 Host 有 4 CPU，如果把某个 service 的 CPU 资源设为 4，其他 service 將无法取得任何 CPU 资源。&amp;#x20;</li><li><strong>limit</strong>：限制资源，最多可使用的资源。</li></ul><p>示例（资源限制）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker service create --reserve-memory 800M --limit-memory 1024M --reserve-cpu 1 --limit-cpu 1.5 masl</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">预定800M内存，最大可使用1G内存；预定1个cpu，最大可使用1.5个cpu</span></span><br></pre></td></tr></table></figure><p>示例（资源限制更新）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker service update --limit-cpu 0.5 --limit-memory 2G masl</span><br><span class="line">docker service update --limit-cpu 3 --limit-memory 1g masl</span><br><span class="line">docker service update --limit-cpu 2 --limit-memory 100m masl</span><br></pre></td></tr></table></figure><h2 id="四、集群网络模式"><a href="#四、集群网络模式" class="headerlink" title="四、集群网络模式"></a>四、集群网络模式</h2><p>集群网络模式与 docker 网络类型类似，比如桥接、Host等网络模式。一个服务部署于 docker swarm 集群中后，那客户如何才能访问你部署的服务呢？根据我们所学的 Docker 相关知识，我们一般会做端口的映射。因此 docker swarm 集群也是这种思想。那它具体是如何实现的呢？</p><p>所有节点都使用一个网络入口（模式），该网络入口（模式）上的每个节点都可以在已映射的端口上接收 docker swarm 集群中任何节点上相关服务的连接，即便该节点没有运行任何服务。</p><p>要使用该网络模式之前，需要在 swarm 集群节点间打通以下端口（所以注意防火墙 IP 白名单问题）：</p><ul><li>7946：容器网络发现端口（manager 和 worker 上）；</li><li>4789：容器网络入口端口（manager 和 worker 上）。</li></ul><p>&#x3D;&#x3D;注意：还有个 2377 端口&#x3D;&#x3D;：该端口用于集群管理通信的 TCP 端口（仅在 manager 上）。</p><p>如下图，尽管我的 node3 节点没有运行任何服务，但我依然可以通过该节点 IP+Port 来实现服务访问。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/ingress-routing-mesh.png" alt="ingress-routing-mesh"></p><p>初始化 swarm 或将 Docker 主机加入现有 swarm 时，会在该主机（管理节点）上创建两个新网络，当然工作节点也会创建对应的这两个网络。</p><ul><li><p>名为 ingress 的 overlay 网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">该网络的作用是：处理与swarm集群服务相关的控制和数据流量。swarm群组服务并不会将其连接到用户定义的overlay网络时，而是连接到默认的ingress网络。</span><br><span class="line">若要连接到用户自定义的overlay网络需要使用--network指定(但创建该用户自定义的overlay网络时必须使用--attachable选项)。</span><br></pre></td></tr></table></figure></li><li><p>名为 docker_gwbridge 的 bridge 网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">它将参与到该swarm群集的各个Docker守护程序连接连接起来。可以使用docker network create创建用户定义overlay网络，服务或容器一次可以连接到多个网络，服务或容器只能通过它们各自连接的网络进行通信</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-1-服务端口"><a href="#4-1-服务端口" class="headerlink" title="4.1 服务端口"></a>4.1 服务端口</h3><p>默认情况下，当您发布端口时，它默认就是 TCP 端口。当然，你可以指定 TCP 或 UDP 来发布，当您同时发布 TCP 和 UDP 端口时，如果你省略了协议说明符，则该端口将作为 TCP 端口来发布。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801165227555.png" alt="image-20220801165227555"></p><h4 id="4-1-1-TCP"><a href="#4-1-1-TCP" class="headerlink" title="4.1.1 TCP"></a>4.1.1 TCP</h4><p>1、语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">  --name &lt;SERVICE-NAME&gt; \</span><br><span class="line">  --publish published=&lt;PUBLISHED-PORT&gt;,target=&lt;CONTAINER-PORT&gt; \</span><br><span class="line">  &lt;IMAGE&gt;</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--publish：指定（映射）要发布的端口号</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">published：你要实际访问的外部端口（可自定义，不要和系统服务现有端口冲突即可）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">targetL：你swarm集群运行的服务（容器）的真实（内部）端口</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">短语法格式</span></span><br><span class="line">docker service create \</span><br><span class="line">  --name &lt;SERVICE-NAME&gt; \</span><br><span class="line">  -p &lt;PUBLISHED-PORT&gt;:&lt;CONTAINER-PORT&gt; \</span><br><span class="line">  &lt;IMAGE&gt;</span><br></pre></td></tr></table></figure><p>2、案例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">  --name my-web \</span><br><span class="line">  --publish published=8080,target=80 \</span><br><span class="line">  --replicas 2 \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801165353092.png" alt="image-20220801165353092"></p><p>3、访问验证</p><blockquote><p>上图可看出，这两个服务分别部署在了 work1、work2 上了，管理节点上没有被调度使用，现在就来验证管理是否能正常访问集群中的服务。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801165529583.png" alt="image-20220801165529583"></p><p>所以得出结论，在集群中部署的服务，不管是单节点服务，还是集群，在整个集群节点中都会映射对应的发布端口，所在集群部署服务时，确保所有集群节点的端口与你现在部署的服务端口不发生冲突。</p><p>4、如何改变现有服务的发布端口</p><blockquote><p>上面我定义发布端口为 8080，现在需要改为 8181，可做如下修改。</p><p>实际上这是新增映射端口，原来端口（8080）还存在，如果不需要可在添加完成后删掉旧的映射端口。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">语法</span></span><br><span class="line">docker service update \</span><br><span class="line">  --publish-add published=&lt;PUBLISHED-PORT&gt;,target=&lt;CONTAINER-PORT&gt; \</span><br><span class="line">  &lt;SERVICE&gt;</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">实例--新增端口映射</span></span><br><span class="line">docker service update \</span><br><span class="line">  --publish-add published=8181,target=80 \</span><br><span class="line">  my-web</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除映射的端口</span></span><br><span class="line">docker service update \</span><br><span class="line">  --publish-rm published=8080,target=80 \</span><br><span class="line">  my-web</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">但是注意，删除的时候新增的8181端口也被删除，还得重新映射，所以一般的操作步骤就是将原端口先<span class="built_in">rm</span>掉，在添加端口</span></span><br></pre></td></tr></table></figure><blockquote><p>如下图，同样是滚动更新的。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801172328081.png" alt="image-20220801172328081"></p><p>5、如何查看服务的发布端口？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service inspect --format=&quot;&#123;&#123;json .Endpoint.Spec.Ports&#125;&#125;&quot; my-web</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220801172550912.png" alt="image-20220801172550912"></p><h4 id="4-1-2-UDP"><a href="#4-1-2-UDP" class="headerlink" title="4.1.2 UDP"></a>4.1.2 UDP</h4><p>1、语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker service create --name &lt;SERVICE-NAME&gt; \</span><br><span class="line">  --publish published=&lt;PUBLISHED-PORT&gt;,target=&lt;CONTAINER-PORT&gt;,protocol=udp \</span><br><span class="line">  &lt;IMAGE&gt;</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--publish：指定（映射）要发布的端口号</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">published：你要实际访问的外部端口（可自定义，不要和系统服务现有端口冲突即可）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">targetL：你swarm集群运行的服务（容器）的真实（内部）端口</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">短语法格式</span></span><br><span class="line">docker service create \</span><br><span class="line">  --name &lt;SERVICE-NAME&gt; \</span><br><span class="line">  -p &lt;PUBLISHED-PORT&gt;:&lt;CONTAINER-PORT&gt;/udp \</span><br><span class="line">  &lt;IMAGE&gt;</span><br></pre></td></tr></table></figure><p>2、案例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">长语法</span></span><br><span class="line">docker service create --name dns-cache \</span><br><span class="line">  --publish published=53,target=53,protocol=udp \</span><br><span class="line">  dns-cache</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">短语法</span></span><br><span class="line">docker service create --name dns-cache \</span><br><span class="line">  -p 53:53/udp \</span><br><span class="line">  dns-cache</span><br></pre></td></tr></table></figure><h4 id="4-1-3-TCP-及-UDP"><a href="#4-1-3-TCP-及-UDP" class="headerlink" title="4.1.3 TCP 及 UDP"></a>4.1.3 TCP 及 UDP</h4><p>1、语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker service create --name dns-cache \</span><br><span class="line">  --publish published=53,target=53 \</span><br><span class="line">  --publish published=53,target=53,protocol=udp \</span><br><span class="line">  dns-cache</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--publish：指定（映射）要发布的端口号</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">published：你要实际访问的外部端口（可自定义，不要和系统服务现有端口冲突即可）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">targetL：你swarm集群运行的服务（容器）的真实（内部）端口</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">短语法格式</span></span><br><span class="line">docker service create --name &lt;SERVICE-NAME&gt; \</span><br><span class="line">  -p &lt;PUBLISHED-PORT&gt;:&lt;CONTAINER-PORT&gt; \</span><br><span class="line">  -p &lt;PUBLISHED-PORT&gt;:&lt;CONTAINER-PORT&gt;/udp \</span><br><span class="line">  &lt;IMAGE&gt;</span><br></pre></td></tr></table></figure><p>2、案例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">长语法</span></span><br><span class="line">docker service create --name dns-cache \</span><br><span class="line">  --publish published=53,target=53 \</span><br><span class="line">  --publish published=53,target=53,protocol=udp \</span><br><span class="line">  dns-cache</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">短语法</span></span><br><span class="line">docker service create --name dns-cache \</span><br><span class="line">  -p 53:53 \</span><br><span class="line">  -p 53:53/udp \</span><br><span class="line">  dns-cache</span><br></pre></td></tr></table></figure><h3 id="4-2-Host-网络"><a href="#4-2-Host-网络" class="headerlink" title="4.2 Host 网络"></a>4.2 Host 网络</h3><p>如不想经过路由，而直接访问集群服务，可采用 Host 模式，在部署服务时指定。其实这就是 Docker 的 Host 网络模式，共享宿主机网络。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker service create --name dns-cache \</span><br><span class="line">  --publish published=53,target=53,protocol=udp,mode=host \</span><br><span class="line">  --mode global \</span><br><span class="line">  dns-cache</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;至此，基于 Linux 的 Docker Swarm 集群部署及应用告一段落，这种简单的容器编排最终还是会转向 K8s，但是我们也要根据实际场景来部署，别什么一来就上 K8s，也许你目前的服务数量都不够 K8s 的基本生产部署条件。因此，我们是逐步转向 K8s 集群的，不管任何技术，它都有个过渡期。后续会继续分享 Docker Swarm 集群详细的工作原理及网络模式。&#x3D;&#x3D;</p><h3 id="4-3-负载均衡"><a href="#4-3-负载均衡" class="headerlink" title="4.3 负载均衡"></a>4.3 负载均衡</h3><p>在集群中，可通过任意一个节点来实现访问，不管该节点是否已经部署了服务都可访问。因此所有节点都是平等的（对于客户端而言）。于是，我们可以使用负载均衡技术来实现统一入口访问。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/ingress-lb.png" alt="ingress-lb"></p><p>如上图，Docker Swarm 负载均衡有两种模式，一种是vip（默认），另一种是dnsrr，dnsrr模式下 -p参数是无效的，就是说其服务器是无法直接通过端口映射被外边访问的，如果想要被外边访问有两种方式：一种是使用浏览器代理，可参考<a href="https://5socks.net/Manual/browser_en.html">https://5socks.net/Manual/browser_en.html</a> ；另一种是使用类似nginx转发功能。</p><p>&#x3D;&#x3D;使用 Nginx 实现：&#x3D;&#x3D;</p><p>1、创建 overlay 网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver overlay swarm-net</span><br></pre></td></tr></table></figure><p>2、创建 nginx 转发路由服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">  --replicas 1 \</span><br><span class="line">  --name proxy_docker \</span><br><span class="line">  --network swarm-net \</span><br><span class="line">  --publish published=8088,target=8088 \</span><br><span class="line">  --publish published=50070,target=50070 \</span><br><span class="line">  centos7.3:latest /usr/sbin/init /bin/bash</span><br></pre></td></tr></table></figure><p>官方的说明：</p><p>Use the –publish flag to publish a port when you create a service. target is used to specify the port inside the container, and published is used to specify the port to bind on the routing mesh. If you leave off the published port, a random high-numbered port is bound for each service task. You need to inspect the task to determine the port.</p><p>翻译：</p><p>在创建服务时，使用–Publish标志发布端口。Target用于指定容器内部的端口，PUBLISHED用于指定要绑定到路由网格上的端口。如果不使用发布的端口，则会为每个服务任务绑定一个随机的高编号端口。您需要检查任务以确定端口。</p><p>3、在proxy_docker容器中安装nginx并配置负载均衡即可</p><p>此时就可以通过8088、50070进行访问了。</p><h3 id="4-4-自定义网络"><a href="#4-4-自定义网络" class="headerlink" title="4.4 自定义网络"></a>4.4 自定义网络</h3><p>1、创建网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker network create \</span><br><span class="line">  --driver overlay \</span><br><span class="line">  --subnet 10.0.9.0/24 \</span><br><span class="line">  --gateway 10.0.9.1 \</span><br><span class="line">  my-network</span><br></pre></td></tr></table></figure><p>2、使用自定义的网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">  --replicas 2 \</span><br><span class="line">  --name my-web \</span><br><span class="line">  --network my-network \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure><p>说明：自定义的网络可使该网络模式下的服务互相通信（包括跨主机通信）。</p><p>4、将现有服务并入自定义的网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service update --network-add my-network my-web</span><br></pre></td></tr></table></figure><p>5、将自定义网络下的服务移除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service update --network-rm my-network my-web</span><br></pre></td></tr></table></figure><h2 id="五、集群安全"><a href="#五、集群安全" class="headerlink" title="五、集群安全"></a>五、集群安全</h2><h3 id="5-1-集群安全"><a href="#5-1-集群安全" class="headerlink" title="5.1 集群安全"></a>5.1 集群安全</h3><ul><li></li></ul><h3 id="5-2-服务安全"><a href="#5-2-服务安全" class="headerlink" title="5.2 服务安全"></a>5.2 服务安全</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">     --name nginx \</span><br><span class="line">     --secret site.key \</span><br><span class="line">     --secret site.crt \</span><br><span class="line">     --secret site.conf \</span><br><span class="line">     --publish published=3000,target=443 \</span><br><span class="line">     nginx:latest \</span><br><span class="line">     sh -c &quot;ln -s /root/site.conf /etc/nginx/conf.d/site.conf &amp;&amp; exec nginx -g &#x27;daemon off;&#x27;&quot;</span><br></pre></td></tr></table></figure><h3 id="5-3-数据持久化"><a href="#5-3-数据持久化" class="headerlink" title="5.3 数据持久化"></a>5.3 数据持久化</h3><p>Docker 相关得服务，我们一般是要做数据持久化的。集群中使用 volume 或者 bind 类型来挂载，而 –mount 无论使用哪种类型，在创建服务时都是使用该参数。如何对现有的服务更新持久化目录？可采用这两个参数来实现：<code>--mount-add</code>、<code>--mount-rm</code>。</p><p>1、创建服务时指定持久化目录</p><ul><li><p>默认数据卷驱动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">语法</span></span><br><span class="line">docker service create \</span><br><span class="line">  --mount src=&lt;VOLUME-NAME&gt;,dst=&lt;CONTAINER-PATH&gt; \</span><br><span class="line">  --name myservice \</span><br><span class="line">  &lt;IMAGE&gt;</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">src：宿主机持久化目录（执行时不存在则自动创建）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">dst：容器内部数据目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认数据卷驱动为<span class="built_in">local</span></span></span><br></pre></td></tr></table></figure></li><li><p>指定数据卷驱动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">语法</span></span><br><span class="line">docker service create \</span><br><span class="line">  --mount type=volume,src=&lt;VOLUME-NAME&gt;,dst=&lt;CONTAINER-PATH&gt;,volume-driver=&lt;DRIVER&gt;,volume-opt=&lt;KEY0&gt;=&lt;VALUE0&gt;,volume-opt=&lt;KEY1&gt;=&lt;VALUE1&gt; \</span><br><span class="line">  --name myservice \</span><br><span class="line">  &lt;IMAGE&gt;</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">src：宿主机持久化目录（执行时不存在则自动创建）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">dst：容器内部数据目录</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">  --mount type=bind,src=&lt;HOST-PATH&gt;,dst=&lt;CONTAINER-PATH&gt; \</span><br><span class="line">  --name myservice \</span><br><span class="line">  &lt;IMAGE&gt;</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要求src必须提前存在</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">权限：读写</span></span><br><span class="line"></span><br><span class="line">========================================</span><br><span class="line">docker service create \</span><br><span class="line">  --mount type=bind,src=&lt;HOST-PATH&gt;,dst=&lt;CONTAINER-PATH&gt;,readonly \</span><br><span class="line">  --name myservice \</span><br><span class="line">  &lt;IMAGE&gt;</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要求src必须提前存在</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">权限：只读</span></span><br></pre></td></tr></table></figure></li></ul><p>2、更新现有的服务的持久化目录</p><ul><li><p>新增数据卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">  --mount-add src=&lt;VOLUME-NAME&gt;,dst=&lt;CONTAINER-PATH&gt; \</span><br><span class="line">  --name myservice \</span><br><span class="line">  &lt;IMAGE&gt;</span><br></pre></td></tr></table></figure></li><li><p>删除数据卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">  --mount-rm src=&lt;VOLUME-NAME&gt;,dst=&lt;CONTAINER-PATH&gt; \</span><br><span class="line">  --name myservice \</span><br><span class="line">  &lt;IMAGE&gt;</span><br></pre></td></tr></table></figure></li></ul><p>3、案例</p><p>&#x3D;&#x3D;用 bind 方式来实现&#x3D;&#x3D;</p><ul><li><p>创建持久化目录</p><blockquote><p>先在集群中某台服务器执行，完成后在将整体目录结构同步于其他集群节点</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/nginx/&#123;conf,html,logs&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动临时容器（拷贝必要配置文件至持久化目录）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行临时容器</span></span><br><span class="line">docker run -d --name=tmp nginx:1.20.2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拷贝相关文件</span></span><br><span class="line">docker cp tmp:/etc/nginx/nginx.conf /data/nginx/conf/</span><br><span class="line">docker cp tmp:/etc/nginx/conf.d /data/nginx/conf/</span><br></pre></td></tr></table></figure></li><li><p>将目录&#x2F;文件 scp 至其他节点</p><blockquote><p>因为集群内部服务运行节点是随机的，所以要保证集群中所有工作节点都具备相同的程序（服务）运行环境。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r /data/nginx/conf 192.168.56.132:/data/nginx/</span><br><span class="line">scp -r /data/nginx/conf 192.168.56.133:/data/nginx/</span><br></pre></td></tr></table></figure></li><li><p>Docker Swarm 集群启动服务</p><blockquote><p>以上配置完成后，就可以在集群的管理节点执行如下命令来启动一个服务</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">  --replicas 2 \</span><br><span class="line">  --name my-web \</span><br><span class="line">  --network my-network \</span><br><span class="line">  --publish published=8080,target=80 \</span><br><span class="line">  --hostname=&quot;my-nginx&quot; \</span><br><span class="line">  --mount type=bind,src=/data/nginx/conf/nginx.conf,dst=/etc/nginx/nginx.conf \</span><br><span class="line">  --mount type=bind,src=/data/nginx/conf/conf.d,dst=/etc/nginx/conf.d \</span><br><span class="line">  --mount type=bind,src=/data/nginx/html,dst=/usr/share/nginx/html \</span><br><span class="line">  --mount type=bind,src=/data/nginx/logs,dst=/var/log/nginx \</span><br><span class="line">  nginx:1.20.2</span><br></pre></td></tr></table></figure></li><li><p>创建测试数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch /data/nginx/html/index.html</span><br><span class="line">echo &quot;test&quot; &gt; /data/nginx/html/index.html</span><br></pre></td></tr></table></figure></li><li><p>验证</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220805130319377.png" alt="image-20220805130319377"></p></li></ul><p>&#x3D;&#x3D;用 volume 来实现：&#x3D;&#x3D;</p><p>下面的功能实现将容器内部的 <code>/usr/share/nginx/html</code> 目录以  volume 持久化到 Host 本地，至于会持久化到哪个 node 节点，就看这个 service 是在哪个节点上运行的，service 在哪个节点上运行就持久化到哪个节点上，并且你会看到挂载的目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">  --replicas 1 \</span><br><span class="line">  --name my-web \</span><br><span class="line">  --publish published=10800,target=80 \</span><br><span class="line">  --hostname=&quot;my-nginx&quot; \</span><br><span class="line">  --constraint node.labels.label==produce-smzhsserver \</span><br><span class="line">  --mount &#x27;type=volume,src=nginx,dst=/usr/share/nginx/html,volume-driver=local,volume-nocopy=true,volume-opt=type=nfs,volume-opt=device=172.17.16.86:/data/nginx,&quot;volume-opt=o=addr=172.17.16.86,vers=4,soft,timeo=180,bg,tcp,rw&quot;&#x27; \</span><br><span class="line">  nginx:1.20.2</span><br></pre></td></tr></table></figure><p>我去 produce-smzhsserver 节点上去看看：</p><blockquote><p>86 NFS 共享的目录已经被自动挂载到运行 service 的节点上，当集群删除 service 时会自动取消挂载。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221118173834456.png" alt="image-20221118173834456"></p><p>再看看 produce-smzhsserver 节点上的持久化目录：</p><blockquote><p>volume 数据卷路径：&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;nginx&#x2F;_data</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221118174309280.png" alt="image-20221118174309280"></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>注意关闭相关主机防火墙，或者你开放了防火墙后，注意添加相关 IP Port 白名单、安全组等。</p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> Docker Swarm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker_Swarm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改 Docker 默认数据存储路径</title>
      <link href="/posts/articles/f3a0a47c.html"/>
      <url>/posts/articles/f3a0a47c.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/docker.png" alt="docker"></p><p><font color=Brown><strong>Author</strong>：rab</font><br><font color=Brown><strong>Date</strong>：2022&#x2F;07&#x2F;22</font><br><font color=Brown><strong>Blog</strong>：<a href="https://blog.csdn.net/IT_ZRS?type=blog"><font color=Brown>https://blog.csdn.net/IT_ZRS?type&#x3D;blog</font></a></font></p><p><strong>Linux Version</strong>：CentOS 7.9<br><strong>Docker Version</strong>：18.06.3</p><hr><p>会存在这样一种情况，当我们安装 Docker 的时候，如果不修改默认数据存储路径的话，其一般默认为 <code>/var/lib/docker/</code> ，该目录是挂载于我们服务器系统盘（&#x2F;）下的，当你后面运行的容器和下载的镜像越来越多时，就会导致磁盘空间被占满，从而无法登录操作系统。此时，就需要调整 Docker 的数据存储目录了。</p><hr><p><strong>1、yum 安装 Docker</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里以 yum 方式安装的 Docker 来举例</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其实不管那种方式部署的Docker，其实原理都一样，掌握一种即可。</span></span><br></pre></td></tr></table></figure><p><strong>2、查看默认路径</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info |grep &#x27;Docker Root Dir&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220722113558578.png" alt="image-20220722113558578"></p><p><strong>3、创建数据存储目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/data/docker</span><br></pre></td></tr></table></figure><p><strong>4、修改配置文件（默认路径）</strong></p><blockquote><p>常用三种方法修改默认数据存储路径的方法（三选一即可）</p></blockquote><ul><li><p>修改配置 <code>daemon.json</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止所有正在运行的容器</span></span><br><span class="line">docker stop $(docker ps -a | awk &#x27;&#123; print $1&#125;&#x27; | tail -n +2)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止docker服务</span></span><br><span class="line">systemctl stop docker.service</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改配置</span></span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://q1rw9tzz.mirror.aliyuncs.com&quot;],</span><br><span class="line">  &quot;graph&quot;: &quot;/home/data/docker&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动docker服务</span></span><br><span class="line">systemctl start docker.service</span><br></pre></td></tr></table></figure><p>⚠：重启后，你会发现&#x3D;&#x3D;所有容器和镜像&#x3D;&#x3D;都消失了，那是因为你的 Docker 的数据目录改变了，而旧数据还在原来的 <code>/var/lib/docker/</code> 下，所以此时你是看不到有任何容器和镜像的。</p><p>解决方法就是：将默认数据<code>/var/lib/docker/</code>替换新数据<code>/home/data/docker</code>后，再次重启即可。&#x3D;&#x3D;所以在部署 Docker 的时候就应该先规划好相关路径。&#x3D;&#x3D;</p></li><li><p>修改 <code>systemd</code> 管理脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /lib/systemd/system/docker.service</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">ExecStart=/usr/bin/dockerd --graph /home/data/docker</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重载</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启</span></span><br><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure></li><li><p>软链接方式（推荐）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看docker默认数据存储路径容量大小</span></span><br><span class="line">[root@jenkins-node1 data]# cd /var/lib/docker</span><br><span class="line">[root@jenkins-node1 docker]# du -sh</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220722121218262.png" alt="image-20220722121218262"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mv</span>移动到新的数据目录，并做软链接</span></span><br><span class="line">[root@jenkins-node1 data]# ln -s /home/data/docker /var/lib/docker</span><br><span class="line">[root@jenkins-node1 data]# ll /var/lib/docker</span><br><span class="line">lrwxrwxrwx 1 root root 17 Jul 22 12:15 /var/lib/docker -&gt; /home/data/docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启一下Docker</span></span><br><span class="line">systemctl start docker.service</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意：不要直接将空目录/home/data/docker软链接到docker默认的数据目录上，因为这样会导致数据目标链接的数据被清空，所以先<span class="built_in">mv</span>一下在做软链接（除非你确认你的目标数据可以被覆盖）</span></span><br></pre></td></tr></table></figure></li></ul><p><mark>至此，Docker 默认数据目录修改完成！！</mark></p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何制作一个精简的 Docker 镜像？</title>
      <link href="/posts/articles/f1d19dd5.html"/>
      <url>/posts/articles/f1d19dd5.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、选用最小基础镜像"><a href="#一、选用最小基础镜像" class="headerlink" title="一、选用最小基础镜像"></a>一、选用最小基础镜像</h2><p>比如：debian（更推荐）、Ubuntu。</p><p>案例：通过 Debian、Ubuntu 基础镜像构建 redis 镜像。</p><h3 id="1-1-Ubuntu"><a href="#1-1-Ubuntu" class="headerlink" title="1.1 Ubuntu"></a>1.1 Ubuntu</h3><p>1、Dockerfile</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; Dockerfile-Ubuntu &lt;&lt;&#x27;EOF&#x27;</span><br><span class="line">FROM ubuntu:trusty</span><br><span class="line">ENV VER 3.0.0</span><br><span class="line">ENV URL http://download.redis.io/releases/redis-$VER.tar.gz</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y curl make gcc</span><br><span class="line">RUN curl -L $URL | tar zxv</span><br><span class="line">WORKDIR redis-$VER</span><br><span class="line">RUN make</span><br><span class="line">RUN make install</span><br><span class="line">WORKDIR /</span><br><span class="line">RUN apt-get remove -y --auto-remove curl make gcc</span><br><span class="line">RUN apt-get clean</span><br><span class="line">RUN rm -rf /var/lib/apt/lists/* /redis-$VER</span><br><span class="line">CMD [&quot;redis-server&quot;]</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>2、构建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t redis:v1 -f Dockerfile-Ubuntu .</span><br></pre></td></tr></table></figure><h3 id="1-2-Debian"><a href="#1-2-Debian" class="headerlink" title="1.2 Debian"></a>1.2 Debian</h3><p>1、Dockerfile</p><blockquote><p>更换一下国内源：<a href="https://developer.aliyun.com/mirror/debian?spm=a2c6h.13651102.0.0.4a0c1b111SQZ4Z">https://developer.aliyun.com/mirror/debian?spm=a2c6h.13651102.0.0.4a0c1b111SQZ4Z</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; Dockerfile-Debian &lt;&lt;&#x27;EOF&#x27;</span><br><span class="line">FROM debian:jessie</span><br><span class="line">ENV VER 3.0.0</span><br><span class="line">ENV URL http://download.redis.io/releases/redis-$VER.tar.gz</span><br><span class="line">RUN echo &quot;deb http://mirrors.aliyun.com/debian jessie main contrib non-free&quot; &gt; /etc/apt/sources.list</span><br><span class="line">RUN echo &quot;deb-src http://mirrors.aliyun.com/debian jessie main contrib non-free&quot; &gt;&gt; /etc/apt/sources.list</span><br><span class="line">RUN echo &quot;deb http://mirrors.aliyun.com/debian jessie-updates main contrib non-free&quot; &gt;&gt; /etc/apt/sources.list</span><br><span class="line">RUN echo &quot;deb-src http://mirrors.aliyun.com/debian jessie-updates main contrib non-free&quot; &gt;&gt; /etc/apt/sources.list</span><br><span class="line">RUN echo &quot;deb http://mirrors.aliyun.com/debian-security jessie/updates main contrib non-free&quot; &gt;&gt; /etc/apt/sources.list</span><br><span class="line">RUN echo &quot;deb-src http://mirrors.aliyun.com/debian-security jessie/updates main contrib non-free&quot; &gt;&gt; /etc/apt/sources.list</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y curl make gcc</span><br><span class="line">RUN curl -L $URL | tar zxv</span><br><span class="line">WORKDIR redis-$VER</span><br><span class="line">RUN make</span><br><span class="line">RUN make install</span><br><span class="line">WORKDIR /</span><br><span class="line">RUN apt-get remove -y --auto-remove curl make gcc</span><br><span class="line">RUN apt-get clean</span><br><span class="line">RUN rm -rf /var/lib/apt/lists/* /redis-$VER</span><br><span class="line">CMD [&quot;redis-server&quot;]</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>2、构建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t redis:v2 -f Dockerfile-Debian .</span><br></pre></td></tr></table></figure><h3 id="1-3-镜像大小对比"><a href="#1-3-镜像大小对比" class="headerlink" title="1.3 镜像大小对比"></a>1.3 镜像大小对比</h3><p>redis:v1：Ubuntu 为基础构建的镜像</p><p>redis:v2：Debian 为基础构建的镜像</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220831160948177.png" alt="image-20220831160948177"></p><p>可见，Debian 构建的镜像比 Ubuntu 构建的镜像小，&#x3D;&#x3D;所以我们一般通过 Debian 作为基础镜像来构建镜像&#x3D;&#x3D;。</p><h2 id="二、串联指令"><a href="#二、串联指令" class="headerlink" title="二、串联指令"></a>二、串联指令</h2><p>Dockerfile 中最多只能有 127 个 RUN 指令，镜像制作中我们可以将多条 RUN 指令合并为一条 RUN 指令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; Dockerfile-Debian &lt;&lt;&#x27;EOF&#x27;</span><br><span class="line">FROM debian:jessie</span><br><span class="line">ENV VER 3.0.0</span><br><span class="line">ENV URL http://download.redis.io/releases/redis-$VER.tar.gz</span><br><span class="line">RUN echo &quot;deb http://mirrors.aliyun.com/debian jessie main contrib non-free&quot; &gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="line">    echo &quot;deb-src http://mirrors.aliyun.com/debian jessie main contrib non-free&quot; &gt;&gt; /etc/apt/sources.list  &amp;&amp; \</span><br><span class="line">    echo &quot;deb http://mirrors.aliyun.com/debian jessie-updates main contrib non-free&quot; &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="line">    echo &quot;deb-src http://mirrors.aliyun.com/debian jessie-updates main contrib non-free&quot; &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="line">    echo &quot;deb http://mirrors.aliyun.com/debian-security jessie/updates main contrib non-free&quot; &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="line">    echo &quot;deb-src http://mirrors.aliyun.com/debian-security jessie/updates main contrib non-free&quot; &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="line">    apt-get update &amp;&amp; \</span><br><span class="line">    apt-get install -y curl make gcc &amp;&amp; \</span><br><span class="line">    curl -L $URL | tar zxv &amp;&amp; \</span><br><span class="line">    cd redis-$VER &amp;&amp; \</span><br><span class="line">    make &amp;&amp; \</span><br><span class="line">    make install &amp;&amp; \</span><br><span class="line">    cd / &amp;&amp; \</span><br><span class="line">    apt-get remove -y --auto-remove curl make gcc &amp;&amp; \</span><br><span class="line">    apt-get clean &amp;&amp; \</span><br><span class="line">    rm -rf /var/lib/apt/lists/* /redis-$VER</span><br><span class="line">CMD [&quot;redis-server&quot;]</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>看看串联后构建的镜像大小：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220831162432371.png" alt="image-20220831162432371"></p><p>可明显看到，redis:v3 镜像的大小仅为 144M，是没有将 RUN 指令合并前构建镜像的二分之一还要小，可见 RUN 指令串联后效果是很明显的。</p><h2 id="三、压缩镜像"><a href="#三、压缩镜像" class="headerlink" title="三、压缩镜像"></a>三、压缩镜像</h2><p>实际上就是将多个 RUN 指令进行压缩，下载 docker-squash 即可，解压就是一个二进制文件。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220831162208429.png" alt="image-20220831162208429"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加到环境变量</span></span><br><span class="line">mv docker-squash /usr/local/bin/</span><br></pre></td></tr></table></figure><p>开始压缩</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker save redis:v2 | docker-squash -verbose -t redis:v4 | docker load</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">压缩redis:v2镜像为redis:v4然后再导回redis:v2</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">效果并不是很明显（尝试压缩即可）</span></span><br></pre></td></tr></table></figure><h2 id="四、使用专用的基础镜像"><a href="#四、使用专用的基础镜像" class="headerlink" title="四、使用专用的基础镜像"></a>四、使用专用的基础镜像</h2><p>如 scratch、busybox 镜像。</p><h3 id="4-1-运行一个-redis-容器"><a href="#4-1-运行一个-redis-容器" class="headerlink" title="4.1 运行一个 redis 容器"></a>4.1 运行一个 redis 容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --rm --name=tmp --hostname tmp redis:v3</span><br></pre></td></tr></table></figure><h3 id="4-2-查看可执行模块的所属"><a href="#4-2-查看可执行模块的所属" class="headerlink" title="4.2 查看可执行模块的所属"></a>4.2 查看可执行模块的所属</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it tmp bash</span><br><span class="line">ldd /usr/local/bin/redis-server</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220831164416695.png" alt="image-20220831164416695"></p><blockquote><p>将所属的文件都 copy 到 Host，然后使用空镜像（scratch）为基础镜像进行打包。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker cp tmp:/usr .</span><br><span class="line">docker cp tmp:/lib .</span><br><span class="line">docker cp tmp:/lib64 .</span><br><span class="line"></span><br><span class="line">tar czf rootfs.tar.gz usr lib lib64</span><br></pre></td></tr></table></figure><p>编写 Dockerfile</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; Dockerfile-Rootfs &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">FROM scratch</span><br><span class="line">ADD rootfs.tar.gz /</span><br><span class="line">COPY redis.conf /etc/redis/redis.conf</span><br><span class="line">EXPOSE 6379</span><br><span class="line">CMD [&quot;/usr/local/bin/redis-server&quot;]</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>构建镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t redis:v4 -f Dockerfile-Rootfs .</span><br></pre></td></tr></table></figure><p>查看镜像大小</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220831171305830.png" alt="image-20220831171305830"></p><p>运行容器并查看容器日志</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220831171105626.png" alt="image-20220831171105626"></p><p><mark>以上就是如何制作一个最简镜像。</mark></p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何理解 K8s 动态伸缩与触发上线？</title>
      <link href="/posts/articles/e927d0f0.html"/>
      <url>/posts/articles/e927d0f0.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/yys.jpeg" alt="yys"></p><p><strong>K8s 版本</strong>：1.23.6</p><hr><p>一般地，如果仅修改 Pod 的副本数（如新增&#x2F;缩减），这就属于<code>动态伸缩</code>。如果是修改容器镜像的版本，则会触发上线，具体看下面例子。</p><h2 id="一、动态伸缩"><a href="#一、动态伸缩" class="headerlink" title="一、动态伸缩"></a>一、动态伸缩</h2><p>1、查看当前 Pod 副本（当前为 2）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230210162734240.png" alt="image-20230210162734240"></p><p>2、扩容 Pod 副本数（扩容为 3）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1：编辑控制器，修改副本</span></span><br><span class="line">kubectl edit deployment nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2：修改YAML配置文件</span></span><br><span class="line">...</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      web: web-server</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法3：scale</span></span><br><span class="line">kubectl scale deployments/nginx --replicas=3</span><br></pre></td></tr></table></figure><p>3、apply 应用创建资源</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx.yml</span><br></pre></td></tr></table></figure><p>4、再次查看副本数</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod</span><br></pre></td></tr></table></figure><blockquote><p>可见，副本数已经调整为 3 了，你会发现，它是在原副本数的基础上新增了一个副本，之前的副本仍保持不变且正常对外提供服务，且 Replicaset 名也没发生变化。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230210163525542.png" alt="image-20230210163525542"></p><blockquote><p>如果要实现缩容，把值调小于当前值即可。</p></blockquote><h2 id="二、触发上线"><a href="#二、触发上线" class="headerlink" title="二、触发上线"></a>二、触发上线</h2><p>1、查看当前 Pod 副本（当前为 3）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230210163525542.png" alt="image-20230210163525542"></p><p>2、修改 Pod 中容器的镜像版本号</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1：编辑控制器，修改副本</span></span><br><span class="line">kubectl edit deployment nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2：修改YAML配置文件</span></span><br><span class="line">...</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: nginx</span><br><span class="line">          image: nginx:1.23.3</span><br><span class="line">          ports:</span><br><span class="line">          - containerPort: 80</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>3、apply 应用创建资源</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx.yml</span><br></pre></td></tr></table></figure><p>4、查看 Pod 是否正常运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230210165232135.png" alt="image-20230210165232135"></p><p>5、验证 Pod 中容器镜像版本号</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe replicaset nginx-7ccc4bb9dd</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230210165053887.png" alt="image-20230210165053887"></p><p>你会发现，这三个新的 Pod 实现了一个滚动更新的效果，ReplicaSet 名也发生了变化，也就是说创建了新的 ReplicaSet，新版逐渐替换旧版。如下图所示，创建了一个名为 <code>nginx-7ccc4bb9dd</code> 的 ReplicaSet 资源，并替换了旧的 ReplicaSet。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230210165559485.png" alt="image-20230210165559485"></p><p>所以这里 ReplicaSet 的作用就很明显了，前面的章节提到 ReplicaSet 创建于 Deployment，且 ReplicaSet 的名称为 <code>Deploymen名称 + hash字串</code>，这个 Hash 字串保证了不重叠，可见上图两个 ReplicaSet 资源，均来源于同个 Deploymen，但由于 Hash 的作用，在服务版本升级时避免了重叠现象。</p><p>之所以保留旧的 ReplicaSet，也是便于版本会退时直接沿用原来的 ReplicaSet。</p><p><mark>小结：</mark></p><ul><li><p>动态伸缩时，ReplicaSet 资源不发生变化，触发上线时，ReplicaSet 发生了变化；</p></li><li><p>动态伸缩时，扩容则会在原 Pod 副本数的基础上新增 Pod，此时未发生触发上线；</p></li><li><p>触发上线时，如修改 Pod 容器镜像版本，则所有 Pod 依次实现滚动升级，此时未发生动态伸缩。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> K8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8s </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins Pipeline 方法定义及调用</title>
      <link href="/posts/articles/fcc16254.html"/>
      <url>/posts/articles/fcc16254.html</url>
      
        <content type="html"><![CDATA[<p>网上查了一些文档资料，<code>Jenkins Pipeline 方法调用</code> 的文章还是比较少的，就算有也描述得不太清楚。于是根据自己的经验总结了如何在 Jenkinsfile 进行方法调用。如有不当之处，请予指正。</p><p>首先来说一下为什么要使用<code>方法</code>？有这样一个场景，我有十几台远端服务器，这些服务器都是我的测试（或线上）服务器，我构建后的包需要部署到这些服务器上，于是我会为每台远程服务器定义相关登录信息（用户名、密码或密钥）等。这些配置对于每台服务器来说其实都是一样，无非就是 IP 不同而已（用户名、密钥或密码我暂且保持一致），于是我就可以将相同的部分定义为一个方法或叫函数，并在我的流水线阶段来调用这些方法或函数，当你定义的函数过多时，你还可以将这些函数写道<code>共享库</code>中，然后流水线调用共享库即可。</p><p>本案例以<code>声明式</code>  Jenkinsfile 为例进行演示！</p><h3 id="1、定义方法（函数）"><a href="#1、定义方法（函数）" class="headerlink" title="1、定义方法（函数）"></a>1、定义方法（函数）</h3><p>方法定义于 <code>pipeline &#123;&#125;</code> 之外，并在 <code>pipeline &#123;&#125;</code> 之内进行调用。如下，我定义了一个远程服务器的远程登录信息，方便我能把构建的包发布到远程服务器上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 创建函数</span><br><span class="line">def RemoteHost(Jarnname, Host, ProJect) &#123;</span><br><span class="line">    withCredentials([usernamePassword(credentialsId: &#x27;131&#x27;, passwordVariable: &#x27;PassWord&#x27;, usernameVariable: &#x27;UserName&#x27;)])&#123;</span><br><span class="line">        def remote = [:]</span><br><span class="line">        remote.name = &quot;$Jarnname&quot;</span><br><span class="line">        remote.host = &quot;$Host&quot;</span><br><span class="line">        remote.user = &quot;$UserName&quot;</span><br><span class="line">        remote.password = &quot;$PassWord&quot;</span><br><span class="line">        remote.port = 22</span><br><span class="line">        remote.allowAnyHosts = true</span><br><span class="line">        sshPut remote: remote, from: &quot;./target/$Jarnname&quot;, into: &quot;./$&#123;ProJect&#125;/&quot;, override: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 流水线步骤</span><br><span class="line">pipeline &#123;</span><br><span class="line">stages &#123;</span><br><span class="line">// 阶段 + 步骤</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、调用方法（函数）"><a href="#2、调用方法（函数）" class="headerlink" title="2、调用方法（函数）"></a>2、调用方法（函数）</h3><p>看下面代码块的<code>项目发布</code>阶段，在这里调用了上面定义的函数，并进行参数传递。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">// 创建函数</span><br><span class="line">def RemoteHost(Jarnname, Host, ProJect) &#123;</span><br><span class="line">    withCredentials([usernamePassword(credentialsId: &#x27;131&#x27;, passwordVariable: &#x27;PassWord&#x27;, usernameVariable: &#x27;UserName&#x27;)])&#123;</span><br><span class="line">        def remote = [:]</span><br><span class="line">        remote.name = &quot;$Jarnname&quot;</span><br><span class="line">        remote.host = &quot;$Host&quot;</span><br><span class="line">        remote.user = &quot;$UserName&quot;</span><br><span class="line">        remote.password = &quot;$PassWord&quot;</span><br><span class="line">        remote.port = 22</span><br><span class="line">        remote.allowAnyHosts = true</span><br><span class="line">        sshPut remote: remote, from: &quot;./target/$Jarnname&quot;, into: &quot;./$&#123;ProJect&#125;/&quot;, override: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 流水线步骤</span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        docker &#123;</span><br><span class="line">            image &#x27;maven:v2&#x27;</span><br><span class="line">            args &#x27;-v /var/lib/jenkins/workspace/$JOB_NAME:/root/.m2 -v /root/mavenRepository:/usr/repository&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">stages &#123;</span><br><span class="line">    // 拉取代码</span><br><span class="line">        stage(&#x27;拉取代码&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                checkout([$class: &#x27;GitSCM&#x27;,</span><br><span class="line">                    branches: [[name: &quot;$&#123;params.BRANCH_TAG&#125;&quot;]],</span><br><span class="line">                    doGenerateSubmoduleConfigurations: false,</span><br><span class="line">                    extensions: [],</span><br><span class="line">                    gitTool: &#x27;Default&#x27;,</span><br><span class="line">                    submoduleCfg: [],</span><br><span class="line">                    userRemoteConfigs: [[url: &#x27;https://codeup.aliyun.com/xx/java_code.git&#x27;,credentialsId: &#x27;yourid&#x27;,]]</span><br><span class="line">                ])</span><br><span class="line">        &#125;</span><br><span class="line">        // 项目构建</span><br><span class="line">        stage(&quot;构建项目&quot;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &quot;mvn clean package -Dmaven.test.skip=true -P test&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 项目发布（在这里调用方法）</span><br><span class="line">        stage (&quot;项目发布&quot;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script &#123;</span><br><span class="line">                    switch(&quot;$p_name&quot;)&#123;</span><br><span class="line">                        case &quot;cms&quot;:</span><br><span class="line">                            Jarnname = &quot;demo.jar&quot;</span><br><span class="line">                            Host = &quot;192.168.56.131&quot;</span><br><span class="line">                            ProJect = &quot;cms&quot;</span><br><span class="line">                            // 调用方法并传递参数</span><br><span class="line">                            RemoteHost(&quot;$&#123;Jarnname&#125;&quot;, &quot;$&#123;Host&#125;&quot;, &quot;$&#123;ProJect&#125;&quot;)</span><br><span class="line">                        break</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，我们就不用每次都写一遍定义的方法内容了，只需调用其函数名即可。</p><p><mark>注意：</mark>上面只是我 Jenkinsfile 的一部分！</p><p>至此，Jenkins Pipeline 方法定义及调用已经完成。</p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CICD </tag>
            
            <tag> Jenkins_Pipeline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins Pipeline 配置钉钉消息通知</title>
      <link href="/posts/articles/7ede8fbb.html"/>
      <url>/posts/articles/7ede8fbb.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/2d697c8b26a7d91dc044f623e7f80f4a.jpeg" alt="2d697c8b26a7d91dc044f623e7f80f4a"></p><p><font color="Brown"><strong>Author</strong>：rab</font> <font color="Brown"><strong>Date</strong>：2022&#x2F;07&#x2F;08</font> <font color="Brown"><strong>Blog</strong>：<a href="https://blog.csdn.net/IT_ZRS?type=blog"><font color="Brown">https://blog.csdn.net/IT_ZRS?type&#x3D;blog</font></a></font></p><p><strong>Jenkins 版本</strong>：2.341</p><hr><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>有这样一个需求，在编写 Jenkinsfile 脚本中，需配置钉钉告警功能，里面涉及到的相关告警信息中，需包含构建人，即哪个该项目是由哪个人进行构建的，构建成功后相关的构建信息会以钉钉消息的形式通知。</p><p>功能实现：</p><ul><li>构建编号；</li><li>构建列表；</li><li>构建分支；</li><li>构建环境；</li><li>构建状态；</li><li>项目地址；</li><li>构建日志；</li><li>构建后启动状态；</li><li>执行人；</li><li>构建持续时间。</li></ul><h2 id="一、安装插件"><a href="#一、安装插件" class="headerlink" title="一、安装插件"></a>一、安装插件</h2><h3 id="1-1-build-user-vars-plugin"><a href="#1-1-build-user-vars-plugin" class="headerlink" title="1.1 build user vars plugin"></a>1.1 build user vars plugin</h3><p>如果需要获取项目构建的人信息，需要安装 <code>build user vars plugin</code> 插件，否在获取变量值的时为 <code>Null</code>，下图我已经安装了，大家在搜索框搜索安装即可。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/plugin.png" alt="plugin"></p><h3 id="1-2-Ding-Talk"><a href="#1-2-Ding-Talk" class="headerlink" title="1.2 Ding Talk"></a>1.2 Ding Talk</h3><p>这里还需要安装钉钉插件 <code>Ding Talk</code>，这后面会在 <code>Jenkins 系统配置</code>中进行相关配置。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220708101206429.png" alt="image-20220708101206429"></p><h2 id="二、配置钉钉告警"><a href="#二、配置钉钉告警" class="headerlink" title="二、配置钉钉告警"></a>二、配置钉钉告警</h2><h3 id="2-1-钉钉添加机器人"><a href="#2-1-钉钉添加机器人" class="headerlink" title="2.1 钉钉添加机器人"></a>2.1 钉钉添加机器人</h3><p><strong>1、进入你对应的相关群聊</strong></p><blockquote><p>点击右上角的设置图标；</p><p>下图是我已经配置过钉钉了。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220708102604257.png" alt="image-20220708102604257"></p><p><strong>2、点击<code>智能群助手</code></strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220708102736255.png" alt="image-20220708102736255"></p><p><strong>3、点击<code>添加机器人</code></strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220708103008728.png" alt="image-20220708103008728"></p><p>这时会跳到这个页面：继续点击<code>添加机器人</code></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220708103218129.png" alt="image-20220708103218129"></p><p><strong>4、选择<code>自定义</code></strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220708103341118.png" alt="image-20220708103341118"></p><p><strong>5、完成相关填写即可</strong></p><blockquote><p>不清楚的可以点击图片上的<code>说明问文档</code></p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220708103446648.png" alt="image-20220708103446648"></p><p>此时会生成 <code>webhook</code> 口令！你也可以点击对应的机器人获取：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220708103943044.png" alt="image-20220708103943044"></p><h3 id="2-2-Jenkins-系统配置"><a href="#2-2-Jenkins-系统配置" class="headerlink" title="2.2 Jenkins 系统配置"></a>2.2 Jenkins 系统配置</h3><p><strong>1、进入系统配置</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220708102301654.png" alt="image-20220708102301654"></p><p><strong>2、找到钉钉模块</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220708102207159.png" alt="image-20220708102207159"></p><h2 id="三、编写-Jenkinsfile"><a href="#三、编写-Jenkinsfile" class="headerlink" title="三、编写 Jenkinsfile"></a>三、编写 Jenkinsfile</h2><p>以上配置均完成后，接下来就是在 <code>jenkinsfile</code> 中配置了。</p><p>构建后通知配置于 <code>pipeline &#123;&#125;</code> 中，与 <code>stages &#123;&#125;</code> 同级，下面是具体的模板信息，这里我只设置了<code>成功</code>、<code>失败</code>两种情况，当然还有其他情况，大家根据实际情况配置即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">stages &#123;</span><br><span class="line">// 流水线阶段/步骤</span><br><span class="line">&#125;</span><br><span class="line">    post &#123;</span><br><span class="line">        success &#123;</span><br><span class="line">            wrap([$class: &#x27;BuildUser&#x27;]) &#123;</span><br><span class="line">                dingtalk(</span><br><span class="line">                    robot: &#x27;Jenkins-Dingtalk&#x27;,</span><br><span class="line">                    type: &#x27;MARKDOWN&#x27;,</span><br><span class="line">                    title: &quot;success: $&#123;JOB&#125;&quot;,</span><br><span class="line">                    text: [&quot;### 项目信息&quot;,</span><br><span class="line">                        &#x27;---&#x27;,</span><br><span class="line">                        &quot;- 项目主体: CheckCheck&quot;,</span><br><span class="line">                        &quot;- 子项目: 斗地主&quot;,</span><br><span class="line">                        &quot;![ddz](https://xxx.com/img/puk.jpeg)&quot;,</span><br><span class="line">                        &quot;&quot;,</span><br><span class="line">                        &#x27;---&#x27;,</span><br><span class="line">                        &quot;### 构建信息&quot;,</span><br><span class="line">                        &#x27;---&#x27;,</span><br><span class="line">                        &quot;- 构建编号: &lt;font color=#008000&gt;$&#123;BUILD_ID&#125;&lt;/font&gt;&quot;,</span><br><span class="line">                        &quot;- 构建列表: $&#123;JOB&#125;&quot;,</span><br><span class="line">                        &quot;- 构建分支: $&#123;BRANCH_TAG&#125;&quot;,</span><br><span class="line">                        &quot;- 构建环境: $&#123;ENV&#125;&quot;,</span><br><span class="line">                        &quot;- 构建状态: **&lt;font color=#008000&gt;$&#123;currentBuild.result&#125;&lt;/font&gt;**&quot;,</span><br><span class="line">                        &quot;- 项目地址: $&#123;BUILD_URL&#125;&quot;,</span><br><span class="line">                        &quot;- 构建日志: $&#123;BUILD_URL&#125;console&quot;,</span><br><span class="line">                        &quot;&quot;,</span><br><span class="line">                        &#x27;---&#x27;,</span><br><span class="line">                        &quot;### 是否启动&quot;,</span><br><span class="line">                        &#x27;---&#x27;,</span><br><span class="line">                        &quot;- 构建后启动: $&#123;START&#125;&quot;,</span><br><span class="line">                        &quot;&quot;,</span><br><span class="line">                        &#x27;---&#x27;,</span><br><span class="line">                        &quot;### 执行人&quot;,</span><br><span class="line">                        &#x27;---&#x27;,</span><br><span class="line">                        &quot;- $&#123;env.BUILD_USER&#125;&quot;,</span><br><span class="line">                        &quot;&quot;,</span><br><span class="line">                        &#x27;---&#x27;,</span><br><span class="line">                        &quot;### 持续时间&quot;,</span><br><span class="line">                        &#x27;---&#x27;,</span><br><span class="line">                        &quot;- $&#123;currentBuild.durationString&#125;&quot;,</span><br><span class="line">                        &quot;&quot;,</span><br><span class="line">                        &#x27;---&#x27;]</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        failure &#123;</span><br><span class="line">            wrap([$class: &#x27;BuildUser&#x27;]) &#123;</span><br><span class="line">                dingtalk(</span><br><span class="line">                    robot: &#x27;Jenkins-Dingtalk&#x27;,</span><br><span class="line">                    type: &#x27;MARKDOWN&#x27;,</span><br><span class="line">                    title: &quot;failure: $&#123;JOB&#125;&quot;,</span><br><span class="line">                    text: [&quot;### 项目信息&quot;,</span><br><span class="line">                        &#x27;---&#x27;,</span><br><span class="line">                        &quot;- 项目主体: CheckCheck&quot;,</span><br><span class="line">                        &quot;- 子项目: 斗地主&quot;,</span><br><span class="line">                        &quot;![ddz](https://xxx.com/img/puk.jpeg)&quot;,</span><br><span class="line">                        &quot;&quot;,</span><br><span class="line">                        &#x27;---&#x27;,</span><br><span class="line">                        &quot;### 构建信息&quot;,</span><br><span class="line">                        &#x27;---&#x27;,</span><br><span class="line">                        &quot;- 构建编号: &lt;font color=#dd3238&gt;$&#123;BUILD_ID&#125;&lt;/font&gt;&quot;,</span><br><span class="line">                        &quot;- 构建列表: $&#123;JOB&#125;&quot;,</span><br><span class="line">                        &quot;- 构建分支: $&#123;BRANCH_TAG&#125;&quot;,</span><br><span class="line">                        &quot;- 构建环境: $&#123;ENV&#125;&quot;,</span><br><span class="line">                        &quot;- 构建状态: **&lt;font color=#dd3238&gt;$&#123;currentBuild.result&#125;&lt;/font&gt;**&quot;,</span><br><span class="line">                        &quot;- 项目地址: $&#123;BUILD_URL&#125;&quot;,</span><br><span class="line">                        &quot;- 构建日志: $&#123;BUILD_URL&#125;console&quot;,</span><br><span class="line">                        &quot;&quot;,</span><br><span class="line">                        &#x27;---&#x27;,</span><br><span class="line">                        &quot;### 是否启动&quot;,</span><br><span class="line">                        &#x27;---&#x27;,</span><br><span class="line">                        &quot;- 构建后启动: $&#123;START&#125;&quot;,</span><br><span class="line">                        &quot;&quot;,</span><br><span class="line">                        &#x27;---&#x27;,</span><br><span class="line">                        &quot;### 执行人&quot;,</span><br><span class="line">                        &#x27;---&#x27;,</span><br><span class="line">                        &quot;- $&#123;env.BUILD_USER&#125;&quot;,</span><br><span class="line">                        &quot;&quot;,</span><br><span class="line">                        &#x27;---&#x27;,</span><br><span class="line">                        &quot;### 持续时间&quot;,</span><br><span class="line">                        &#x27;---&#x27;,</span><br><span class="line">                        &quot;- $&#123;currentBuild.durationString&#125;&quot;,</span><br><span class="line">                        &quot;&quot;,</span><br><span class="line">                        &#x27;---&#x27;]</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编写 <code>jenkinsfile</code> 需注意的几个问题：</p><ul><li>变量：需确保你定义的变量有效；</li><li>钉钉配置：robot: ‘Jenkins-Dingtalk’  这个值必须为 <code>2.2 小结</code> 中系统配置定义的机器人 ID，因为钉钉的 webhook 是配置在 Jenkins 系统上的，否则你的 jenkinsfile 是无法连接或找到钉钉的。</li></ul><h2 id="四、钉钉告警验证"><a href="#四、钉钉告警验证" class="headerlink" title="四、钉钉告警验证"></a>四、钉钉告警验证</h2><p>配完成后，就可以进行构建操作，不管成功或失败，都会接收到告警信息。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220708105131153.png" alt="image-20220708105131153"></p><p><mark>至此，Jenkins pipeline 配置钉钉消息通知已经完成！</mark></p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CICD </tag>
            
            <tag> Jenkins_Pipeline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins 实现 Gitlab API 调用及共享库应用</title>
      <link href="/posts/articles/c2464361.html"/>
      <url>/posts/articles/c2464361.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/original.webp" alt="original"></p><p><font color="Brown"><strong>Author</strong>：rab</font><br><strong>Gitlab 版本</strong>：15.1.2<br><strong>Jenkins 版本</strong>：2.332.3</p><p><a href="https://www.jenkins.io/doc/">Jenkins 官方文档</a><br><a href="https://docs.gitlab.com/">Gitlab 官方文档</a></p><hr><p>我们可通过 <code>Branches API</code> 接口来创建分支，先进行接口调试，调试完成后以 Jenkins Pipeline 的方式执行，并最终通过进一步优化实现 Jenkins 共享库构建效果。</p><h2 id="一、Branches-API"><a href="#一、Branches-API" class="headerlink" title="一、Branches API"></a>一、Branches API</h2><h3 id="1-1-获取接口地址"><a href="#1-1-获取接口地址" class="headerlink" title="1.1 获取接口地址"></a>1.1 获取接口地址</h3><p>此时，就可以根据官方接口文档，获取如下创建分支的接口地址。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220720212457723.png" alt="image-20220720212457723"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --request POST --header &quot;PRIVATE-TOKEN: &lt;your_access_token&gt;&quot; &quot;https://gitlab.example.com/api/v4/projects/5/repository/branches?branch=newbranch&amp;ref=main&quot;</span><br></pre></td></tr></table></figure><h3 id="1-2-创建-Token"><a href="#1-2-创建-Token" class="headerlink" title="1.2 创建 Token"></a>1.2 创建 Token</h3><p>然后在 Gitlab 上创建 Token，操作步骤如下图：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220720210637927.png" alt="image-20220720210637927"></p><blockquote><p>创建完成后会生成一个 Token，复制到接口地址</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220720211017865.png" alt="image-20220720211017865"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl --request POST --header &quot;PRIVATE-TOKEN: DxVUpBnVmg4NUNfBdyxx&quot; &quot;https://192.168.56.133/api/v4/projects/5/repository/branches?branch=newbranch&amp;ref=main&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个toke与上图不符，是因为上图的toke被我删了，然后这是我重新创建的token</span></span><br></pre></td></tr></table></figure><ul><li>接口地址中 <code>/projects/5</code> 就是 Gitlab 的项目 ID，如果你要对下图项目做相关操作，应修改为 <code>/projects/3</code>；</li><li>newbranch 表示你要创建的分支名称（自定义）；</li><li>main 表示你以哪个分支为基础来创建新分支。</li></ul><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220720211901227.png" alt="image-20220720211901227"></p><p>所以最终地址为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl --request POST --header &quot;PRIVATE-TOKEN: DxVUpBnVmg4NUNfBdyxx&quot; &quot;https://192.168.56.133/api/v4/projects/3/repository/branches?branch=rab_test&amp;ref=main&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我定义了一个名为rab_test的新分支，且以main分支为基础进行创建</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果你的Gitlab没有开启443认证，那需要把https---&gt;http</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl --request POST --header <span class="string">&quot;PRIVATE-TOKEN: DxVUpBnVmg4NUNfBdyxx&quot;</span> <span class="string">&quot;http://192.168.56.133/api/v4/projects/3/repository/branches?branch=rab_test&amp;ref=main&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="1-3-接口调试"><a href="#1-3-接口调试" class="headerlink" title="1.3 接口调试"></a>1.3 接口调试</h3><h4 id="1-3-1-shell-终端调试"><a href="#1-3-1-shell-终端调试" class="headerlink" title="1.3.1 shell 终端调试"></a>1.3.1 shell 终端调试</h4><p>此时，你在任意 <code>shell 终端</code>进行调试，最终看是否生成预期分支，这里我就在 <code>Jenkins</code> 服务器上执行上述接口地址。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220720213450615.png" alt="image-20220720213450615"></p><p>看样子是没什么问题，然后到 Gitlab 上看看有没有创建指定的分支。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220720213716467.png" alt="image-20220720213716467"></p><p>看到上图结果，完全是没问题的，说明调试已经调通了。</p><h4 id="1-3-2-Postman-调试"><a href="#1-3-2-Postman-调试" class="headerlink" title="1.3.2 Postman 调试"></a>1.3.2 Postman 调试</h4><p>1、新建 POST 请求</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220720215246034.png" alt="image-20220720215246034"></p><p>2、请求头添加 Token 信息（k-v）</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220720215715183.png" alt="image-20220720215715183"></p><p>3、配置好后点击 Send</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220720220019813.png" alt="image-20220720220019813"></p><p>4、Gitlab 查看结果</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220720215923496.png" alt="image-20220720215923496"></p><p>也是能够成功构建的。</p><p>postman 有一个好处就是，可以根据你的接口地址生成对应的语言片段，入下图，生成 cURL 格式的片段：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220721074130645.png" alt="image-20220721074130645"></p><p>当然，它还支持其他语言片段，如 python、Java等</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220721074618259.png" alt="image-20220721074618259"></p><h3 id="1-4-Pipeline-实现"><a href="#1-4-Pipeline-实现" class="headerlink" title="1.4 Pipeline 实现"></a>1.4 Pipeline 实现</h3><p>以上接口都调通后，接下来就可以通过 Jenkins 流水线来实现了，写一个简单的案例，创建分支<code>rab_test-2</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">agent any</span><br><span class="line">stages &#123;</span><br><span class="line">stage(&quot;create branch&quot;)&#123;</span><br><span class="line">steps&#123;</span><br><span class="line">// 复制刚刚postman调通的接口地址</span><br><span class="line">sh &quot;&quot;&quot;</span><br><span class="line">curl --location --request POST \</span><br><span class="line">&quot;http://192.168.56.133/api/v4/projects/3/repository/branches?branch=rab_test-2&amp;ref=main&quot; \</span><br><span class="line">--header &quot;PRIVATE-TOKEN: DxVUpBnVmg4NUNfBdyxx&quot;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行 Jenkins 构建操作，如图构建成功。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220720221858742.png" alt="image-20220720221858742"></p><p>接下来去 Gitlab 上看看是否生成新的分支。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220720222025108.png" alt="image-20220720222025108"></p><p>完全没问题，由于我的分支在 Pipeline 脚本中写死了，后面你可以自己优化一下，比如传递一些参数进行动态创建。</p><h2 id="二、优化-Pipeline"><a href="#二、优化-Pipeline" class="headerlink" title="二、优化 Pipeline"></a>二、优化 Pipeline</h2><p>你会发现，上面的 Pipeline 脚本的接口都是写死的，也就是说如果你想修改相关参数值的话，需要进入脚本中修改，比较麻烦，因此我们再次进行优化。</p><h3 id="2-1-参数化构建"><a href="#2-1-参数化构建" class="headerlink" title="2.1 参数化构建"></a>2.1 参数化构建</h3><p>实现功能：使用者可以灵活自定义新分支名、基础分支，而不需要再次进入修改 Pipeline 脚本，只需要传递参数即可值。</p><p>1、配置参数化配置</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220722160509602.png" alt="image-20220722160509602"></p><p>最终效果如下图：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220722161159292.png" alt="image-20220722161159292"></p><p>2、修改 Pipeline 脚本</p><p>上述参数定义好后，接下来就需要把参数名写进 Pipeline 脚本对应位置，实现参数传递。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">agent any</span><br><span class="line">stages &#123;</span><br><span class="line">stage(&quot;create branch&quot;)&#123;</span><br><span class="line">steps&#123;</span><br><span class="line">// 复制刚刚postman调通的接口地址</span><br><span class="line">sh &quot;&quot;&quot;</span><br><span class="line">curl --location --request POST \</span><br><span class="line">&quot;http://192.168.56.133/api/v4/projects/3/repository/branches?branch=$&#123;env.NewBranchName&#125;&amp;ref=$&#123;env.BaseBranchName&#125;&quot; \</span><br><span class="line">--header &quot;PRIVATE-TOKEN: DxVUpBnVmg4NUNfBdyxx&quot;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、构建验证</p><ul><li><p>Jenkins 构建</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220722163726215.png" alt="image-20220722163726215"></p></li><li><p>Gitlab 查看是否创建成功</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220722163829870.png" alt="image-20220722163829870"></p></li></ul><h3 id="2-2-Token-加密"><a href="#2-2-Token-加密" class="headerlink" title="2.2 Token 加密"></a>2.2 Token 加密</h3><p>上面的 Token 是以明文形式传输传输的，并不安全，我们需要用到凭证方式来代替明文方式。</p><p>1、在安全设置中找到管理凭据</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220722164231089.png" alt="image-20220722164231089"></p><p>2、具体配置</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220722164704419.png" alt="image-20220722164704419"></p><p>3、通过 Jenkins 自带的<code>片段生成器</code>来生成相关片段语句</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220722165500385.png" alt="image-20220722165500385"></p><p>4、修改 Pipeline 脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">agent any</span><br><span class="line">stages &#123;</span><br><span class="line">stage(&quot;Create Branch&quot;)&#123;</span><br><span class="line">steps&#123;</span><br><span class="line">script&#123;</span><br><span class="line">withCredentials([string(credentialsId: &#x27;gitlab-create-branch&#x27;, variable: &#x27;Gitlab_Token&#x27;)]) &#123;</span><br><span class="line">// 创建分支</span><br><span class="line">sh &quot;&quot;&quot;</span><br><span class="line">curl --location --request POST \</span><br><span class="line">&quot;http://192.168.56.133/api/v4/projects/3/repository/branches?branch=$&#123;env.NewBranchName&#125;&amp;ref=$&#123;env.BaseBranchName&#125;&quot; \</span><br><span class="line">--header &quot;PRIVATE-TOKEN: $&#123;Gitlab_Token&#125;&quot;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、构建验证</p><ul><li><p>Jenkins 构建</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220722170212203.png" alt="image-20220722170212203"></p></li><li><p>Gitlab 查看是否创建成功</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220722170244315.png" alt="image-20220722170244315"></p></li></ul><h3 id="2-3-定义函数（方法）"><a href="#2-3-定义函数（方法）" class="headerlink" title="2.3 定义函数（方法）"></a>2.3 定义函数（方法）</h3><p>函数的作用在于更加灵活的传递参数、减少书写代码量。</p><p>1、定义函数</p><blockquote><p>注意：函数体的参数名要和定义函数中的参数保持一致</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 创建分支</span><br><span class="line">def CreateBranch(ProjectID, NewBranchName, BaseBranchName) &#123;</span><br><span class="line">withCredentials([string(credentialsId: &#x27;gitlab-create-branch&#x27;, variable: &#x27;Gitlab_Token&#x27;)]) &#123;</span><br><span class="line">sh &quot;&quot;&quot;</span><br><span class="line">curl --location --request POST \</span><br><span class="line">&quot;http://192.168.56.133/api/v4/projects/$&#123;ProjectID&#125;/repository/branches?branch=$&#123;NewBranchName&#125;&amp;ref=$&#123;BaseBranchName&#125;&quot; \</span><br><span class="line">--header &quot;PRIVATE-TOKEN: $&#123;Gitlab_Token&#125;&quot;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 流水线（主）</span><br><span class="line">pipeline &#123;</span><br><span class="line">agent any</span><br><span class="line">stages &#123;</span><br><span class="line">stage(&quot;Create Branch&quot;) &#123;</span><br><span class="line">steps &#123;</span><br><span class="line">script &#123;</span><br><span class="line">ProjectID = 3</span><br><span class="line">// 调用函数时，如果定义的参数类型为字符串时需夹双引号，为数字时则不需要</span><br><span class="line">CreateBranch(ProjectID, &quot;$&#123;env.NewBranchName&#125;&quot;, &quot;$&#123;BaseBranchName&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、构建验证</p><ul><li><p>Jenkins 构建</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220722171720258.png" alt="image-20220722171720258"></p></li><li><p>Gitlab 查看是否创建成功</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220722171903832.png" alt="image-20220722171903832"></p></li></ul><p>到这里，Gitlab 的工程 ID 还是被写死的，因此我们需要通过 Gitlab 的项目名动态获取 Gitlab 项目对应的 ID 值，这也需要调用 Gitlab 的相关接口，如下图。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220722174810022.png" alt="image-20220722174810022"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl --header &quot;PRIVATE-TOKEN: &lt;your_access_token&gt;&quot; &quot;https://gitlab.example.com/api/v4/projects?search=test&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">PRIVATE-TOKEN：Token值</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">test</span>：表示你要填入的项目名称</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改一下</span></span><br><span class="line">curl --header &quot;PRIVATE-TOKEN: DxVUpBnVmg4NUNfBdyxx&quot; &quot;http://192.168.56.133/api/v4/projects?search=Tq&quot;</span><br></pre></td></tr></table></figure><blockquote><p>现在命令行测试一下，看看该接口返回的结果；</p><p>可看到，已经返回了 Gitlab 中 Tq 项目的 id 值了，说明该接口可用。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220722175431433.png" alt="image-20220722175431433"></p><blockquote><p>Postman 上更直观一点</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220722180306186.png" alt="image-20220722180306186"></p><p>3、再次优化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 请求地址</span><br><span class="line">def HttpReq(ApiUrl, Method) &#123;</span><br><span class="line">GitlabAPI = &quot;http://192.168.56.133/api/v4&quot;</span><br><span class="line">withCredentials([string(credentialsId: &#x27;gitlab-create-branch&#x27;, variable: &#x27;Gitlab_Token&#x27;)]) &#123;</span><br><span class="line">response = sh returnStdout: true, script: &quot;&quot;&quot;</span><br><span class="line">curl --location --request $&#123;Method&#125; \</span><br><span class="line">&quot;$&#123;GitlabAPI&#125;/$&#123;ApiUrl&#125;&quot; \</span><br><span class="line">--header &quot;PRIVATE-TOKEN: $&#123;Gitlab_Token&#125;&quot;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">return response</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建分支</span><br><span class="line">def CreateBranch(ProjectID, NewBranchName, BaseBranchName) &#123;</span><br><span class="line">ApiUrl = &quot;projects/$&#123;ProjectID&#125;/repository/branches?branch=$&#123;NewBranchName&#125;&amp;ref=$&#123;BaseBranchName&#125;&quot;</span><br><span class="line">Method = &quot;POST&quot;</span><br><span class="line">HttpReq(ApiUrl, Method)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取项目ID</span><br><span class="line">def GetProjectID(ProjectName) &#123;</span><br><span class="line">ApiUrl = &quot;projects?search=$&#123;ProjectName&#125;&quot;</span><br><span class="line">Method = &quot;GET&quot;</span><br><span class="line">result = HttpReq(ApiUrl, Method)</span><br><span class="line">result = readJSON text: result</span><br><span class="line">return result[0][&quot;id&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 流水线（主）</span><br><span class="line">pipeline &#123;</span><br><span class="line">agent any</span><br><span class="line">stages &#123;</span><br><span class="line">stage(&quot;Create Branch&quot;) &#123;</span><br><span class="line">steps &#123;</span><br><span class="line">script &#123;</span><br><span class="line">ProjectID = GetProjectID(&quot;$&#123;ProjectName&#125;&quot;)</span><br><span class="line">CreateBranch(ProjectID, &quot;$&#123;env.NewBranchName&#125;&quot;, &quot;$&#123;BaseBranchName&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>进行构建</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723141300754.png" alt="image-20220723141300754"></p></li><li><p>Gitlab 上查看是否生成</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723145203412.png" alt="image-20220723145203412"></p></li></ul><p>=&#x3D;注意：如果你使用了 <code>readJSON</code> JSON 解析，那你需要安装如下插件，否则报错。&#x3D;&#x3D;</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723144954347.png" alt="image-20220723144954347"></p><p>&#x3D;&#x3D;错误现象：提示没有 readJDSON 这个方法，这种报错类型一般是缺少插件导致的，安装对应插件即可。&#x3D;&#x3D;</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723145457812.png" alt="image-20220723145457812"></p><h2 id="三、共享库"><a href="#三、共享库" class="headerlink" title="三、共享库"></a>三、共享库</h2><p>上面已经做了相关优化了，但是在生产环境中的代码量远比上面多，而且定义的函数也会越来越多，因此，我们就需要使用 Jenkins 的共享库，共享库的作用是将具备同样性质或很少改动的函数（方法）归档于 Git 仓库管理，并在 Jenkinsfile 中调用（引用）的手段，这将大大减少 Pipeline 代码量。</p><h3 id="3-1-创建共享库"><a href="#3-1-创建共享库" class="headerlink" title="3.1 创建共享库"></a>3.1 创建共享库</h3><p>1、创建项目仓库</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723150155668.png" alt="image-20220723150155668"></p><p>2、添加目录&#x2F;文件</p><ul><li>点击 <code>Web IDE</code></li></ul><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723151049250.png" alt="image-20220723151049250"></p><ul><li><p>创建目录</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723150944708.png" alt="image-20220723150944708"></p></li><li><p>添加文件</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723152123651.png"></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723152250816.png" alt="image-20220723152250816"></p></li></ul><p>3、将定义好的方法提交到代码仓库</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723152849499.png" alt="image-20220723152849499"></p><h3 id="3-2-加载共享库"><a href="#3-2-加载共享库" class="headerlink" title="3.2 加载共享库"></a>3.2 加载共享库</h3><p>1、流水线脚本加载共享库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 加载共享库，其中jenkinslib要与Jenkins系统配置中保持一致（jenkinslib可自定义），@amin表示共享库所在分支</span><br><span class="line">@Library(&quot;jenkinslib@main&quot;) _</span><br><span class="line">// 导入jenkinsfile.groovy。这里要注意：下面的jenkinsfile()名字必须与你共享库中jenkinsfile.groovy名一致，否则报错</span><br><span class="line">def myjenkinsfile = new org.devops.jenkinsfile()</span><br><span class="line"></span><br><span class="line">// 流水线（主）</span><br><span class="line">pipeline &#123;</span><br><span class="line">agent any</span><br><span class="line">tools &#123;</span><br><span class="line">git &#x27;git&#x27;</span><br><span class="line">&#125;</span><br><span class="line">stages &#123;</span><br><span class="line">stage(&quot;Create Branch&quot;) &#123;</span><br><span class="line">steps &#123;</span><br><span class="line">script &#123;</span><br><span class="line">// 然后就可以调用共享库中的方法了 myjenkinsfile 即为我上面引用的方法（可在上面自定义）</span><br><span class="line">ProjectID = myjenkinsfile.GetProjectID(&quot;$&#123;env.ProjectName&#125;&quot;)</span><br><span class="line">myjenkinsfile.CreateBranch(ProjectID, &quot;$&#123;env.NewBranchName&#125;&quot;, &quot;$&#123;env.BaseBranchName&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、同样将流水线脚本也进行 Git 版本管理</p><blockquote><p>这样的话便于管理 Jenkinfile 及共享库</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723153913871.png" alt="image-20220723153913871"></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723162121271.png" alt="image-20220723162121271"></p><h3 id="3-3-Jenkins-配置"><a href="#3-3-Jenkins-配置" class="headerlink" title="3.3 Jenkins 配置"></a>3.3 Jenkins 配置</h3><p>1、Jenkins 流水线配置</p><p>因为我们的流水线脚本进行了 Git 版本管理，所以你可以在 Jenkins 流水线配置中配置 URL 即可。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723155806926.png" alt="image-20220723155806926"></p><p>2、Jenkins 系统配置</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723161609360.png" alt="image-20220723161609360"></p><h3 id="3-4-Jenkins-构建"><a href="#3-4-Jenkins-构建" class="headerlink" title="3.4 Jenkins 构建"></a>3.4 Jenkins 构建</h3><p>以上都配置好之后，接下来就开始构建了。</p><p>1、Jenkins 构建</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723190934794.png" alt="image-20220723190934794"></p><p>2、Gitlab 查看是否构建成功</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723190856525.png" alt="image-20220723190856525"></p><p><mark>至此，已实现 Jenkins 如何调用 Gitlab API 及 Jenkins 共享库的最终应用。</mark></p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CICD </tag>
            
            <tag> Jenkins_Pipeline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins Pipeline 密钥远程部署</title>
      <link href="/posts/articles/7e46479a.html"/>
      <url>/posts/articles/7e46479a.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/pipeline.png" alt="pipeline"></p><p><strong>Jenkins 版本</strong>：Jenkins 2.341</p><hr><h2 id="一、配置流程"><a href="#一、配置流程" class="headerlink" title="一、配置流程"></a>一、配置流程</h2><h3 id="1-1-片段生成"><a href="#1-1-片段生成" class="headerlink" title="1.1 片段生成"></a>1.1 片段生成</h3><p>1、按如下图选择</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220719122921121.png" alt="image-20220719122921121"></p><p>2、新增密钥信息</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220719133057946.png" alt="image-20220719133057946"></p><h3 id="1-2-脚本配置"><a href="#1-2-脚本配置" class="headerlink" title="1.2 脚本配置"></a>1.2 脚本配置</h3><p>以上配置完成后，接下来就可以在 Jenkinsfile 中配置了，具体配置如下图：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220719064524167.png" alt="image-20220719064524167"></p><p>:warning:注意：使用密钥形式的推送方式，<code>sshPut</code>、<code>sshCommand</code> 等相关命令必须放到 <code>remote.*</code> 下，否则报如下错误：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220718221941424.png" alt="image-20220718221941424"></p><p>与 <code>withCredentials.usernamePassword</code> 方式不同的是，<code>withCredentials.usernamePassword</code> 则可以紧跟 <code>remote.*</code> ，也可以不紧跟，具体如下：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220719071358730.png" alt="image-20220719071358730"></p><h2 id="二、小结"><a href="#二、小结" class="headerlink" title="二、小结"></a>二、小结</h2><p>为了服务器账户安全，jenkins 远程部署时可使用<code>withCredentials()</code> 方法来实现密码加密，常用的有<code>用户名/密码</code>方式、<code>SSH 用户密钥对</code> 方式来实现，当然还有其他方式，图下图所示：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220719133812902.png" alt="image-20220719133812902"></p><p>但要注意的一点是，<code>用户名/密码</code>方式和<code>SSH 用户密钥对</code> 方式在 Jenkinsfile 脚本结构上有一点小区别：</p><ul><li><p><code>SSH 用户密钥对</code> 方式：<code>sshPut</code>、<code>sshCommand</code> 等相关命令必须紧跟 <code>remote.*</code></p></li><li><p><code>用户名/密码</code>方式：<code>sshPut</code>、<code>sshCommand</code> 等相关命令可以紧跟 <code>remote.*</code>，也可以不紧跟。</p></li></ul><p><mark>至此，Jenkins Pipeline 密钥远程部署已经配置完成！</mark></p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CICD </tag>
            
            <tag> Jenkins_Pipeline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins 用户权限管理</title>
      <link href="/posts/articles/bc241c84.html"/>
      <url>/posts/articles/bc241c84.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/2d697c8b26a7d91dc044f623e7f80f4a.jpeg" alt="2d697c8b26a7d91dc044f623e7f80f4a"></p><p><font color="Brown"><strong>Author</strong>：rab</font> <font color="Brown"><strong>Date</strong>：2022&#x2F;07&#x2F;05</font> <font color="Brown"><strong>Blog</strong>：<a href="https://blog.csdn.net/IT_ZRS?type=blog"><font color="Brown">https://blog.csdn.net/IT_ZRS?type&#x3D;blog</font></a></font></p><p><strong>Jenkins 版本</strong>：2.332.3</p><hr><h2 id="一、安装插件"><a href="#一、安装插件" class="headerlink" title="一、安装插件"></a>一、安装插件</h2><h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><blockquote><p>在 Jenkins 的管理插件中进行插件安装</p><p>输入 Role 即可找到，如下图我已经安装过了。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220706113750812.png" alt="image-20220706113750812"></p><h3 id="1-2-配置"><a href="#1-2-配置" class="headerlink" title="1.2 配置"></a>1.2 配置</h3><blockquote><p>点击 Configure Global Security 进入配置</p></blockquote><p><strong>1、在 Jenkins 设置中找到如下图标</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220706114033184.png" alt="image-20220706114033184"></p><p><strong>2、选择刚安装的插件来作为我的用户权限</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220706114334669.png" alt="image-20220706114334669"></p><h2 id="二、创建角色"><a href="#二、创建角色" class="headerlink" title="二、创建角色"></a>二、创建角色</h2><h3 id="2-1-插件功能"><a href="#2-1-插件功能" class="headerlink" title="2.1 插件功能"></a>2.1 插件功能</h3><p>在 Jenkins 设置下找到 <code>Manage and Assign Roles</code> 并点击进入</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220706114829442.png" alt="image-20220706114829442"></p><p>主要功能：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220706115131927.png" alt="image-20220706115131927"></p><h3 id="2-2-角色管理"><a href="#2-2-角色管理" class="headerlink" title="2.2 角色管理"></a>2.2 角色管理</h3><p><strong>1、点击上图 <code>Manage Roles</code> 进入角色管理</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220706115702953.png" alt="image-20220706115702953"></p><p><strong>2、创建全局角色</strong></p><p>创建一个名为 base 的全局角色，该角色可作为所有用户的基本权限，也就是所有普通用户都具备的基本权限，并赋予角色 <code>Overall 下的 Read</code> 权限。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220706120353287.png" alt="image-20220706120353287"><strong>3、创建项目角色</strong></p><p>创建一个名为 shop 的项目角色，Pattern 为过滤或匹配正则表达项，<code>cms.*</code> 表示以 cms 开头的项目都会被匹配到，设置完之后，为该项目角色赋予对应的权限。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220706121102934.png" alt="image-20220706121102934"></p><p>Pattern 可以匹配作业（job）、代理（agents）、文件夹（folders）等项目关键字及类型。</p><p>格式为：<code>jobs, agents, folders, etc</code>    如有多个的话，用英文状态下的逗号”,”分开即可。</p><p><strong>4、创建节点角色</strong></p><p>节点角色主要是用于主从 Jenkins 部署时，进行节点权限配置。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220706121946074.png" alt="image-20220706121946074"></p><h3 id="2-3-角色分配"><a href="#2-3-角色分配" class="headerlink" title="2.3 角色分配"></a>2.3 角色分配</h3><p><strong>1、创建用户</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220706122231874.png" alt="image-20220706122231874"></p><p><strong>2、点击 <code>Assign Roles</code> 为用户分配权限</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220706122541034.png" alt="image-20220706122541034"></p><p>按照上面配置的项目角色权限，ops 用户只能匹配到以 cms 开头的项目，其他项目他是无法看到的，接下来进行验证。</p><p><strong>3、ops 用户登录验证</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220706122943398.png" alt="image-20220706122943398"></p><p><mark>至此，Jenkins 用户权限设置完毕！</mark></p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CICD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins 数据迁移</title>
      <link href="/posts/articles/5515f74f.html"/>
      <url>/posts/articles/5515f74f.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/jenkins-logo.webp" alt="jenkins-logo"></p><p><font color=Brown><strong>Author</strong>：rab</font><br><font color=Brown><strong>Date</strong>：2022&#x2F;07&#x2F;22</font><br><font color=Brown><strong>Blog</strong>：<a href="https://blog.csdn.net/IT_ZRS?type=blog"><font color=Brown>https://blog.csdn.net/IT_ZRS?type&#x3D;blog</font></a></font></p><p><strong>Jenkins Version</strong>：2.341</p><hr><h2 id="一、迁移目的"><a href="#一、迁移目的" class="headerlink" title="一、迁移目的"></a>一、迁移目的</h2><p>由于 Jenkins 部署初期磁盘规划问题（数据目录部署到了系统盘），导致服务器磁盘（系统盘）吃紧，现对 Jenkins 数据目录进行更改迁移（变更），具体如下。</p><table><thead><tr><th>迁移目录</th><th>文件详情</th><th>部署方式</th><th>磁盘容量</th><th>服务版本</th></tr></thead><tbody><tr><td>原始数据</td><td>&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;jenkins-data</td><td>Docker</td><td>（&#x2F;）50G    Used：82%</td><td>Jenkins：2.341</td></tr><tr><td>目标数据</td><td>&#x2F;home&#x2F;www&#x2F;jenkins-data</td><td>Docker</td><td>（&#x2F;home&#x2F;www）100G    Used：61%</td><td>Jenkins：2.341</td></tr></tbody></table><h2 id="二、迁移步骤"><a href="#二、迁移步骤" class="headerlink" title="二、迁移步骤"></a>二、迁移步骤</h2><h3 id="2-1-方案-1（推荐）"><a href="#2-1-方案-1（推荐）" class="headerlink" title="2.1 方案 1（推荐）"></a>2.1 方案 1（推荐）</h3><blockquote><p>以软（符号）链接的方式迁移数据目录；</p><p>本次采用的就是该方案进行的数据迁移。</p></blockquote><p>1、停止当前 Jenkins 容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop elastic_lalande</span><br></pre></td></tr></table></figure><p>2、移动 Jenkins 数据目录至新目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /var/lib/docker/volumes/jenkins-data /home/www/jenkins-data</span><br></pre></td></tr></table></figure><p>3、对移动后的数据目录做软链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ln -s /home/www/jenkins-data /var/lib/docker/volumes/jenkins-data </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这样做的好处在于，你不用重新运行新容器，对你之前的jenkinsfile文件也无需改动。</span></span><br></pre></td></tr></table></figure><p>4、启动 Jenkins</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker start elastic_lalande</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后查看日志是否启动有报错（没有明显的error信息就代表启动成功）</span></span><br><span class="line">docker logs -f elastic_lalande</span><br><span class="line">....</span><br></pre></td></tr></table></figure><blockquote><p>最后在确认一下相关端口是否正常监听。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220722133403078.png" alt="image-20220722133403078"></p><h3 id="2-2-方案-2"><a href="#2-2-方案-2" class="headerlink" title="2.2 方案 2"></a>2.2 方案 2</h3><blockquote><p>以重新运行新容器方式迁移</p></blockquote><p>1、保存当前容器为新镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit elastic_lalande jenkins:2022.07.22</span><br></pre></td></tr></table></figure><p>2、停止原始 Jenkins 容器</p><blockquote><p>先 stop 关闭容器，不要 rm -v，便于新容器无法启动（运行）时再次启用原始 Jenkins</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop elastic_lalande</span><br></pre></td></tr></table></figure><p>3、拷贝原始数据至目标路径</p><blockquote><p>原始数据保持不变，便于失败后回滚</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp -rfp /var/lib/docker/volumes/jenkins-data /home/www/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果原本你的服务器磁盘空间就不够，可以直接<span class="built_in">mv</span>，若后续需要回滚，再<span class="built_in">mv</span>回来即可（这不影响）</span></span><br><span class="line">mv /var/lib/docker/volumes/jenkins-data /home/www/</span><br></pre></td></tr></table></figure><p>4、启动新 Jenkins 容器（备选）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd \</span><br><span class="line">       --user root \</span><br><span class="line">       --privileged=true  \</span><br><span class="line">       --name=jenkins \</span><br><span class="line">       --restart=always \</span><br><span class="line">       -p 8888:8080 \</span><br><span class="line">       -p 50000:50000 \</span><br><span class="line">       -v /root:/home \</span><br><span class="line">       -v /home/www/jenkins-data:/var/jenkins_home \</span><br><span class="line">       -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">       -v /etc/localtime:/etc/localtime \</span><br><span class="line">       -e JAVA_OPTS=-Duser.timezone=Asia/Shanghai jenkins:2022.07.22</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后查看日志是否启动有报错（没有明显的error信息就代表启动成功）</span></span><br><span class="line">docker logs -f Jenkins</span><br><span class="line">....</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最后在确认一下相关端口是否正常监听</span></span><br></pre></td></tr></table></figure><h2 id="三、构建验证"><a href="#三、构建验证" class="headerlink" title="三、构建验证"></a>三、构建验证</h2><blockquote><p>启动无误后，就可以浏览器访问了，紧接着就是验证测试、生产环境的构建是否正常。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220722132320403.png" alt="image-20220722132320403"></p><h3 id="3-1-测试环境"><a href="#3-1-测试环境" class="headerlink" title="3.1 测试环境"></a>3.1 测试环境</h3><p>1、台球</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220722131158153.png" alt="image-20220722131158153"></p><p>2、麻将</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220722130945462.png" alt="image-20220722130945462"></p><p>3、地主</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220722130548988.png" alt="image-20220722130548988"></p><h3 id="3-2-生产环境"><a href="#3-2-生产环境" class="headerlink" title="3.2 生产环境"></a>3.2 生产环境</h3><p>1、台球</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220722132003684.png" alt="image-20220722132003684"></p><p>2、麻将</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220722132142832.png" alt="image-20220722132142832"></p><p>3、地主</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220722131802571.png" alt="image-20220722131802571"></p><p>以上测试没有异常，说明 Jenkins 功能没受任何影响，此时可通知相关开发人员使用了。</p><h2 id="四、数据清理"><a href="#四、数据清理" class="headerlink" title="四、数据清理"></a>四、数据清理</h2><blockquote><p>如果你采用的是软链接的方式，则跳过以下操作步骤。</p></blockquote><p>当目标容器运行正常时（功能、权限、数据等），就可清理旧数据释放存储空间了。</p><p>1、删除 Jenkins 原始挂载数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /var/lib/docker/volumes/jenkins-data</span><br></pre></td></tr></table></figure><p>2、删除 Docker 容器即相关挂载数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -v elastic_lalande</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;至此，Jenkins 数据迁移完成！&#x3D;&#x3D;</p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CICD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Active Choice Parameter 在 Jenkinsfile 中的应用</title>
      <link href="/posts/articles/1be7f41.html"/>
      <url>/posts/articles/1be7f41.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/js.jpeg" alt="js"></p><p>插件地址：</p><blockquote><p>插件地址：<a href="https://plugins.jenkins.io/uno-choice/">https://plugins.jenkins.io/uno-choice/</a></p><p>Github 地址：<a href="https://github.com/jenkinsci/active-choices-plugin">https://github.com/jenkinsci/active-choices-plugin</a></p></blockquote><hr><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>也许你可能有这样一个需求，在 Jenkins 构建时需要使用有单选、复选、及多值输入的场景，那你就可以使用 <code>Active Choice</code> 插件来实现。</p><h2 id="一、插件安装"><a href="#一、插件安装" class="headerlink" title="一、插件安装"></a>一、插件安装</h2><h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221022112938268.png" alt="image-20221022112938268"></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221022112857295.png" alt="image-20221022112857295"></p><h3 id="1-2-配置"><a href="#1-2-配置" class="headerlink" title="1.2 配置"></a>1.2 配置</h3><p>1、添加选项参数</p><blockquote><p>选择下图红框</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221022142752156.png" alt="image-20221022142752156"></p><p>2、编写 Groovy Script</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221022115716214.png" alt="image-20221022115716214"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">return [</span><br><span class="line">    &#x27;Sao Paulo&#x27;,</span><br><span class="line">    &#x27;Rio de Janeiro&#x27;,</span><br><span class="line">    &#x27;Parana&#x27;,</span><br><span class="line">    &#x27;Acre&#x27;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>2、选择<code>选择类型</code></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221022115007328.png" alt="image-20221022115007328"></p><p>3、效果展示</p><blockquote><p>当你选择多选时，可通过下图实现多选</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221022115434378.png"></p><p>4、当选择不同的 user 时可进行动态更新</p><blockquote><p>再次新增一个 Active Choice Reactive 控件，上面的 UI 控件会触发下面的选项参数并动态更新</p><p>此时选项参数选择如下图红框</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221022142942603.png" alt="image-20221022142942603"></p><p>&#x3D;&#x3D;配置&#x3D;&#x3D;：引用参数，实现自动更新。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221022150006005.png" alt="image-20221022150006005"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (User == &quot;Sao Paulo&quot;) &#123;</span><br><span class="line">  return [&quot;Barretos&quot;, &quot;Sao Paulo&quot;, &quot;Itu&quot;]</span><br><span class="line">&#125; else if (User == &quot;Rio de Janeiro&quot;) &#123;</span><br><span class="line">  return [&quot;Rio de Janeiro&quot;, &quot;Mangaratiba&quot;]</span><br><span class="line">&#125; else if (User == &quot;Parana&quot;) &#123;</span><br><span class="line">  return [&quot;Curitiba&quot;, &quot;Ponta Grossa&quot;]</span><br><span class="line">&#125; else if (User == &quot;Acre&quot;) &#123;</span><br><span class="line">  return [&quot;Rio Branco&quot;, &quot;Acrelandia&quot;]</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  return [&quot;Unknown state&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、效果</p><blockquote><p>选择 User 时，会根据配置规则刷新 PerformShell。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221022150121681.png" alt="image-20221022150121681"></p><h2 id="二、应用案例"><a href="#二、应用案例" class="headerlink" title="二、应用案例"></a>二、应用案例</h2><p>实现功能：通过选择不同的构建工具来构建不同的项目。</p><h3 id="2-1-直接配置"><a href="#2-1-直接配置" class="headerlink" title="2.1 直接配置"></a>2.1 直接配置</h3><blockquote><p>该方式不通过 <code>Pipeline</code> 脚本配置，直接进入你 Jenkins 的 Project 进行配置。</p></blockquote><p>1、添加选项参数</p><blockquote><p>选择下图红框</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221022142752156.png" alt="image-20221022142752156"></p><p>2、编写 Groovy Script</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221022114859335.png" alt="image-20221022114859335"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">return[</span><br><span class="line">  &quot;maven&quot;,</span><br><span class="line">  &quot;ant&quot;,</span><br><span class="line">  &quot;gradle&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>3、效果</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221022120838181.png" alt="image-20221022120838181"></p><p>4、当选择不同的 BuildType 时可进行动态更新</p><blockquote><p>再次新增一个 Active Choice Reactive 控件，上面的 UI 控件会触发下面的选项参数并动态更新</p><p>此时选项参数选择如下图红框</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221022142942603.png" alt="image-20221022142942603"></p><p>5、配置</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221022144341857.png" alt="image-20221022144341857"></p><p>&#x3D;&#x3D;Groovy 脚本&#x3D;&#x3D;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">if (BuildType == &quot;maven&quot;) &#123;</span><br><span class="line">  return [&quot;clean package&quot;]</span><br><span class="line">&#125; else if (BuildType == &quot;ant&quot;) &#123;</span><br><span class="line">  return [&quot;ant -buildfile build.xml&quot;]</span><br><span class="line">&#125; else if (BuildType == &quot;gradle&quot;) &#123;</span><br><span class="line">  return [&quot;gradle clean build&quot;]</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  return [&quot;Unknown state&quot;]</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或下面的都一样的（任选其一即可）</span></span><br><span class="line"></span><br><span class="line">if (BuildType.equals (&quot;maven&quot;)) &#123;</span><br><span class="line">  return [&quot;clean package&quot;]</span><br><span class="line">&#125; else if (BuildType.equals (&quot;ant&quot;)) &#123;</span><br><span class="line">  return [&quot;ant -buildfile build.xml&quot;]</span><br><span class="line">&#125; else if (BuildType.equals (&quot;gradle&quot;)) &#123;</span><br><span class="line">  return [&quot;gradle clean build&quot;]</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  return [&quot;Unknown state&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、效果</p><p>选择 maven 类型时自动选择构建命令，而不需要手动点击 PerformShell 选项</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221022145422284.png" alt="image-20221022145422284"></p><h3 id="2-2-Jenkinsfile-配置"><a href="#2-2-Jenkinsfile-配置" class="headerlink" title="2.2 Jenkinsfile 配置"></a>2.2 Jenkinsfile 配置</h3><p><code>2.1 部分</code>是直接通过 web 界面设置，接下来我们可以通过 Pipeline 来自动化实现。附上一个参考模板样例：根据自身需求修改即可</p><h4 id="2-2-1-案例一"><a href="#2-2-1-案例一" class="headerlink" title="2.2.1 案例一"></a>2.2.1 案例一</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">properties([</span><br><span class="line">    parameters([</span><br><span class="line">        [<span class="attr">$class:</span> <span class="string">&#x27;ChoiceParameter&#x27;</span>, </span><br><span class="line">            <span class="symbol">choiceType:</span> <span class="string">&#x27;PT_SINGLE_SELECT&#x27;</span>, </span><br><span class="line">            <span class="symbol">description:</span> <span class="string">&#x27;Select the Env Name from the Dropdown List&#x27;</span>, </span><br><span class="line">            <span class="symbol">filterLength:</span> <span class="number">1</span>, </span><br><span class="line">            <span class="symbol">filterable:</span> <span class="literal">true</span>, </span><br><span class="line">            <span class="symbol">name:</span> <span class="string">&#x27;Env&#x27;</span>, </span><br><span class="line">            <span class="symbol">randomName:</span> <span class="string">&#x27;choice-parameter-5631314439613978&#x27;</span>, </span><br><span class="line">            <span class="symbol">script:</span> [</span><br><span class="line">                <span class="symbol">$class:</span> <span class="string">&#x27;GroovyScript&#x27;</span>, </span><br><span class="line">                <span class="symbol">fallbackScript:</span> [</span><br><span class="line">                    <span class="symbol">classpath:</span> [], </span><br><span class="line">                    <span class="symbol">sandbox:</span> <span class="literal">false</span>, </span><br><span class="line">                    <span class="symbol">script:</span> </span><br><span class="line">                        <span class="string">&#x27;return[\&#x27;Could not get Env\&#x27;]&#x27;</span></span><br><span class="line">                ], </span><br><span class="line">                <span class="symbol">script:</span> [</span><br><span class="line">                    <span class="symbol">classpath:</span> [], </span><br><span class="line">                    <span class="symbol">sandbox:</span> <span class="literal">false</span>, </span><br><span class="line">                    <span class="symbol">script:</span> </span><br><span class="line">                        <span class="string">&#x27;return[&quot;Dev&quot;,&quot;QA&quot;,&quot;Stage&quot;,&quot;Prod&quot;]&#x27;</span></span><br><span class="line">                ]</span><br><span class="line">            ]</span><br><span class="line">        ],</span><br><span class="line">        [<span class="attr">$class:</span> <span class="string">&#x27;CascadeChoiceParameter&#x27;</span>, </span><br><span class="line">            <span class="symbol">choiceType:</span> <span class="string">&#x27;PT_SINGLE_SELECT&#x27;</span>, </span><br><span class="line">            <span class="symbol">description:</span> <span class="string">&#x27;Select the Server from the Dropdown List&#x27;</span>, </span><br><span class="line">            <span class="symbol">filterLength:</span> <span class="number">1</span>, </span><br><span class="line">            <span class="symbol">filterable:</span> <span class="literal">true</span>, </span><br><span class="line">            <span class="symbol">name:</span> <span class="string">&#x27;Server&#x27;</span>, </span><br><span class="line">            <span class="symbol">randomName:</span> <span class="string">&#x27;choice-parameter-5631314456178619&#x27;</span>, </span><br><span class="line">            <span class="symbol">referencedParameters:</span> <span class="string">&#x27;Env&#x27;</span>,</span><br><span class="line">            <span class="symbol">script:</span> [</span><br><span class="line">                <span class="symbol">$class:</span> <span class="string">&#x27;GroovyScript&#x27;</span>, </span><br><span class="line">                <span class="symbol">fallbackScript:</span> [</span><br><span class="line">                    <span class="symbol">classpath:</span> [], </span><br><span class="line">                    <span class="symbol">sandbox:</span> <span class="literal">false</span>, </span><br><span class="line">                    <span class="symbol">script:</span> </span><br><span class="line">                        <span class="string">&#x27;return[\&#x27;Could not get Environment from Env Param\&#x27;]&#x27;</span></span><br><span class="line">                ], </span><br><span class="line">                <span class="symbol">script:</span> [</span><br><span class="line">                    <span class="symbol">classpath:</span> [], </span><br><span class="line">                    <span class="symbol">sandbox:</span> <span class="literal">false</span>, </span><br><span class="line">                    <span class="symbol">script:</span> </span><br><span class="line">                        <span class="string">&#x27;&#x27;&#x27;if (Env.equals(&quot;Dev&quot;)) &#123;</span></span><br><span class="line"><span class="string">  return[&quot;devaaa001&quot;,&quot;devaaa002&quot;,&quot;devbbb001&quot;,&quot;devbbb002&quot;,&quot;devccc001&quot;,&quot;devccc002&quot;]</span></span><br><span class="line"><span class="string">&#125; else if (Env.equals(&quot;QA&quot;)) &#123;</span></span><br><span class="line"><span class="string">  return[&quot;qaaaa001&quot;,&quot;qabbb002&quot;,&quot;qaccc003&quot;]</span></span><br><span class="line"><span class="string">&#125; else if (Env.equals(&quot;Stage&quot;)) &#123;</span></span><br><span class="line"><span class="string">  return[&quot;staaa001&quot;,&quot;stbbb002&quot;,&quot;stccc003&quot;]</span></span><br><span class="line"><span class="string">&#125; else if (Env.equals(&quot;Prod&quot;)) &#123;</span></span><br><span class="line"><span class="string">  return[&quot;praaa001&quot;,&quot;prbbb002&quot;,&quot;prccc003&quot;]</span></span><br><span class="line"><span class="string">&#125;&#x27;&#x27;&#x27;</span></span><br><span class="line">                ]</span><br><span class="line">            ]</span><br><span class="line">        ]</span><br><span class="line">    ])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">pipeline &#123;</span><br><span class="line">  environment &#123;</span><br><span class="line">         vari = <span class="string">&quot;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  agent any</span><br><span class="line">  stages &#123;</span><br><span class="line">      stage (<span class="string">&quot;Example&quot;</span>) &#123;</span><br><span class="line">        steps &#123;</span><br><span class="line">         script&#123;</span><br><span class="line">          echo <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">          echo <span class="string">&quot;$&#123;params.Env&#125;&quot;</span></span><br><span class="line">          echo <span class="string">&quot;$&#123;params.Server&#125;&quot;</span></span><br><span class="line">          <span class="keyword">if</span> (params.Server.equals(<span class="string">&quot;Could not get Environment from Env Param&quot;</span>)) &#123;</span><br><span class="line">              echo <span class="string">&quot;Must be the first build after Pipeline deployment.  Aborting the build&quot;</span></span><br><span class="line">              currentBuild.result = <span class="string">&#x27;ABORTED&#x27;</span></span><br><span class="line">              <span class="keyword">return</span></span><br><span class="line">          &#125;</span><br><span class="line">          echo <span class="string">&quot;Crossed param validation&quot;</span></span><br><span class="line">        &#125; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;构建结果：&#x3D;&#x3D;</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221023142918432.png" alt="image-20221023142918432"></p><h4 id="2-2-2-案例二"><a href="#2-2-2-案例二" class="headerlink" title="2.2.2 案例二"></a>2.2.2 案例二</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">properties([</span><br><span class="line">    parameters([</span><br><span class="line">        choice(<span class="attr">name:</span><span class="string">&quot;Select&quot;</span>,<span class="attr">choices:</span>[<span class="string">&#x27;yes&#x27;</span>,<span class="string">&#x27;no&#x27;</span>],<span class="attr">description:</span> <span class="string">&quot;⚠ 选择 yse 或 no ！&quot;</span>),</span><br><span class="line">        [<span class="attr">$class:</span> <span class="string">&#x27;CascadeChoiceParameter&#x27;</span>,</span><br><span class="line">            <span class="symbol">choiceType:</span> <span class="string">&#x27;PT_SINGLE_SELECT&#x27;</span>,</span><br><span class="line">            <span class="symbol">description:</span> <span class="string">&#x27;⚠ 选择需要限制的 CPU 值 ！&#x27;</span>,</span><br><span class="line">            <span class="symbol">name:</span> <span class="string">&#x27;CPU_LIMIT&#x27;</span>,</span><br><span class="line">            <span class="symbol">randomName:</span> <span class="string">&#x27;choice-parameter-5631314456178624&#x27;</span>,</span><br><span class="line">            <span class="symbol">referencedParameters:</span> <span class="string">&#x27;Select&#x27;</span>,</span><br><span class="line">            <span class="symbol">script:</span> [</span><br><span class="line">                <span class="symbol">$class:</span> <span class="string">&#x27;GroovyScript&#x27;</span>,</span><br><span class="line">                <span class="symbol">fallbackScript:</span> [</span><br><span class="line">                    <span class="symbol">classpath:</span> [],</span><br><span class="line">                    <span class="symbol">sandbox:</span> <span class="literal">true</span>,</span><br><span class="line">                    <span class="symbol">script:</span></span><br><span class="line">                        <span class="string">&#x27;return[\&#x27;nothing.....\&#x27;]&#x27;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="symbol">script:</span> [</span><br><span class="line">                    <span class="symbol">classpath:</span> [],</span><br><span class="line">                    <span class="symbol">sandbox:</span> <span class="literal">true</span>,</span><br><span class="line">                    <span class="symbol">script:</span></span><br><span class="line">                        <span class="string">&quot;&quot;&quot;if (Select.equals(&#x27;yes&#x27;)) &#123;</span></span><br><span class="line"><span class="string">  return[&quot;0.5C&quot;,&quot;2C&quot;,&quot;4C&quot;]</span></span><br><span class="line"><span class="string">&#125; else &#123;</span></span><br><span class="line"><span class="string">  return[&quot;none limit&quot;]</span></span><br><span class="line"><span class="string">&#125;&quot;&quot;&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            ]</span><br><span class="line">        ]</span><br><span class="line">    ])</span><br><span class="line">])</span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;test&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&quot;$&#123;params.Select&#125;&quot;</span></span><br><span class="line">                echo <span class="string">&quot;$&#123;params.CPU_LIMIT&#125;&quot;</span>  <span class="comment">// 获取参数值时必须使用params.&lt;参数名&gt;才能获取，否则报错</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;构建效果&#x3D;&#x3D;</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221023152841068.png" alt="image-20221023152841068"></p><h4 id="2-2-3-案例三"><a href="#2-2-3-案例三" class="headerlink" title="2.2.3 案例三"></a>2.2.3 案例三</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">properties([</span><br><span class="line">    parameters([</span><br><span class="line">        <span class="comment">// 参数一：用于用户构建前的选择（如选择构建工具）</span></span><br><span class="line">        [<span class="attr">$class:</span> <span class="string">&#x27;ChoiceParameter&#x27;</span>, </span><br><span class="line">            <span class="symbol">choiceType:</span> <span class="string">&#x27;PT_SINGLE_SELECT&#x27;</span>, </span><br><span class="line">            <span class="symbol">description:</span> <span class="string">&#x27;Select the BuildTools Name from the Dropdown List&#x27;</span>, </span><br><span class="line">            <span class="symbol">filterLength:</span> <span class="number">1</span>, </span><br><span class="line">            <span class="symbol">filterable:</span> <span class="literal">true</span>, </span><br><span class="line">            <span class="symbol">name:</span> <span class="string">&#x27;BuildTools&#x27;</span>, </span><br><span class="line">            <span class="symbol">randomName:</span> <span class="string">&#x27;choice-parameter-5631314439613978&#x27;</span>, </span><br><span class="line">            <span class="symbol">script:</span> [</span><br><span class="line">                <span class="symbol">$class:</span> <span class="string">&#x27;GroovyScript&#x27;</span>, </span><br><span class="line">                <span class="symbol">fallbackScript:</span> [</span><br><span class="line">                    <span class="symbol">classpath:</span> [], </span><br><span class="line">                    <span class="symbol">sandbox:</span> <span class="literal">true</span>, </span><br><span class="line">                    <span class="symbol">script:</span> </span><br><span class="line">                        <span class="string">&#x27;return[\&#x27;Could not get BuildTools\&#x27;]&#x27;</span></span><br><span class="line">                ], </span><br><span class="line">                <span class="symbol">script:</span> [</span><br><span class="line">                    <span class="symbol">classpath:</span> [], </span><br><span class="line">                    <span class="symbol">sandbox:</span> <span class="literal">true</span>, </span><br><span class="line">                    <span class="symbol">script:</span> </span><br><span class="line">                        <span class="string">&#x27;return[&quot;Maven&quot;,&quot;Ant&quot;,&quot;Gradle&quot;]&#x27;</span></span><br><span class="line">                ]</span><br><span class="line">            ]</span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">// 参数二：根据参数一的选择内容自动更新（如选择不同的构建工具就会自动更新为对应的构建命名）</span></span><br><span class="line">        [<span class="attr">$class:</span> <span class="string">&#x27;CascadeChoiceParameter&#x27;</span>, </span><br><span class="line">            <span class="symbol">choiceType:</span> <span class="string">&#x27;PT_SINGLE_SELECT&#x27;</span>, </span><br><span class="line">            <span class="symbol">description:</span> <span class="string">&#x27;Select the ExecuteShell from the Dropdown List&#x27;</span>, </span><br><span class="line">            <span class="symbol">filterLength:</span> <span class="number">1</span>, </span><br><span class="line">            <span class="symbol">filterable:</span> <span class="literal">true</span>, </span><br><span class="line">            <span class="symbol">name:</span> <span class="string">&#x27;ExecuteShell&#x27;</span>, </span><br><span class="line">            <span class="symbol">randomName:</span> <span class="string">&#x27;choice-parameter-5631314456178619&#x27;</span>, </span><br><span class="line">            <span class="comment">// BuildTools 为应用参数一（并获取参数一的值）</span></span><br><span class="line">            <span class="symbol">referencedParameters:</span> <span class="string">&#x27;BuildTools&#x27;</span>,</span><br><span class="line">            <span class="symbol">script:</span> [</span><br><span class="line">                <span class="symbol">$class:</span> <span class="string">&#x27;GroovyScript&#x27;</span>, </span><br><span class="line">                <span class="symbol">fallbackScript:</span> [</span><br><span class="line">                    <span class="symbol">classpath:</span> [], </span><br><span class="line">                    <span class="symbol">sandbox:</span> <span class="literal">true</span>, </span><br><span class="line">                    <span class="symbol">script:</span> </span><br><span class="line">                        <span class="string">&#x27;return[\&#x27;Could not get Environment from ExecuteShell Param\&#x27;]&#x27;</span></span><br><span class="line">                ], </span><br><span class="line">                <span class="symbol">script:</span> [</span><br><span class="line">                    <span class="symbol">classpath:</span> [], </span><br><span class="line">                    <span class="symbol">sandbox:</span> <span class="literal">true</span>, </span><br><span class="line">                    <span class="comment">// 根据获取的参数一的值来动态返回你自定义的值</span></span><br><span class="line">                    <span class="symbol">script:</span> </span><br><span class="line">                        <span class="string">&#x27;&#x27;&#x27;if (BuildTools.equals(&quot;Maven&quot;)) &#123;</span></span><br><span class="line"><span class="string">  return[&quot;clean package&quot;]</span></span><br><span class="line"><span class="string">&#125; else if (BuildTools.equals(&quot;Ant&quot;)) &#123;</span></span><br><span class="line"><span class="string">  return[&quot;ant -buildfile build.xml&quot;]</span></span><br><span class="line"><span class="string">&#125; else if (BuildTools.equals(&quot;Gradle&quot;)) &#123;</span></span><br><span class="line"><span class="string">  return[&quot;gradle clean build&quot;]</span></span><br><span class="line"><span class="string">&#125;&#x27;&#x27;&#x27;</span></span><br><span class="line">                ]</span><br><span class="line">            ]</span><br><span class="line">        ]</span><br><span class="line">    ])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 流水线脚本</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    environment &#123;</span><br><span class="line">        vari = <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage (<span class="string">&quot;Example&quot;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script&#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">                echo <span class="string">&quot;$&#123;params.BuildTools&#125;&quot;</span></span><br><span class="line">                echo <span class="string">&quot;$&#123;params.ExecuteShell&#125;&quot;</span></span><br><span class="line">                <span class="comment">// 若参数二获取不到值则取消本次构建</span></span><br><span class="line">                <span class="keyword">if</span> (params.ExecuteShell.equals(<span class="string">&quot;Could not get Environment from ExecuteShell Param&quot;</span>)) &#123;</span><br><span class="line">                    echo <span class="string">&quot;Must be the first build after Pipeline deployment.  Aborting the build&quot;</span></span><br><span class="line">                    currentBuild.result = <span class="string">&#x27;ABORTED&#x27;</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark>构建效果：</mark><br><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221023162054239.png" alt="image-20221023162054239"></p><p><mark>构建输出：</mark><br><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221023161641157.png" alt="image-20221023161641157"></p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CICD </tag>
            
            <tag> Jenkins_Pipeline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pipeline 核心技术</title>
      <link href="/posts/articles/a951d278.html"/>
      <url>/posts/articles/a951d278.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/%E6%B5%81%E6%B0%B4%E7%BA%BF.webp" alt="流水线"></p><p><font color=Brown><strong>Author</strong>：rab</font><br><font color=Brown><strong>Date</strong>：2022&#x2F;07&#x2F;24</font><br><font color=Brown><strong>Blog</strong>：<a href="https://blog.csdn.net/IT_ZRS?type=blog"><font color=Brown>https://blog.csdn.net/IT_ZRS?type&#x3D;blog</font></a></font></p><hr><h2 id="一、整体结构"><a href="#一、整体结构" class="headerlink" title="一、整体结构"></a>一、整体结构</h2><p>Pipeline 有两种语法格式，分别是脚本式和声明式，通常我们是两种语法格式结合使用。先来看看整体结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">agent any</span><br><span class="line">stages &#123;</span><br><span class="line">stage(&#x27;git&#x27;) &#123;</span><br><span class="line">steps &#123;</span><br><span class="line">// 拉取项目</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">stage(&#x27;build&#x27;) &#123;</span><br><span class="line">steps &#123;</span><br><span class="line">// 构建项目</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">stage(&#x27;deproment&#x27;) &#123;</span><br><span class="line">steps &#123;</span><br><span class="line">script &#123;</span><br><span class="line">// 发布项目</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">post &#123;</span><br><span class="line">always &#123;</span><br><span class="line">// 不管构建成功、失败还是取消都执行该部分操作</span><br><span class="line">&#125;</span><br><span class="line">success &#123;</span><br><span class="line">// 只有构建成功后才执行该部分操作</span><br><span class="line">&#125;</span><br><span class="line">failure &#123;</span><br><span class="line">// 只有构建失败后才执行该部分操作</span><br><span class="line">&#125;</span><br><span class="line">aborted &#123;</span><br><span class="line">// 只有构建中途取消构建后才执行该部分</span><br><span class="line">&#125;</span><br><span class="line">unstable &#123;</span><br><span class="line">// 构建不稳定时执行该部分</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、基本语法"><a href="#二、基本语法" class="headerlink" title="二、基本语法"></a>二、基本语法</h2><h3 id="2-1-agent"><a href="#2-1-agent" class="headerlink" title="2.1 agent"></a>2.1 agent</h3><h4 id="2-1-1-说明"><a href="#2-1-1-说明" class="headerlink" title="2.1.1 说明"></a>2.1.1 说明</h4><p><code>agent</code>  的作用是：你本次的构建在哪个 Jenkins 服务器实例上执行。因此 <code>agent</code> 部分有以下参数可选择。</p><ul><li><p><strong>any</strong>：该参数表示当前构建任务可在任意可用 Jenkins 节点上运行；</p></li><li><p><strong>none</strong>：当为 none 时，在 stage 阶段中时必须指定  Jenkins 服务器实例，否则报错；</p></li><li><p><strong>label</strong>：在指定的 Jenkins 标签节点运行（前提是你已经为你的 Jenkins 实例设置了标签）；</p></li><li><p><strong>node</strong>：该参数支持自定义流水线工作目录（<code>即 workspace 目录</code>）；</p></li><li><p><strong>docker</strong>：可使用 docker 在指定的 <code>pipeline &#123;&#125;</code> 或 <code>stage() &#123;&#125;</code> 中执行；</p></li><li><p><strong>dockerfile</strong>：可使用 dockerfile 在指定的 <code>pipeline &#123;&#125;</code> 或 <code>stage() &#123;&#125;</code> 中执行；</p></li><li><p><strong>kubernetes</strong>：应用于 K8s 中</p></li></ul><h4 id="2-1-2-案例"><a href="#2-1-2-案例" class="headerlink" title="2.1.2 案例"></a>2.1.2 案例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">案例1</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">agent any</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">案例2</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">agent none</span><br><span class="line">stages &#123;</span><br><span class="line">stage(&#x27;build&#x27;) &#123;</span><br><span class="line">agent your_Jenkins_labelname</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">案例3</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">agent &#123; label &quot;your_Jenkins_labelname&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">案例4</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">  agent &#123; </span><br><span class="line">     node &#123;</span><br><span class="line">        label &quot;your_Jenkins_labelname&quot;,</span><br><span class="line">        customWorkspace &quot;/data/jenkins_agent/workspace&quot;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">案例5</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">agent &#123;</span><br><span class="line">docker &#123;</span><br><span class="line">image &#x27;maven:3.8.1-adoptopenjdk-11&#x27;</span><br><span class="line">label &#x27;your_Jenkins_labelname&#x27;</span><br><span class="line">args  &#x27;-v /tmp:/tmp&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">案例6</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        // Equivalent to &quot;docker build -f Dockerfile.build --build-arg version=1.0.2 ./build/</span><br><span class="line">        dockerfile &#123;</span><br><span class="line">            filename &#x27;Dockerfile.build&#x27;</span><br><span class="line">            dir &#x27;build&#x27;</span><br><span class="line">            label &#x27;your_Jenkins_labelname&#x27;</span><br><span class="line">            additionalBuildArgs  &#x27;--build-arg version=1.0.2&#x27;</span><br><span class="line">            args &#x27;-v /tmp:/tmp&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">案例7</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        kubernetes &#123;</span><br><span class="line">            defaultContainer &#x27;kaniko&#x27;</span><br><span class="line">            yaml &#x27;&#x27;&#x27;</span><br><span class="line">    kind: Pod</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: kaniko</span><br><span class="line">        image: gcr.io/kaniko-project/executor:debug</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        command:</span><br><span class="line">        - sleep</span><br><span class="line">        args:</span><br><span class="line">        - 99d</span><br><span class="line">        volumeMounts:</span><br><span class="line">          - name: aws-secret</span><br><span class="line">            mountPath: /root/.aws/</span><br><span class="line">          - name: docker-registry-config</span><br><span class="line">            mountPath: /kaniko/.docker</span><br><span class="line">      volumes:</span><br><span class="line">        - name: aws-secret</span><br><span class="line">          secret:</span><br><span class="line">            secretName: aws-secret</span><br><span class="line">        - name: docker-registry-config</span><br><span class="line">          configMap:</span><br><span class="line">            name: docker-registry-config</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单看一下 node 形式的：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220724140903917.png" alt="image-20220724140903917"></p><h3 id="2-2-stages"><a href="#2-2-stages" class="headerlink" title="2.2 stages"></a>2.2 stages</h3><h4 id="2-2-1-说明"><a href="#2-2-1-说明" class="headerlink" title="2.2.1 说明"></a>2.2.1 说明</h4><p>stages （阶段）包含多个 stage（且至少包含一个 stage），一个 stage 中包含一个 steps（步骤-且只包含一个 steps）</p><h4 id="2-2-2-案例"><a href="#2-2-2-案例" class="headerlink" title="2.2.2 案例"></a>2.2.2 案例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">agent any</span><br><span class="line">stages &#123;</span><br><span class="line">stage(&#x27;build&#x27;) &#123;</span><br><span class="line">steps &#123;</span><br><span class="line">script &#123;</span><br><span class="line">println(&#x27;build your project !&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">===================================</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如何嵌套脚本式语法？</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当我们引用 script &#123;&#125; 时，就可以在该部分中引入脚本时语法（比如<span class="keyword">for</span>循环、<span class="keyword">if</span>判断等等）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">script &#123;&#125; 紧跟 steps，然后所有的脚本式语法就在 script &#123;...&#125; 中执行</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">错误书写方式如下：</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">agent any</span><br><span class="line">stages &#123;</span><br><span class="line">stage(&#x27;build&#x27;) &#123;</span><br><span class="line">steps &#123;</span><br><span class="line">echo &#x27;hello world&#x27;</span><br><span class="line">script &#123;</span><br><span class="line">println(&#x27;build your project !&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">正确书写方式如下：</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">agent any</span><br><span class="line">stages &#123;</span><br><span class="line">stage(&#x27;build&#x27;) &#123;</span><br><span class="line">steps &#123;</span><br><span class="line">script &#123;</span><br><span class="line">echo &#x27;hello world&#x27;</span><br><span class="line">println(&#x27;build your project !&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220724141744321.png" alt="image-20220724141744321"></p><h3 id="2-3-post"><a href="#2-3-post" class="headerlink" title="2.3 post"></a>2.3 post</h3><h4 id="2-3-1-说明"><a href="#2-3-1-说明" class="headerlink" title="2.3.1 说明"></a>2.3.1 说明</h4><p><code>post</code> 部分是流水线构建后的相关操作步骤，其包含五个状态参数。</p><ul><li><strong>always</strong>：不管构建成功、失败还是取消都执行该部分操作；</li><li><strong>success</strong>：只有构建成功后才执行该部分操作；</li><li><strong>failure</strong>：只有构建失败后才执行该部分操作；</li><li><strong>aborted</strong>：只有构建中途取消构建后才执行该部分；</li><li><strong>unstable</strong>：构建不稳定时执行该部分。</li></ul><p>⚠注意：<code>post</code> 部分与 <code>stages</code>  处于同级。</p><h4 id="2-3-2-案例"><a href="#2-3-2-案例" class="headerlink" title="2.3.2 案例"></a>2.3.2 案例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">agent any</span><br><span class="line">stages &#123;</span><br><span class="line">stage(&#x27;build&#x27;) &#123;</span><br><span class="line">steps &#123;</span><br><span class="line">script &#123;</span><br><span class="line">println(&#x27;build your project !&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">post &#123;</span><br><span class="line">success &#123;</span><br><span class="line">echo &#x27;build success&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220724143856442.png" alt="image-20220724143856442"></p><h3 id="2-4-环境变量"><a href="#2-4-环境变量" class="headerlink" title="2.4 环境变量"></a>2.4 环境变量</h3><p>我们可以通过 <code>environment</code> 来设置环境变量。</p><h4 id="2-4-1-预定义变量"><a href="#2-4-1-预定义变量" class="headerlink" title="2.4.1 预定义变量"></a>2.4.1 预定义变量</h4><p>1、说明</p><p>预定义变量也就是我们 Jenkins 内部默认存在且可用的变量，属于全局 变量，即该类型的变量<code>可在 Pipeline 中全局或局部引用</code>。如何查看 Jenkins 的预定义变量？可在 <code>Jenkins 流水线语法</code> 部分中查看，如下图，每一个变量都有相应的解释。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220724144355604.png" alt="image-20220724144355604"></p><p>2、如何引用预定义变量</p><p>对于预定义变量或全局变量，引用方式为：<code>$&#123;env.变量名&#125;</code></p><h4 id="2-4-2-自定义变量"><a href="#2-4-2-自定义变量" class="headerlink" title="2.4.2 自定义变量"></a>2.4.2 自定义变量</h4><p>自定义变量也可以定义全局变量与局部变量。</p><p>1、自定义全局变量</p><blockquote><p>与 <code>stages &#123;&#125;</code> 同级的自定义变量属于全局变量，在流水线脚本中各阶段中可全局或局部引用。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123;</span><br><span class="line">        PROJECT = &quot;cms&quot;</span><br><span class="line">        VERSION = &quot;v1.0.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;build&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &quot;$&#123;env.PROJECT&#125;&quot;</span><br><span class="line">                // 或 echo &quot;$&#123;PROJECT&#125;&quot; 都是可以的</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post &#123;</span><br><span class="line">        success &#123;</span><br><span class="line">            echo &#x27;build success&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220724145832755.png" alt="image-20220724145832755"></p><p>2、自定义局部变量</p><blockquote><p>定义于 <code>stage(&#39;...&#39;) &#123;&#125;</code> 下的变量我们称之为局部变量，该变量只能在其所处的阶段步骤中引用。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;build&#x27;) &#123;</span><br><span class="line">            environment &#123;</span><br><span class="line">                PROJECT = &quot;cms&quot;</span><br><span class="line">                VERSION = &quot;v1.0.0&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &quot;$&#123;VERSION&#125;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post &#123;</span><br><span class="line">        success &#123;</span><br><span class="line">            echo &#x27;build success&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220724154749312.png" alt="image-20220724154749312"></p><p>如果你在其他 stage 阶段引用时，是获取不到该变量值的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;build&#x27;) &#123;</span><br><span class="line">            environment &#123;</span><br><span class="line">                PROJECT = &quot;cms&quot;</span><br><span class="line">                VERSION = &quot;v1.0.0&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &quot;$&#123;VERSION&#125;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&#x27;depro&#x27;) &#123;</span><br><span class="line">        steps &#123;</span><br><span class="line">        echo &quot;$&#123;VERSION&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post &#123;</span><br><span class="line">        success &#123;</span><br><span class="line">            echo &#x27;build success&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220724155044976.png" alt="image-20220724155044976"></p><p>除非你定义了全局变量，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123;</span><br><span class="line">    NAME = &quot;rab&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;build&#x27;) &#123;</span><br><span class="line">            environment &#123;</span><br><span class="line">                PROJECT = &quot;cms&quot;</span><br><span class="line">                VERSION = &quot;v1.0.0&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &quot;$&#123;VERSION&#125;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&#x27;depro&#x27;) &#123;</span><br><span class="line">        steps &#123;</span><br><span class="line">        echo &quot;$&#123;NAME&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post &#123;</span><br><span class="line">        success &#123;</span><br><span class="line">            echo &#x27;build success&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220724155259349.png" alt="image-20220724155259349"></p><p>&#x3D;&#x3D;再次来看看定义变量的方法：&#x3D;&#x3D;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def PROJECT = cms</span><br><span class="line">String NAME = rab</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以上这两种写法是一样，def可以自动推导出变量类型，而String这种写法是精确这个变量是一个字符串类型的。</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全局变量的定义方式</span></span><br><span class="line">env.NAME = rab</span><br></pre></td></tr></table></figure><h3 id="2-5-credentials"><a href="#2-5-credentials" class="headerlink" title="2.5 credentials"></a>2.5 credentials</h3><h4 id="2-5-1-说明"><a href="#2-5-1-说明" class="headerlink" title="2.5.1 说明"></a>2.5.1 说明</h4><p><code>credentials</code> 可用于在 Jenkins 环境中通过标识符访问预定义的凭证。在 <code>environment</code> 中，我们经常使用 <code>credentials</code> 方法来对敏感密钥&#x2F;密码进行加密。</p><ul><li><p><strong>Secret Text 类型的凭证</strong></p><p><code>credentials()</code> 将确保指定的环境变量包含秘密文本内容。</p></li><li><p><strong>SStandard username and password 类型的凭证</strong></p><p>指定的环境变量指定为 <code>username:password</code> ，并且两个额外的环境变量将被自动定义：分别为 <code>MYVARNAME_USR</code> 和 <code>MYVARNAME_PSW</code> 。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123; </span><br><span class="line">        CC = &#x27;clang&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Example&#x27;) &#123;</span><br><span class="line">            environment &#123; </span><br><span class="line">                REMOTE_HOST = credentials(&#x27;remote-host&#x27;) </span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;printenv&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">credentials 填的是凭证的唯一ID标识值</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时你就可以在 stage(<span class="string">&#x27;Example&#x27;</span>) &#123;&#125; 阶段中引用相关变量参数了（REMOTE_HOST_PSW和REMOTE_HOST_USR）</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220724171024606.png" alt="image-20220724171024606"></p><h4 id="2-5-2-案例"><a href="#2-5-2-案例" class="headerlink" title="2.5.2 案例"></a>2.5.2 案例</h4><p>1、<code>Secret Text</code> 类型的凭证</p><p>这个比较简单，一般用于以文本形式加密密码、Token 等敏感信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123; </span><br><span class="line">        CC = &#x27;clang&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Example&#x27;) &#123;</span><br><span class="line">            environment &#123; </span><br><span class="line">                REMOTE_HOST_TOKEN = credentials(&#x27;test-secret-text&#x27;) </span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;printenv&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220724184105358.png" alt="image-20220724184105358"></p><p>2、<code>SStandard username and password</code> 类型的凭证</p><blockquote><p>如果想以密钥形式登录远程服务器，可采用 <code>withCredentials() &#123;&#125;</code> 函数（方法）</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123; </span><br><span class="line">        CC = &#x27;clang&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;remote_host&#x27;) &#123;</span><br><span class="line">            environment &#123; </span><br><span class="line">                REMOTE_HOST = credentials(&#x27;remote-host&#x27;) </span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script &#123;</span><br><span class="line">                    sh &#x27;printenv&#x27;</span><br><span class="line">                    def remote = [:]</span><br><span class="line">                    remote.name = &quot;192.168.56.133&quot;</span><br><span class="line">                    remote.host = &quot;192.168.56.133&quot;</span><br><span class="line">                    remote.user = &quot;$&#123;REMOTE_HOST_USR&#125;&quot;</span><br><span class="line">                    remote.port = 22</span><br><span class="line">                    remote.password = &quot;$&#123;REMOTE_HOST_PSW&#125;&quot;</span><br><span class="line">                    remote.allowAnyHosts = true</span><br><span class="line">                    sshCommand remote: remote, command: &quot;ls -a&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220724180206647.png" alt="image-20220724180206647"></p><p>来到 133 这台服务器上验证看看，是不是有这几个文件：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220724180407114.png" alt="image-20220724180407114"></p><h3 id="2-6-options"><a href="#2-6-options" class="headerlink" title="2.6 options"></a>2.6 options</h3><h4 id="2-6-1-说明"><a href="#2-6-1-说明" class="headerlink" title="2.6.1 说明"></a>2.6.1 说明</h4><p>该选项参数可控制 Jenkins 构建超时时间、构建重试次数、禁止并行构建等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">options &#123;</span><br><span class="line">// 保存最近的记录（保留1份）</span><br><span class="line">buildDiscarder(logRotator(numToKeepStr: &#x27;1&#x27;))</span><br><span class="line">// 禁止并行构建</span><br><span class="line">disableConcurrentBuilds()</span><br><span class="line">// 跳过默认的代码检出</span><br><span class="line">skipDefaultCheckout()</span><br><span class="line">// 设定流水线的超时时间(可用于阶段级别)</span><br><span class="line">timeout(time: 1, unit: &#x27;HOURS&#x27;)</span><br><span class="line">// 设定流水线的重试次数(可用于阶段级别)</span><br><span class="line">retry(3)</span><br><span class="line">// 设置日志时间输出(可用于阶段级别)</span><br><span class="line">timestamps()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-2-案例"><a href="#2-6-2-案例" class="headerlink" title="2.6.2 案例"></a>2.6.2 案例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;build&#x27;) &#123;</span><br><span class="line">            environment &#123;</span><br><span class="line">                PROJECT = &quot;cms&quot;</span><br><span class="line">                VERSION = &quot;v1.0.0&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            options &#123;</span><br><span class="line">            timestamps()</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &quot;$&#123;VERSION&#125;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post &#123;</span><br><span class="line">        success &#123;</span><br><span class="line">            echo &#x27;build success&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220724163227712.png" alt="image-20220724163227712"></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220724163409911.png" alt="image-20220724163409911"></p><h3 id="2-7-parameters"><a href="#2-7-parameters" class="headerlink" title="2.7 parameters"></a>2.7 parameters</h3><h4 id="2-7-1-说明"><a href="#2-7-1-说明" class="headerlink" title="2.7.1 说明"></a>2.7.1 说明</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">字符串类型</span></span><br><span class="line">string(name: &#x27;&#x27;, defaultvalue: &#x27;&#x27;, description: &#x27;&#x27;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文本类型</span></span><br><span class="line">text(name: &#x27;&#x27;, defaultvalue: &#x27;&#x27;, description: &#x27;&#x27;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">布尔类型</span></span><br><span class="line">booleanParam(name: &#x27;&#x27;, defaultvalue: &#x27;&#x27;, description: &#x27;&#x27;)  --&gt; true/false</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选项类型（只可选择一项）</span></span><br><span class="line">choice(name: &#x27;&#x27;, choices: [&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;], description: &#x27;&#x27;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">扩展选项类型（可选择多项，需安装扩展插件）</span></span><br><span class="line">extendedChoice(name: &#x27;&#x27;, description: &#x27;&#x27;, multiSelectDelimiter: &#x27;,&#x27;, quoteValue: false, saveJSONParameterToFile: false, type: &#x27;PT_CHECKBOX&#x27;, value: &#x27;a,b,c,...&#x27;, visibleItemCount: 10)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">密码类型</span></span><br><span class="line">password(name:&#x27;&#x27;, defaultvalue:&#x27;&#x27;, description:&#x27;&#x27;)</span><br></pre></td></tr></table></figure><p>注意：extendedChoice 类型参数需要安装下面插件：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220724173732718.png" alt="image-20220724173732718"></p><h4 id="2-7-2-案例"><a href="#2-7-2-案例" class="headerlink" title="2.7.2 案例"></a>2.7.2 案例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    parameters &#123;</span><br><span class="line">        string(name: &#x27;A&#x27;, defaultValue: &#x27;A-string&#x27;, description: &#x27;this is string&#x27;)</span><br><span class="line">        text(name: &#x27;B&#x27;, defaultValue: &#x27;B-text&#x27;, description: &#x27;this is text&#x27;)</span><br><span class="line">        booleanParam(name: &#x27;C&#x27;, defaultValue: &#x27;true&#x27;, description: &#x27;this is booleanParam&#x27;)</span><br><span class="line">        choice(name:&#x27;D&#x27;, choices:[&#x27;dev&#x27;,&#x27;ops&#x27;,&#x27;master&#x27;], description: &#x27;this is choice&#x27;)</span><br><span class="line">        extendedChoice(name: &#x27;&#x27;, description: &#x27;this is extendedChoice&#x27;, multiSelectDelimiter: &#x27;,&#x27;, quoteValue: false, saveJSONParameterToFile: false, type: &#x27;PT_CHECKBOX&#x27;, value: &#x27;a,b,c,...&#x27;, visibleItemCount: 10)</span><br><span class="line">        password(name: &#x27;E&#x27;, defaultValue: &#x27;E-password&#x27;, description: &#x27;this is password&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Hello&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &#x27;Hello World&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&#x27;myparamters&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &quot;hello $&#123;params.A&#125;&quot;</span><br><span class="line">                echo &quot;hello $&#123;params.B&#125;&quot;</span><br><span class="line">                echo &quot;hello $&#123;params.C&#125;&quot;</span><br><span class="line">                echo &quot;hello $&#123;params.D&#125;&quot;</span><br><span class="line">                echo &quot;hello $&#123;params.E&#125;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数化界面：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220724174328712.png" alt="image-20220724174328712"></p><p>构建结果：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220724174537039.png" alt="image-20220724174537039"></p><h3 id="2-8-triggers"><a href="#2-8-triggers" class="headerlink" title="2.8 triggers"></a>2.8 triggers</h3><h4 id="2-8-1-说明"><a href="#2-8-1-说明" class="headerlink" title="2.8.1 说明"></a>2.8.1 说明</h4><p><code>triggers</code> 为流水线触发方式，一般用于 webhook 集成：</p><ul><li>cron 定时触发：<code>triggers &#123; cron(&#39;H */4 * * 1-5&#39;) &#125;</code></li><li>pollSCM：<code>triggers &#123; pollSCM(&#39;H */4 * * 1-5&#39;) &#125;</code></li></ul><p>⚠注意：<code>pollSCM</code> 触发器仅在 <code>Jenkins 2.22</code> 或更高版本中可用。</p><h4 id="2-8-2-案例"><a href="#2-8-2-案例" class="headerlink" title="2.8.2 案例"></a>2.8.2 案例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    triggers &#123;</span><br><span class="line">        cron(&#x27;H/1 * * * 1-5&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    environment &#123;</span><br><span class="line">        PROJECT = &quot;cms&quot;</span><br><span class="line">        VERSION = &quot;v1.0.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;build&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &quot;$&#123;PROJECT&#125;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post &#123;</span><br><span class="line">        success &#123;</span><br><span class="line">            echo &#x27;build success&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关于计划任务具体详细解释，可以看官方文档——<a href="https://www.jenkins.io/doc/book/pipeline/syntax/">计划任务</a></p></blockquote><h3 id="2-9-input"><a href="#2-9-input" class="headerlink" title="2.9 input"></a>2.9 input</h3><h4 id="2-9-1-说明"><a href="#2-9-1-说明" class="headerlink" title="2.9.1 说明"></a>2.9.1 说明</h4><p><code>input</code> 在流水线中作为交互式应用，应用于 <code>steps &#123;&#125;</code> 前，并在<code>steps &#123;&#125;</code> 执行前暂停。如果 <code>input</code> 为同意继续执行，那将会继续执行 <code>steps &#123;&#125;</code> 部分，否则取消。</p><p>配置选项：</p><ul><li>message：自定义信息（该选项是必须存在的）；</li><li>id：可选 input 标识符（默认为 stage 名称）;</li><li>ok：表单上“确定”按钮（继续&#x2F;取消）；</li><li>submitter：提交者；</li><li>parameters：提示提交者提供的可选参数列表。</li></ul><h4 id="2-9-2-案例"><a href="#2-9-2-案例" class="headerlink" title="2.9.2 案例"></a>2.9.2 案例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Example&#x27;) &#123;</span><br><span class="line">            input &#123;</span><br><span class="line">                message &quot;Should we continue?&quot;</span><br><span class="line">                id &quot;deploy&quot;</span><br><span class="line">                ok &quot;Yes, we should.&quot;</span><br><span class="line">                submitter &quot;alice&quot;</span><br><span class="line">                parameters &#123;</span><br><span class="line">                    string(name: &#x27;PERSON&#x27;, defaultValue: &#x27;Mr Jenkins&#x27;, description: &#x27;my test&#x27;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &quot;Hello, $&#123;PERSON&#125;, nice to meet you.&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220725163538813.png" alt="image-20220725163538813"></p><blockquote><p>点击【Yes, we should.】则继续执行 <code>steps &#123;&#125;</code> 部分；</p><p>点击【Abort】则取消执行该阶段的 <code>steps &#123;&#125;</code> 部分，如下图：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220725163754347.png" alt="image-20220725163754347"></p></blockquote><h3 id="2-10-when"><a href="#2-10-when" class="headerlink" title="2.10 when"></a>2.10 when</h3><h4 id="2-10-1-说明"><a href="#2-10-1-说明" class="headerlink" title="2.10.1 说明"></a>2.10.1 说明</h4><p>这是声明式语法中的条件判断语句，而在脚本式语法中使用的是 <code>if</code> 判断。该指令主要是根据给定的条件来选择是否继续执行 <code>stage 阶段</code>  部分，只有所有条件都返回 <code>true</code> 才能执行阶段，否则跳过该阶段。</p><p>常用选项参数：</p><ul><li>branch：仅适用于多分支管道。<code>when &#123; branch &#39;master&#39; &#125;</code></li><li>environment：当指定环境变量设置为给定值时执行该阶段。<code>when &#123; environment name: &#39;DEPLOY_TO&#39;, value: &#39;production&#39; &#125;</code></li><li>expression：表达式返回结果为 true 时执行该阶段。<code>when &#123; expression &#123; return params.DEBUG_BUILD &#125; &#125;</code> 返回结果必须为布尔型（true&#x2F;null），简单地返回“0”或“false”仍将评估为“true”。</li></ul><p>常用判断参数：</p><ul><li>not：<code>when &#123; not &#123; branch &#39;master&#39; &#125; &#125;</code>，表示：当分支不是 master 的时候，执行 steps。</li><li>allOf：<code>when &#123; allOf &#123; branch &#39;master&#39;; environment name: &#39;DEPLOY_TO&#39;, value: &#39;production&#39; &#125; &#125;</code> 当所有都满足条件时才执行 steps。</li><li>anyOf：<code>when &#123; anyOf &#123; branch &#39;master&#39;; branch &#39;staging&#39; &#125; &#125;</code>，只要有一个条件成立了才会执行 steps。</li></ul><h4 id="2-10-2-案例"><a href="#2-10-2-案例" class="headerlink" title="2.10.2 案例"></a>2.10.2 案例</h4><ul><li><p>单一条件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Example Build&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &#x27;Hello World&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&#x27;Example Deploy&#x27;) &#123;</span><br><span class="line">            when &#123;</span><br><span class="line">                branch &#x27;main&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &#x27;Deploying&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多条件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Example Build&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &#x27;Hello World&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&#x27;Example Deploy&#x27;) &#123;</span><br><span class="line">            when &#123;</span><br><span class="line">                branch &#x27;production&#x27;</span><br><span class="line">                environment name: &#x27;DEPLOY_TO&#x27;, value: &#x27;production&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &#x27;Deploying&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>嵌套条件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Example Build&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &#x27;Hello World&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&#x27;Example Deploy&#x27;) &#123;</span><br><span class="line">            when &#123;</span><br><span class="line">                allOf &#123;</span><br><span class="line">                    branch &#x27;production&#x27;</span><br><span class="line">                    environment name: &#x27;DEPLOY_TO&#x27;, value: &#x27;production&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &#x27;Deploying&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多重条件和嵌套条件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Example Build&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &#x27;Hello World&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&#x27;Example Deploy&#x27;) &#123;</span><br><span class="line">            when &#123;</span><br><span class="line">                branch &#x27;production&#x27;</span><br><span class="line">                anyOf &#123;</span><br><span class="line">                    environment name: &#x27;DEPLOY_TO&#x27;, value: &#x27;production&#x27;</span><br><span class="line">                    environment name: &#x27;DEPLOY_TO&#x27;, value: &#x27;staging&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &#x27;Deploying&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>表达式条件和嵌套条件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Example Build&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &#x27;Hello World&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&#x27;Example Deploy&#x27;) &#123;</span><br><span class="line">            when &#123;</span><br><span class="line">                expression &#123; BRANCH_NAME ==~ /(production|staging)/ &#125;</span><br><span class="line">                anyOf &#123;</span><br><span class="line">                    environment name: &#x27;DEPLOY_TO&#x27;, value: &#x27;production&#x27;</span><br><span class="line">                    environment name: &#x27;DEPLOY_TO&#x27;, value: &#x27;staging&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &#x27;Deploying&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-11-parallel"><a href="#2-11-parallel" class="headerlink" title="2.11 parallel"></a>2.11 parallel</h3><h4 id="2-11-1-说明"><a href="#2-11-1-说明" class="headerlink" title="2.11.1 说明"></a>2.11.1 说明</h4><p>一个阶段必须有且只有一个 <code>steps</code>、<code>stages</code>、<code>parallel</code>或<code>matrix</code>。该部分可应用于自动化测试及多主机并行发布。</p><h4 id="2-11-2-案例"><a href="#2-11-2-案例" class="headerlink" title="2.11.2 案例"></a>2.11.2 案例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">agent any</span><br><span class="line">stages &#123;</span><br><span class="line">// 这个stage只能有一个parallel</span><br><span class="line">stage( &#x27;Parallel stage&#x27;) &#123;</span><br><span class="line">failFast true</span><br><span class="line">parallel &#123;</span><br><span class="line">stage( &#x27;windows&#x27; ) &#123;</span><br><span class="line">steps &#123;</span><br><span class="line">echo &quot;windows&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">stage( &#x27;linux&#x27; ) &#123;</span><br><span class="line">steps &#123;</span><br><span class="line">echo &quot;linux&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 这个stage同样也只能有一个parallel</span><br><span class="line">stage( &#x27;Parallel stage 1&#x27;) &#123;</span><br><span class="line">failFast true</span><br><span class="line">parallel &#123;</span><br><span class="line">stage( &#x27;windows-1&#x27; ) &#123;</span><br><span class="line">steps &#123;</span><br><span class="line">echo &quot;windows-1&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">stage( &#x27;linux-1&#x27; ) &#123;</span><br><span class="line">steps &#123;</span><br><span class="line">echo &quot;linux-1&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220725172122718.png" alt="image-20220725172122718"></p><h3 id="2-12-DSL"><a href="#2-12-DSL" class="headerlink" title="2.12 DSL"></a>2.12 DSL</h3><h4 id="2-12-1-JSON-数据格式解析"><a href="#2-12-1-JSON-数据格式解析" class="headerlink" title="2.12.1 JSON 数据格式解析"></a>2.12.1 JSON 数据格式解析</h4><p>1、所需插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pipeline Utils Steps</span><br></pre></td></tr></table></figure><p>2、流水线配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 插件方式配置</span><br><span class="line">def response = readJSON text: &quot;$&#123;scanResult&#125;&quot;</span><br><span class="line">println(scanResult)</span><br><span class="line"></span><br><span class="line">// 原生方法配置</span><br><span class="line">import groovy .json.*</span><br><span class="line">@NonCPs</span><br><span class="line">def Getson(text)&#123;</span><br><span class="line">def prettyJson = sonoutput.prettyPrint(text)</span><br><span class="line">new sonslurperClassic( ).parseText(prettyson)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-12-2-使用凭据"><a href="#2-12-2-使用凭据" class="headerlink" title="2.12.2 使用凭据"></a>2.12.2 使用凭据</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">withcredentials([string(credentialsId: &quot;xxxxx&quot;， variable: &quot;sonarToken&quot;)])&#123;</span><br><span class="line">println(sonarToken)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体如何生产，可以参考 Jenkins 自带的<code>片段生成器</code></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220725174748559.png" alt="image-20220725174748559"></p><h4 id="2-12-3-代码管理"><a href="#2-12-3-代码管理" class="headerlink" title="2.12.3 代码管理"></a>2.12.3 代码管理</h4><p>1、git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">checkout([$</span><span class="language-bash">class: <span class="string">&#x27;GitsCM&#x27;</span>, branches: [[name: <span class="string">&quot;brnachName&quot;</span>]],</span></span><br><span class="line">doGenerateSubmoduleconfigurations: false,</span><br><span class="line">extensions: [], submoduleCfg: [],</span><br><span class="line">userRemoteConfigs: [[credentialsId: &quot;$&#123;credentialsId&#125;&quot;,</span><br><span class="line">url: &quot;$&#123;srcUrl&#125;&quot;]]])</span><br></pre></td></tr></table></figure><p>2、svn</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">checkout([$</span><span class="language-bash">class: <span class="string">&#x27;subversionscM&#x27;</span> , additionalCredentials: [],</span></span><br><span class="line">filterChangelog: false，ignoreDirPropChanges: false,</span><br><span class="line">locations: [[credentialsId: &quot;$&#123;credentialsId&#125;&quot;,</span><br><span class="line">depthoption: &#x27;infinity&#x27;, ignoreExternalsoption: true,</span><br><span class="line">remote: &quot;$&#123;svnurl]&quot;]]，</span><br><span class="line">workspaceUpdater: [$class: &#x27;checkoutUpdater&#x27;]]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="2-12-4-HTML-报告展示"><a href="#2-12-4-HTML-报告展示" class="headerlink" title="2.12.4 HTML 报告展示"></a>2.12.4 HTML 报告展示</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">publishHTML([allowMissing: false,</span><br><span class="line">alwaysLinkToLastBuild: false,keepAll: true,</span><br><span class="line">reportDir: &#x27;./report/&#x27;,</span><br><span class="line">reportFiles: &quot;a.htm1, b.html&quot;,</span><br><span class="line">reportName: &#x27;TnterfaceTestReport&#x27;,</span><br><span class="line">reportTitles: &#x27;HTML&#x27;])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-12-5-获取管道构建用户"><a href="#2-12-5-获取管道构建用户" class="headerlink" title="2.12.5 获取管道构建用户"></a>2.12.5 获取管道构建用户</h4><p>1、所需插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build user vars</span><br></pre></td></tr></table></figure><p>2、流水线配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">wrap([$</span><span class="language-bash">class: <span class="string">&#x27;BuildUser&#x27;</span>])&#123;</span></span><br><span class="line">echo &quot;full name is $BUILD_USER&quot;</span><br><span class="line">echo &quot;user id is $BUTLD_USER_ID&quot;</span><br><span class="line">echo &quot;user email is $BUILD_USER_EMAIL&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-12-6-使用-HttpRequest-发起请求"><a href="#2-12-6-使用-HttpRequest-发起请求" class="headerlink" title="2.12.6 使用 HttpRequest 发起请求"></a>2.12.6 使用 HttpRequest 发起请求</h4><p>1、所需插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP Request</span><br></pre></td></tr></table></figure><p>2、流水线配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ApiUrl = &quot;http://xxxxxx/api/project_branches/list?project=$&#123;projectName&#125;&quot;</span><br><span class="line">Result = httpRequest authentication : &#x27;xxxxxxxxx &#x27;,</span><br><span class="line">quiet : true,</span><br><span class="line">contentType:&#x27;APPLICATION_JSON&#x27;,</span><br><span class="line">url: &quot;$&#123;ApiUrl&#125;&quot;</span><br></pre></td></tr></table></figure><h4 id="2-12-7-获取-Shell-返回值"><a href="#2-12-7-获取-Shell-返回值" class="headerlink" title="2.12.7 获取 Shell 返回值"></a>2.12.7 获取 Shell 返回值</h4><p>1、无需获取</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line">  // 主要阶段以及子阶段流程</span><br><span class="line">  stages &#123;</span><br><span class="line">    // [ 阶段.shell命令执行测试 ]</span><br><span class="line">    stage (&#x27;代码拉取&#x27;) &#123;</span><br><span class="line">      steps &#123;</span><br><span class="line">        // 最简单的方式</span><br><span class="line">        sh &#x27;whoami &amp;&amp; uname -a&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220728182527543.png" alt="image-20220728182527543"></p><p>2、获取标准输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//第一种</span><br><span class="line">result = sh returnStdout: true ,script: &quot;&lt;shell command&gt;&quot;</span><br><span class="line">result = result.trim()</span><br><span class="line"></span><br><span class="line">//第二种</span><br><span class="line">result = sh(script: &quot;&lt;shell command&gt;&quot;, returnStdout: true).trim()</span><br><span class="line"></span><br><span class="line">//第三种</span><br><span class="line">sh &quot;&lt;shell command&gt; &gt; commandResult&quot;</span><br><span class="line">result = readFile(&#x27;commandResult&#x27;).trim()</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220728182611577.png" alt="image-20220728182611577"></p><p>3、获取执行状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//第一种</span><br><span class="line">result = sh returnStatus: true ,script: &quot;&lt;shell command&gt;&quot;</span><br><span class="line">result = result.trim()</span><br><span class="line"></span><br><span class="line">//第二种</span><br><span class="line">result = sh(script: &quot;&lt;shell command&gt;&quot;, returnStatus: true).trim()</span><br><span class="line"></span><br><span class="line">//第三种</span><br><span class="line">sh &#x27;&lt;shell command&gt;; echo $? &gt; status&#x27;</span><br><span class="line">def r = readFile(&#x27;status&#x27;).trim()</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220728182645235.png" alt="image-20220728182645235"></p><p>&#x3D;&#x3D;trim() 方法说明：&#x3D;&#x3D;</p><p>该方法用于删除字符串的头尾空白符。空白符包括：空格、制表符 tab、换行符等其他空白符等, 在 Jenkins 流水线中非常重要，因为命令执行后总是会在其末尾添加一个换行符。</p><h2 id="三、共享库"><a href="#三、共享库" class="headerlink" title="三、共享库"></a>三、共享库</h2><h3 id="3-1-创建共享库"><a href="#3-1-创建共享库" class="headerlink" title="3.1 创建共享库"></a>3.1 创建共享库</h3><p>1、创建项目仓库</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723150155668.png" alt="image-20220723150155668"></p><p>2、添加目录&#x2F;文件</p><ul><li>点击 <code>Web IDE</code></li></ul><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723151049250.png" alt="image-20220723151049250"></p><ul><li><p>创建目录</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723150944708.png" alt="image-20220723150944708"></p></li><li><p>添加文件</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723152123651.png"></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723152250816.png" alt="image-20220723152250816"></p></li></ul><p>3、将定义好的方法提交到代码仓库</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723152849499.png" alt="image-20220723152849499"></p><h3 id="3-2-加载共享库"><a href="#3-2-加载共享库" class="headerlink" title="3.2 加载共享库"></a>3.2 加载共享库</h3><p>1、流水线脚本加载共享库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 加载共享库，其中jenkinslib要与Jenkins系统配置中保持一致（jenkinslib可自定义），@amin表示共享库所在分支</span><br><span class="line">@Library(&quot;jenkinslib@main&quot;) _</span><br><span class="line">// 导入jenkinsfile.groovy。这里要注意：下面的jenkinsfile()名字必须与你共享库中jenkinsfile.groovy名一致，否则报错</span><br><span class="line">def myjenkinsfile = new org.devops.jenkinsfile()</span><br><span class="line"></span><br><span class="line">// 流水线（主）</span><br><span class="line">pipeline &#123;</span><br><span class="line">agent any</span><br><span class="line">tools &#123;</span><br><span class="line">git &#x27;git&#x27;</span><br><span class="line">&#125;</span><br><span class="line">stages &#123;</span><br><span class="line">stage(&quot;Create Branch&quot;) &#123;</span><br><span class="line">steps &#123;</span><br><span class="line">script &#123;</span><br><span class="line">// 然后就可以调用共享库中的方法了 myjenkinsfile 即为我上面引用的方法（可在上面自定义）</span><br><span class="line">ProjectID = myjenkinsfile.GetProjectID(&quot;$&#123;env.ProjectName&#125;&quot;)</span><br><span class="line">myjenkinsfile.CreateBranch(ProjectID, &quot;$&#123;env.NewBranchName&#125;&quot;, &quot;$&#123;env.BaseBranchName&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、同样将流水线脚本也进行 Git 版本管理</p><blockquote><p>这样的话便于管理 Jenkinfile 及共享库</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723153913871.png" alt="image-20220723153913871"></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723162121271.png" alt="image-20220723162121271"></p><h3 id="3-3-Jenkins-配置"><a href="#3-3-Jenkins-配置" class="headerlink" title="3.3 Jenkins 配置"></a>3.3 Jenkins 配置</h3><p>1、Jenkins 流水线配置</p><p>因为我们的流水线脚本进行了 Git 版本管理，所以你可以在 Jenkins 流水线配置中配置 URL 即可。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723155806926.png" alt="image-20220723155806926"></p><p>2、Jenkins 系统配置</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723161609360.png" alt="image-20220723161609360"></p><h3 id="3-4-Jenkins-构建"><a href="#3-4-Jenkins-构建" class="headerlink" title="3.4 Jenkins 构建"></a>3.4 Jenkins 构建</h3><p>以上都配置好之后，接下来就开始构建了。</p><p>1、Jenkins 构建</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723190934794.png" alt="image-20220723190934794"></p><p>2、Gitlab 查看是否构建成功</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220723190856525.png" alt="image-20220723190856525"></p><p>&#x3D;&#x3D;至此，已实现 Jenkins 如何调用 Gitlab API 及 Jenkins 共享库的最终应用。&#x3D;&#x3D;</p><h3 id="3-5-扩展"><a href="#3-5-扩展" class="headerlink" title="3.5 扩展"></a>3.5 扩展</h3><blockquote><p>共享库加载扩展。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载testlib共享库</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">共享库名可自定义，但必须和Jenkins系统配置中配置的共享库名保持一致</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为Jenkins配置了共享库的git地址，如果不一致的话，在加载共享库时就会找不到共享库</span></span><br><span class="line">@Library(&#x27;testlib&#x27;) _</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载testlib共享库的1.0版本</span></span><br><span class="line">@Library(&#x27;testlib@1.0&#x27;) _</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载多个共享库</span></span><br><span class="line">@Library([&#x27;testlib&#x27;, &#x27;testlib@1.0&#x27;]) _</span><br></pre></td></tr></table></figure><h2 id="四、邮件配置"><a href="#四、邮件配置" class="headerlink" title="四、邮件配置"></a>四、邮件配置</h2><h3 id="4-1-Jenkins-配置"><a href="#4-1-Jenkins-配置" class="headerlink" title="4.1 Jenkins 配置"></a>4.1 Jenkins 配置</h3><p>1、安装邮件插件</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220726101813745.png" alt="image-20220726101813745"></p><p>2、服务器地址及相关端口</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220726103143647.png" alt="image-20220726103143647"></p><p>3、系统配置ZRSanqy@123</p><blockquote><p>此处我使用163邮箱来演示。</p></blockquote><ul><li><p>先查看163邮箱的服务器地址</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220726102038591.png" alt="image-20220726102038591"></p></li><li><p>系统配置–&gt;E-mail Notification</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220726104650219.png" alt="image-20220726104650219"></p></li><li><p>注意：上图中的 <code>Use SMTP Authentication</code> 邮件地址必须与下列地址保持一致。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220726105057878.png" alt="image-20220726105057878"></p></li></ul><h3 id="4-2-Jenkinsfile-配置"><a href="#4-2-Jenkinsfile-配置" class="headerlink" title="4.2 Jenkinsfile 配置"></a>4.2 Jenkinsfile 配置</h3><p>保留…后续补充</p><h3 id="4-3-邮件内容参考模板"><a href="#4-3-邮件内容参考模板" class="headerlink" title="4.3 邮件内容参考模板"></a>4.3 邮件内容参考模板</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>$&#123;ENV, var=&quot;JOB_NAME&quot;&#125;-第$&#123;BUILD_NUMBER&#125;次构建日志<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">leftmargin</span>=<span class="string">&quot;8&quot;</span> <span class="attr">marginwidth</span>=<span class="string">&quot;0&quot;</span> <span class="attr">topmargin</span>=<span class="string">&quot;8&quot;</span> <span class="attr">marginheight</span>=<span class="string">&quot;4&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">offset</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">&quot;95%&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;0&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span>  <span class="attr">style</span>=<span class="string">&quot;font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            本邮件由系统自动发出，无需回复！<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">            各位同事，大家好，以下为$&#123;PROJECT_NAME &#125;项目构建信息<span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;#CC0000&quot;</span>&gt;</span>构建结果 - $&#123;BUILD_STATUS&#125;<span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;#0B610B&quot;</span>&gt;</span>构建信息<span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">hr</span> <span class="attr">size</span>=<span class="string">&quot;2&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>项目名称 ： $&#123;PROJECT_NAME&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>构建编号 ： 第$&#123;BUILD_NUMBER&#125;次构建<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>触发原因： $&#123;CAUSE&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>构建状态： $&#123;BUILD_STATUS&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>构建日志： <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;$&#123;BUILD_URL&#125;console&quot;</span>&gt;</span>$&#123;BUILD_URL&#125;console<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>构建  Url ： <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;$&#123;BUILD_URL&#125;&quot;</span>&gt;</span>$&#123;BUILD_URL&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>工作目录 ： <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;$&#123;PROJECT_URL&#125;ws&quot;</span>&gt;</span>$&#123;PROJECT_URL&#125;ws<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>项目  Url ： <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;$&#123;PROJECT_URL&#125;&quot;</span>&gt;</span>$&#123;PROJECT_URL&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>报告  Url ： <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;$&#123;PROJECT_URL&#125;&quot;</span>&gt;</span>$&#123;PROJECT_URL&#125;allure<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;#0B610B&quot;</span>&gt;</span>失败用例<span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">size</span>=<span class="string">&quot;2&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> /&gt;</span></span><br><span class="line">$FAILED_TESTS<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;#0B610B&quot;</span>&gt;</span>最近提交(#$SVN_REVISION)<span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">size</span>=<span class="string">&quot;2&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">$&#123;CHANGES_SINCE_LAST_SUCCESS, reverse=true, format=&quot;%c&quot;, changesFormat=&quot;<span class="tag">&lt;<span class="name">li</span>&gt;</span>%d [%a] %m<span class="tag">&lt;/<span class="name">li</span>&gt;</span>&quot;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">详细提交: <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;$&#123;PROJECT_URL&#125;changes&quot;</span>&gt;</span>$&#123;PROJECT_URL&#125;changes<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="五、项目构建"><a href="#五、项目构建" class="headerlink" title="五、项目构建"></a>五、项目构建</h2><h3 id="5-1-前端项目"><a href="#5-1-前端项目" class="headerlink" title="5.1 前端项目"></a>5.1 前端项目</h3><h4 id="5-1-1-npm"><a href="#5-1-1-npm" class="headerlink" title="5.1.1 npm"></a>5.1.1 npm</h4><p>1、工具下载地址</p><p><a href="https://nodejs.org/en/download/">官方下载地址</a></p><p>2、常用命令</p><ul><li>npm install &lt;模块名&gt; -g     包安装到全局；</li><li>npm list   查看当前已经安装的包；</li><li>npm config set registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a>   设置淘宝源；</li><li>npm config set cache “&#x2F;opt&#x2F;npmcache&#x2F;“   设置缓存路径。</li></ul><h4 id="5-1-2-yarn"><a href="#5-1-2-yarn" class="headerlink" title="5.1.2 yarn"></a>5.1.2 yarn</h4><p>facebook 取代了 npm 的包管理工具，速度快、yarn 缓存包无需重复下载，安装速度快。</p><p>1、安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn</span><br><span class="line">yarn info</span><br></pre></td></tr></table></figure><p>2、常用命令</p><ul><li>yarn</li><li>yarn install</li><li>yarn config set cache-folder “&#x2F;opt&#x2F;yarncache”</li></ul><h3 id="5-2-后端项目"><a href="#5-2-后端项目" class="headerlink" title="5.2 后端项目"></a>5.2 后端项目</h3><h4 id="5-2-1-mavn"><a href="#5-2-1-mavn" class="headerlink" title="5.2.1 mavn"></a>5.2.1 mavn</h4><p>1、工具下载地址</p><p><a href="http://maven.apache.org/download.cgi">官方下载地址</a></p><p>2、常用命令</p><ul><li>mvn clean  清理构建目录；</li><li>mvn clean package  打包；</li><li>mvn clean install  打包部署；</li><li>mvn clean test  单元测试；</li><li>mvn clean package -f ..&#x2F;pom.xml   -f 指定 pom 文件位置；</li><li>mvn clean package -DskipTests   跳过单元测试；</li><li>mvn clean package -Dmaven.test.skip&#x3D;true   跳过单元测试；</li><li>mvn deploy  发布包到制品库。</li></ul><h4 id="5-2-2-gradle"><a href="#5-2-2-gradle" class="headerlink" title="5.2.2 gradle"></a>5.2.2 gradle</h4><p>gradle 基于 groovy，具有灵活强大的构建系统，能帮我们构建更复杂的项目。</p><p>1、工具下载地址</p><p><a href="https://gradle.org/releases/">官方下载地址</a></p><p>2、常用命令</p><ul><li>gradle build  构建项目；</li><li>gradle build -x test  跳过单元测试；</li><li>gradle clean  清空构建目录。</li></ul><h4 id="5-2-3-ant"><a href="#5-2-3-ant" class="headerlink" title="5.2.3 ant"></a>5.2.3 ant</h4><p>1、工具下载地址</p><p><a href="https://ant.apache.org/bindownload.cgi">官方下载地址</a></p><p>2、常用命令</p><ul><li>ant   构建；</li><li>ant -f ..&#x2F;build.xml   -f 指定 xml 文件。</li></ul><h3 id="5-3-Go-项目"><a href="#5-3-Go-项目" class="headerlink" title="5.3 Go 项目"></a>5.3 Go 项目</h3><p>1、工具下载地址</p><p><a href="https://studygolang.com/dl">官方下载地址</a></p><p>2、常用命令</p><ul><li>go build   构建源文件；</li><li>go clean  清空构建目录；</li><li>go doc   生成 godoc 文档；</li><li>go install   编译并安装指定的代码包；</li><li>go fmt   代码格式化；</li><li>go get   获取一个包；</li><li>go run   运行一个 go 文件；</li><li>go test   运行测试。</li></ul><h3 id="5-4-综合案例"><a href="#5-4-综合案例" class="headerlink" title="5.4 综合案例"></a>5.4 综合案例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">// git拉取代码</span><br><span class="line">def GetCode(SrcType, BranchName, GitHttpURL) &#123;</span><br><span class="line">    if (SrcType == &quot;git&quot;) &#123;</span><br><span class="line">        println(&quot;下载代码 --&gt; 分支： $&#123;BranchName&#125;&quot;)</span><br><span class="line">        checkout([$class: &#x27;GitSCM&#x27;,</span><br><span class="line">            branches: [[name: &quot;$&#123;BranchName&#125;&quot;]],</span><br><span class="line">            extensions: [],</span><br><span class="line">            userRemoteConfigs: [[url: &quot;$&#123;GitHttpURL&#125;&quot;, credentialsId: &#x27;git-pull&#x27;,]]</span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 构建类型</span><br><span class="line">def Build(BuildTools, BuildType) &#123;</span><br><span class="line">    switch(BuildType) &#123;</span><br><span class="line">        case &quot;maven&quot;:</span><br><span class="line">            sh &quot;$&#123;BuildTools[&quot;maven&quot;]&#125;/bin/mvn clean install -pl game-hall -am -Dmaven.test.skip=true -P test&quot;</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">        case &quot;gradle&quot;:</span><br><span class="line">            sh &quot;$&#123;BuildTools[&quot;gradle&quot;]&#125;/bin/gradle build -x test&quot;</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">        case &quot;npm&quot;:</span><br><span class="line">            sh &quot;&quot;&quot;$&#123;BuildTools[&quot;web&quot;]&#125;/bin/npm install &amp;&amp; $&#123;BuildTools[&quot;web&quot;]&#125;/bin/npm run build&quot;&quot;&quot;</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">        case &quot;golang&quot;:</span><br><span class="line">            sh &quot;$&#123;BuildTools[&quot;golang&quot;]&#125;/bin/go build demo.go&quot;    </span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">        default :</span><br><span class="line">            println(&quot;BuildType ==&gt; [maven|gradle|web|golang]&quot;)</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 变量定义</span><br><span class="line">// 构建工具变量（数组）</span><br><span class="line">def BuildTools = [&quot;maven&quot;: &quot;/opt/work/apache-maven-3.8.5&quot;, </span><br><span class="line">                &quot;gradle&quot;: &quot;/opt/work/gradle-6.8.3&quot;,</span><br><span class="line">                &quot;npm&quot;: &quot;/opt/work/node-v16.15.1-linux-x64&quot;,</span><br><span class="line">                &quot;yarn&quot;: &quot;/opt/work/yarn-xxx&quot;,</span><br><span class="line">                &quot;golang&quot;: &quot;/opt/work/go&quot;]</span><br><span class="line">// 构建相关变量（字符串）</span><br><span class="line">String BranchName = &quot;$&#123;env.BranchName&#125;&quot;</span><br><span class="line">String GitHttpURL = &quot;$&#123;env.GitHttpURL&#125;&quot;</span><br><span class="line">String BuildType = &quot;$&#123;env.BuildType&#125;&quot;</span><br><span class="line">String SrcType = &quot;$&#123;env.SrcType&#125;&quot;</span><br><span class="line"></span><br><span class="line">// 流水线</span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    options &#123;</span><br><span class="line">        skipDefaultCheckout true</span><br><span class="line">    &#125;</span><br><span class="line">    parameters &#123;</span><br><span class="line">        choice(name: &#x27;GitHttpURL&#x27;,</span><br><span class="line">                            choices: [&#x27;ssh://git@192.168.56.133:2022/root/tq.git&#x27;],</span><br><span class="line">                            description: &#x27;⚠ 选择项目URL&#x27;,)</span><br><span class="line">        gitParameter (name: &#x27;BranchName&#x27;,</span><br><span class="line">                        type: &#x27;PT_BRANCH&#x27;,</span><br><span class="line">                        branchFilter: &#x27;origin/(.*)&#x27;,</span><br><span class="line">                        defaultValue: &#x27;main&#x27;,</span><br><span class="line">                        selectedValue: &#x27;DEFAULT&#x27;,</span><br><span class="line">                        sortMode: &#x27;DESCENDING_SMART&#x27;,</span><br><span class="line">                        description: &#x27;⚠ 选择构建分支或标签&#x27;)</span><br><span class="line">        choice(name: &#x27;SrcType&#x27;,</span><br><span class="line">                            choices: [&#x27;git&#x27;, &#x27;svn&#x27;],</span><br><span class="line">                            description: &#x27;⚠ 选择代码版本控制工具&#x27;,)</span><br><span class="line">        choice(name: &#x27;BuildType&#x27;,</span><br><span class="line">                            choices: [&#x27;maven&#x27;, &#x27;gradle&#x27;, &#x27;npm&#x27;, &#x27;yarn&#x27;, &#x27;goloang&#x27;],</span><br><span class="line">                            description: &#x27;⚠ 选择对应构建工具&#x27;,)</span><br><span class="line">        choice(name: &#x27;SEV&#x27;,</span><br><span class="line">                            choices: [&#x27;192.168.56.133&#x27;],</span><br><span class="line">                            description: &#x27;⚠ 选择测试环境内网服务器&#x27;,)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&quot;GetCode&quot;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script &#123;</span><br><span class="line">                    GetCode(SrcType, BranchName, GitHttpURL)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&quot;Build&quot;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script &#123;</span><br><span class="line">                    Build(BuildTools, BuildType)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，上面的案例也可写入共享库类，具体方法查看文档<code>第三节</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">// 加载共享库</span><br><span class="line">@Library([&#x27;gitscmlib@main&#x27;, &#x27;mytoolslib@main&#x27;]) _</span><br><span class="line">def Mygit = new org.devops.gitscm()</span><br><span class="line">def Mytool = new org.devops.mytools()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 变量定义</span><br><span class="line">// 构建工具变量（数组）</span><br><span class="line">def BuildTools = [&quot;maven&quot;: &quot;/opt/work/apache-maven-3.8.5&quot;, </span><br><span class="line">                &quot;gradle&quot;: &quot;/opt/work/gradle-6.8.3&quot;,</span><br><span class="line">                &quot;npm&quot;: &quot;/opt/work/node-v16.15.1-linux-x64&quot;,</span><br><span class="line">                &quot;yarn&quot;: &quot;/opt/work/yarn-xxx&quot;,</span><br><span class="line">                &quot;golang&quot;: &quot;/opt/work/go&quot;]</span><br><span class="line">// 构建相关变量（字符串）</span><br><span class="line">String BranchName = &quot;$&#123;env.BranchName&#125;&quot;</span><br><span class="line">String GitHttpURL = &quot;$&#123;env.GitHttpURL&#125;&quot;</span><br><span class="line">String BuildType = &quot;$&#123;env.BuildType&#125;&quot;</span><br><span class="line">String SrcType = &quot;$&#123;env.SrcType&#125;&quot;</span><br><span class="line"></span><br><span class="line">// 流水线</span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    options &#123;</span><br><span class="line">        skipDefaultCheckout true</span><br><span class="line">    &#125;</span><br><span class="line">    parameters &#123;</span><br><span class="line">        choice(name: &#x27;GitHttpURL&#x27;,</span><br><span class="line">                            choices: [&#x27;ssh://git@192.168.56.133:2022/root/tq.git&#x27;],</span><br><span class="line">                            description: &#x27;⚠ 选择项目URL&#x27;,)</span><br><span class="line">        gitParameter (name: &#x27;BranchName&#x27;,</span><br><span class="line">                        type: &#x27;PT_BRANCH&#x27;,</span><br><span class="line">                        branchFilter: &#x27;origin/(.*)&#x27;,</span><br><span class="line">                        defaultValue: &#x27;main&#x27;,</span><br><span class="line">                        selectedValue: &#x27;DEFAULT&#x27;,</span><br><span class="line">                        sortMode: &#x27;DESCENDING_SMART&#x27;,</span><br><span class="line">                        description: &#x27;⚠ 选择构建分支或标签&#x27;)</span><br><span class="line">        choice(name: &#x27;SrcType&#x27;,</span><br><span class="line">                            choices: [&#x27;git&#x27;, &#x27;svn&#x27;],</span><br><span class="line">                            description: &#x27;⚠ 选择代码版本控制工具&#x27;,)</span><br><span class="line">        choice(name: &#x27;BuildType&#x27;,</span><br><span class="line">                            choices: [&#x27;maven&#x27;, &#x27;gradle&#x27;, &#x27;npm&#x27;, &#x27;yarn&#x27;, &#x27;goloang&#x27;],</span><br><span class="line">                            description: &#x27;⚠ 选择对应构建工具&#x27;,)</span><br><span class="line">        choice(name: &#x27;SEV&#x27;,</span><br><span class="line">                            choices: [&#x27;192.168.56.133&#x27;],</span><br><span class="line">                            description: &#x27;⚠ 选择测试环境内网服务器&#x27;,)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&quot;GetCode&quot;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script &#123;</span><br><span class="line">                    Mygit.GetCode(SrcType, BranchName, GitHttpURL)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&quot;Build&quot;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script &#123;</span><br><span class="line">                    Mytool.Build(BuildTools, BuildType)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面构建时，项目名称是写死的，如何获取项目名称呢？两种方法：调用 Gitlab API、参数化选项手写。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">// git拉取代码</span><br><span class="line">def GetCode(SrcType, BranchName, GitHttpURL) &#123;</span><br><span class="line">    if (SrcType == &quot;git&quot;) &#123;</span><br><span class="line">        println(&quot;下载代码 --&gt; 分支： $&#123;BranchName&#125;&quot;)</span><br><span class="line">        checkout([$class: &#x27;GitSCM&#x27;,</span><br><span class="line">            branches: [[name: &quot;$&#123;BranchName&#125;&quot;]],</span><br><span class="line">            extensions: [],</span><br><span class="line">            userRemoteConfigs: [[url: &quot;$&#123;GitHttpURL&#125;&quot;, credentialsId: &#x27;git-pull&#x27;,]]</span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 构建类型</span><br><span class="line">def Build(BuildTools, BuildType, BuildProject) &#123;</span><br><span class="line">    switch(BuildType) &#123;</span><br><span class="line">        case &quot;maven&quot;:</span><br><span class="line">        // 这里可以加个if判断语句，来选择是构建所有包还是独立包</span><br><span class="line">            sh &quot;$&#123;BuildTools[&quot;maven&quot;]&#125;/bin/mvn clean install -pl $&#123;BuildProject&#125; -am -Dmaven.test.skip=true -P test&quot;</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">        case &quot;gradle&quot;:</span><br><span class="line">            sh &quot;$&#123;BuildTools[&quot;gradle&quot;]&#125;/bin/gradle build -x test&quot;</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">        case &quot;npm&quot;:</span><br><span class="line">            sh &quot;&quot;&quot;$&#123;BuildTools[&quot;web&quot;]&#125;/bin/npm install &amp;&amp; $&#123;BuildTools[&quot;web&quot;]&#125;/bin/npm run build&quot;&quot;&quot;</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">        case &quot;golang&quot;:</span><br><span class="line">            sh &quot;$&#123;BuildTools[&quot;golang&quot;]&#125;/bin/go build demo.go&quot;    </span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">        default :</span><br><span class="line">            println(&quot;BuildType ==&gt; [maven|gradle|web|golang]&quot;)</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 请求地址</span><br><span class="line">def HttpReq(ApiUrl, Method) &#123;</span><br><span class="line">    GitlabAPI = &quot;http://192.168.56.133/api/v4&quot;</span><br><span class="line">    withCredentials([string(credentialsId: &#x27;gitlab-create-branch&#x27;, variable: &#x27;Gitlab_Token&#x27;)]) &#123;</span><br><span class="line">        response = sh returnStdout: true, script: &quot;&quot;&quot;</span><br><span class="line">            curl --location --request $&#123;Method&#125; \</span><br><span class="line">                &quot;$&#123;GitlabAPI&#125;/$&#123;ApiUrl&#125;&quot; \</span><br><span class="line">                --header &quot;PRIVATE-TOKEN: $&#123;Gitlab_Token&#125;&quot;</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    return response</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取项目名</span><br><span class="line">def AllListRepositoryTree() &#123;</span><br><span class="line">    ApiUrl = &quot;projects/3/repository/tree&quot;</span><br><span class="line">    Method = &quot;GET&quot;</span><br><span class="line">    result = HttpReq(ApiUrl, Method)</span><br><span class="line">    result = readJSON text: result</span><br><span class="line">    return result[9][&quot;name&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 变量定义</span><br><span class="line">// 构建工具变量（数组）</span><br><span class="line">def BuildTools = [&quot;maven&quot;: &quot;/opt/work/apache-maven-3.8.5&quot;, </span><br><span class="line">                &quot;gradle&quot;: &quot;/opt/work/gradle-6.8.3&quot;,</span><br><span class="line">                &quot;npm&quot;: &quot;/opt/work/node-v16.15.1-linux-x64&quot;,</span><br><span class="line">                &quot;yarn&quot;: &quot;/opt/work/yarn-xxx&quot;,</span><br><span class="line">                &quot;golang&quot;: &quot;/opt/work/go&quot;]</span><br><span class="line">// 构建相关变量（字符串）</span><br><span class="line">String BranchName = &quot;$&#123;env.BranchName&#125;&quot;</span><br><span class="line">String GitHttpURL = &quot;$&#123;env.GitHttpURL&#125;&quot;</span><br><span class="line">String BuildType = &quot;$&#123;env.BuildType&#125;&quot;</span><br><span class="line">String SrcType = &quot;$&#123;env.SrcType&#125;&quot;</span><br><span class="line"></span><br><span class="line">// 流水线</span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    options &#123;</span><br><span class="line">        skipDefaultCheckout true</span><br><span class="line">    &#125;</span><br><span class="line">    parameters &#123;</span><br><span class="line">        choice(name: &#x27;GitHttpURL&#x27;,</span><br><span class="line">                            choices: [&#x27;ssh://git@192.168.56.133:2022/root/tq.git&#x27;],</span><br><span class="line">                            description: &#x27;⚠ 选择项目URL&#x27;,)</span><br><span class="line">        gitParameter (name: &#x27;BranchName&#x27;,</span><br><span class="line">                        type: &#x27;PT_BRANCH&#x27;,</span><br><span class="line">                        branchFilter: &#x27;origin/(.*)&#x27;,</span><br><span class="line">                        defaultValue: &#x27;main&#x27;,</span><br><span class="line">                        selectedValue: &#x27;DEFAULT&#x27;,</span><br><span class="line">                        sortMode: &#x27;DESCENDING_SMART&#x27;,</span><br><span class="line">                        description: &#x27;⚠ 选择构建分支或标签&#x27;)</span><br><span class="line">        choice(name: &#x27;SrcType&#x27;,</span><br><span class="line">                            choices: [&#x27;git&#x27;, &#x27;svn&#x27;],</span><br><span class="line">                            description: &#x27;⚠ 选择代码版本控制工具&#x27;,)</span><br><span class="line">        choice(name: &#x27;BuildType&#x27;,</span><br><span class="line">                            choices: [&#x27;maven&#x27;, &#x27;gradle&#x27;, &#x27;npm&#x27;, &#x27;yarn&#x27;, &#x27;goloang&#x27;],</span><br><span class="line">                            description: &#x27;⚠ 选择对应构建工具&#x27;,)</span><br><span class="line">        choice(name: &#x27;SEV&#x27;,</span><br><span class="line">                            choices: [&#x27;192.168.56.133&#x27;],</span><br><span class="line">                            description: &#x27;⚠ 选择测试环境内网服务器&#x27;,)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&quot;GetCode&quot;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script &#123;</span><br><span class="line">                    GetCode(SrcType, BranchName, GitHttpURL)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&quot;Build&quot;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script &#123;</span><br><span class="line">                    BuildProject = AllListRepositoryTree()</span><br><span class="line">                    Build(BuildTools, BuildType, &quot;$&#123;BuildProject&#125;&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，上面的流水线只有获取项目和构建项目的步骤，实际生产中还有发布、发布后操作环节，这里不再演示。</p><h3 id="5-5-WebHook"><a href="#5-5-WebHook" class="headerlink" title="5.5 WebHook"></a>5.5 WebHook</h3><blockquote><p>整体流程：</p></blockquote><ul><li>用户提交代码到 Git；</li><li>当代码提交到 Git 时根据你定义的规则自动触发构建。</li></ul><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220728142557050.png" alt="image-20220728142557050"></p><p>1、Jenkins 创建工程</p><blockquote><p>创建名为 <code>webhook-test</code> 的流水线工程。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220728103637104.png" alt="image-20220728103637104"></p><p>2、安装 WebHook 插件</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220728104314245.png" alt="image-20220728104314245"></p><p>3、生成触发 WebHook URL</p><blockquote><p>在 Jenkins 对应的工程项目配置中生成：</p><p>jenkins-webhook-test</p></blockquote><p><a href="http://192.168.56.131:8080/generic-webhook-trigger/invoke?token=jenkins-webhook-test">http://192.168.56.131:8080/generic-webhook-trigger/invoke?token=jenkins-webhook-test</a></p><p>正则匹配：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只有满足匹配master或production分支的情况下，且git项目名满足匹配字母或-大于1，且触发者（代码提交者）不能是rab，才能触发构建。</span></span><br><span class="line">表达式：refs/heads/(master|production)_[a-zA-Z0-9-]&#123;1&#125;_(?|rab)</span><br><span class="line">针对哪些变量：$ref_$project_$username</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">feiji：http://39.97.189.19:3031/</span><br><span class="line">paopaolong：http://39.97.189.19:3032/</span><br><span class="line">xiaoxiaole：http://39.97.189.19:3033/</span><br><span class="line">zuma：http://39.97.189.19:3034/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4、Gitlab 配置</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220728111656807.png" alt="image-20220728111656807"></p><blockquote><p>JENKINS_URL 换成你的 Jenkins IP 地址</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220728113442233.png" alt="image-20220728113442233"></p><blockquote><p>测试这个 URL 是否可用</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220728120755915.png" alt="image-20220728120755915"></p><blockquote><p>看输出结果</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220728120654191.png" alt="image-20220728120654191"></p><blockquote><p>如果报 <code>Url is blocked: Requests to the local network are not allowed</code></p><p>配置一下 Gitlab 即可。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220728121033555.png" alt="image-20220728121033555"></p><h2 id="六、SonarQube"><a href="#六、SonarQube" class="headerlink" title="六、SonarQube"></a>六、SonarQube</h2><blockquote><p>该工具一般部署于 Jenkins 服务上。</p></blockquote><h3 id="6-1-工作原理"><a href="#6-1-工作原理" class="headerlink" title="6.1 工作原理"></a>6.1 工作原理</h3><p><code>SonarQube</code> 是一种自动代码审查工具，可检测代码中的错误、漏洞等，其可与现有 CICD 工具实现集成，从而实现跨项目分支和拉取请求的持续代码检测，其工作流程如下图所示。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/dev-cycle.png" alt="SonarQube Instance Components"></p><h3 id="6-2-安装部署"><a href="#6-2-安装部署" class="headerlink" title="6.2 安装部署"></a>6.2 安装部署</h3><p>1、创建数据目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/sonarqube/&#123;conf,extensions,logs,data&#125;</span><br></pre></td></tr></table></figure><p>2、启动临时容器</p><blockquote><p>copy lib 文件</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动临时容器</span></span><br><span class="line">docker run -itd \</span><br><span class="line">       --user root \</span><br><span class="line">       --privileged=true  \</span><br><span class="line">       --name=temp \</span><br><span class="line">       --restart=always \</span><br><span class="line">       sonarqube:8.9.0-community</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">copy lib</span></span><br><span class="line">cd /data/sonarqube/</span><br><span class="line">docker cp temp:/opt/sonarqube/lib ./</span><br></pre></td></tr></table></figure><p>3、启动最终容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除临时容器</span></span><br><span class="line">docker stop temp</span><br><span class="line">docker rm temp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行新容器</span></span><br><span class="line">docker run -itd \</span><br><span class="line">       --user root \</span><br><span class="line">       --privileged=true  \</span><br><span class="line">       --name=sonarqube \</span><br><span class="line">       --restart=always \</span><br><span class="line">       -p 9000:9000 \</span><br><span class="line">       -v /data/sonarqube/conf:/opt/sonarqube/conf \</span><br><span class="line">       -v /data/sonarqube/extensions:/opt/sonarqube/extensions \</span><br><span class="line">       -v /data/sonarqube/logs:/opt/sonarqube/logs \</span><br><span class="line">       -v /data/sonarqube/data:/opt/sonarqube/data \</span><br><span class="line">       -v /data/sonarqube/lib:/opt/sonarqube/lib \</span><br><span class="line">       -v /etc/localtime:/etc/localtime \</span><br><span class="line">       sonarqube:8.9.0-community</span><br></pre></td></tr></table></figure><p>4、登录验证</p><blockquote><p><a href="http://ip:9000/">http://ip:9000/</a></p><p>初始用户：admin</p><p>初始密码：admin</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220727111525551.png" alt="image-20220727111525551"></p><blockquote><p>修改初始密码</p><p>新密码为：zhurs@123</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220727111641308.png" alt="image-20220727111641308"></p><blockquote><p>系统界面</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220727111754461.png" alt="image-20220727111754461"></p><h3 id="6-3-基础配置"><a href="#6-3-基础配置" class="headerlink" title="6.3 基础配置"></a>6.3 基础配置</h3><h4 id="6-3-1-安装插件"><a href="#6-3-1-安装插件" class="headerlink" title="6.3.1 安装插件"></a>6.3.1 安装插件</h4><p>1、在线安装</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220727112240587.png" alt="image-20220727112240587"></p><blockquote><p>此时你发现并没有 <code>Install</code> 安装按钮，此时你需要点击 <code>I understand the risk</code>（即我接收安装风险），此时你就会看到 <code>Install</code> 安装按钮了。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220727112709859.png" alt="image-20220727112709859"></p><blockquote><p>这是一个中文插件，安装完成后重启 SonarQube 生效。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart sonarqube</span><br></pre></td></tr></table></figure><blockquote><p>再次验证插件是否被安装（web端是否正常显示中文）</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220727112954126.png" alt="image-20220727112954126"></p><p>&#x3D;&#x3D;如何卸载插件？&#x3D;&#x3D;</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220727113304523.png" alt="image-20220727113304523"></p><p>2、离线安装</p><ul><li><p>插件下载地址：<a href="https://update.sonarsource.org/">传送门</a></p></li><li><p>插件版本与 <code>sonarqube</code> 版本兼容对照表：<a href="https://docs.sonarqube.org/latest/instance-administration/plugin-version-matrix/">传送门</a></p></li><li><p>上传插件至 <code>sonarqube</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">插件上传至该目录下</span></span><br><span class="line">cd /data/sonarqube/extensions/downloads</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wget或本地下载后上传</span></span><br><span class="line">wget https://github.com/xuhuisheng/sonar-l10n-zh/releases/download/sonar-l10n-zh-plugin-9.5/sonar-l10n-zh-plugin-9.5.jar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赋予可执行权限</span></span><br><span class="line">chmod +x sonar-l10n-zh-plugin-9.5.jar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启 sonarqube 生效</span></span><br><span class="line">doker restart sonarqube</span><br></pre></td></tr></table></figure></li></ul><p>&#x3D;&#x3D;常用语言插件安装&#x3D;&#x3D;</p><ul><li>Java</li></ul><h4 id="6-3-2-设置强制登录"><a href="#6-3-2-设置强制登录" class="headerlink" title="6.3.2 设置强制登录"></a>6.3.2 设置强制登录</h4><p>默认所有项目都是可以查看的，但在实际生产中是不被允许的，需要设置为私有的。并且我们需要设置用户强制，只有登录后才能查看。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220727114945573.png" alt="image-20220727114945573"></p><h3 id="6-4-Scanner-扫描"><a href="#6-4-Scanner-扫描" class="headerlink" title="6.4 Scanner 扫描"></a>6.4 Scanner 扫描</h3><blockquote><p>部署于要扫描项目的服务器上。</p></blockquote><h4 id="6-4-1-安装部署"><a href="#6-4-1-安装部署" class="headerlink" title="6.4.1 安装部署"></a>6.4.1 安装部署</h4><p>1、下载二进制包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-4.6.0.2311-linux.zip</span><br></pre></td></tr></table></figure><p>2、配置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">unzip sonar-scanner-cli-4.6.0.2311-linux.zip</span><br><span class="line">mv sonar-scanner-4.6.0.2311-linux/ /opt/ &amp;&amp; mv /opt/sonar-scanner-4.6.0.2311-linux/ /opt/scanner</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">环境变量</span></span><br><span class="line">vim /etc/profile.d/scanner.sh</span><br><span class="line">export PATH=/opt/scanner/bin:$PATH</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重载变量</span></span><br><span class="line">source /etc/profile</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看版本（scanner的JDK版本为11）</span></span><br><span class="line">[root@jenkins-master opt]# sonar-scanner -v</span><br><span class="line">INFO: Scanner configuration file: /opt/scanner/conf/sonar-scanner.properties</span><br><span class="line">INFO: Project root configuration file: NONE</span><br><span class="line">INFO: SonarScanner 4.6.0.2311</span><br><span class="line">INFO: Java 11.0.3 AdoptOpenJDK (64-bit)</span><br><span class="line">INFO: Linux 3.10.0-1160.el7.x86_64 amd64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">而我的服务器安装的是1.8版本的（两者需统一下）为什么与本地不一致呢？因为sonar-scanner中默认集成了jre环境</span></span><br><span class="line">[root@jenkins-master opt]# java -version</span><br><span class="line">java version &quot;1.8.0_202&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_202-b08)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.202-b08, mixed mode)</span><br></pre></td></tr></table></figure><p>3、修改 scanner 的JDK版本</p><blockquote><p>一般默认即可</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /opt/scanner/bin/sonar-scanner</span><br></pre></td></tr></table></figure><ul><li><p>修改前</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220727121534997.png" alt="image-20220727121534997"></p></li><li><p>修改后</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220727121616196.png" alt="image-20220727121616196"></p></li><li><p>再次查看 JDK 版本</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220727121802813.png" alt="image-20220727121802813"></p></li></ul><h4 id="6-4-2-基本使用"><a href="#6-4-2-基本使用" class="headerlink" title="6.4.2 基本使用"></a>6.4.2 基本使用</h4><p>1、配置文件方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认配置文件</span></span><br><span class="line">ll /opt/scanner/conf/sonar-scanner.properties</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义唯一的关键字</span></span><br><span class="line">sonar.projectKey=devops-hello-service</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义项目名称</span></span><br><span class="line">sonar.projectName=My project</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义项目的版本信息</span></span><br><span class="line">sonar.projectVersion=1.0</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定扫描代码的目录位置（多个逗号分隔）</span></span><br><span class="line">sonar.sources=.</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行项目编码</span></span><br><span class="line">sonar.sourceEncoding=UTF-8</span><br><span class="line"></span><br><span class="line">sonar.host.url=http://xxxx:9000</span><br><span class="line">sonar.login=xxx</span><br><span class="line">sonar.password=xxx</span><br></pre></td></tr></table></figure><blockquote><p>当配置文件配置好后，就可以指定配置文件启动扫描程序了。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动扫描（指定配置文件）</span></span><br><span class="line">sonar-scanner -Dproject.settings=sonar-scanner.properties</span><br></pre></td></tr></table></figure><p>2、命令行方式</p><blockquote><p>如果你没有在配置文件（sonar-scanner.properties）中配置，也可使用命令行方式来传递参数</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令行传参</span></span><br><span class="line">sonar-scanner -Dsonar.projectKey=myproject \</span><br><span class="line">              -Dsonar.sources=src1 \</span><br><span class="line">              -Dsonar.sourceEncoding=UTF-8</span><br><span class="line">              ... \</span><br><span class="line">              ...</span><br></pre></td></tr></table></figure><h4 id="6-4-3-项目扫描"><a href="#6-4-3-项目扫描" class="headerlink" title="6.4.3 项目扫描"></a>6.4.3 项目扫描</h4><p>1、Java</p><blockquote><p>初始化一个 Java demo</p></blockquote><p>快速生成：<a href="https://start.spring.io/">https://start.spring.io/</a></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220727153337942.png" alt="image-20220727153337942"></p><blockquote><p>上传至 Gitlab</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220727155100698.png" alt="image-20220727155100698"></p><blockquote><p>本地手动构建一下</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone http://192.168.56.133/root/demo.git</span><br><span class="line">cd demo</span><br><span class="line">mvn clean package</span><br></pre></td></tr></table></figure><blockquote><p>SonarQube 安装 Java 语言插件（该版本默认已经安装了）</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220727161259149.png" alt="image-20220727161259149"></p><blockquote><p>开始扫描</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式一：命令行  执行后会在sonarqube上自动创建你指定的相关项目信息及分析结果（在拉取gitlab项目的家目录执行）</span></span><br><span class="line">sonar-scanner -Dsonar.host.url=http://192.168.56.131:9000 \</span><br><span class="line">-Dsonar.projectKey=rab_test_1 \</span><br><span class="line">-Dsonar.projectName=rab_test-1 \</span><br><span class="line">-Dsonar.projectVersion=1.0 \</span><br><span class="line">-Dsonar.login=admin \</span><br><span class="line">-Dsonar.password=zhurs@123 \</span><br><span class="line">-Dsonar.ws.timeout=30 \</span><br><span class="line">-Dsonar.projectDescription=&quot;my first project!&quot; \</span><br><span class="line">-Dsonar.links.homepage=http://192.168.56.131/devops/devops-maven-service \</span><br><span class="line">-Dsonar.links.ci=http://192.168.56.131:8080/job/其他/job/test/ \</span><br><span class="line">-Dsonar.sources=src \</span><br><span class="line">-Dsonar.sourceEncoding=UTF-8 \</span><br><span class="line">-Dsonar.java.binaries=target/classes \</span><br><span class="line">-Dsonar.java.test.binaries=target/test-classes \</span><br><span class="line">-Dsonar.java.surefire.report=target/surefire-reports</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式二：命令行  提前在sonarqube上创建了项目，并生成了以下语句（在拉取gitlab项目的家目录执行）</span></span><br><span class="line">mvn sonar:sonar \</span><br><span class="line">  -Dsonar.projectKey=demo \</span><br><span class="line">  -Dsonar.host.url=http://192.168.56.131:9000 \</span><br><span class="line">  -Dsonar.login=f58b2783878a817320b834b57ba3323e17b2b325</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220727170318256.png" alt="image-20220727170318256"></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220727170106848.png" alt="image-20220727170106848"></p><p>2、前端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sonar.projectKey=devops-web-service</span><br><span class="line">sonar.projectName=devops-web-service</span><br><span class="line">sonar.projectVersion=1.0</span><br><span class="line">sonar.sources=src</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sonar.sources=dist/static/js</span></span><br><span class="line">sonar.host.url=http://192.168.56.131:9000</span><br><span class="line">sonar.login=admin</span><br><span class="line">sonar.password=zhurs@123</span><br><span class="line">sonar.sourceEncoding=UTF-8</span><br></pre></td></tr></table></figure><p>3、golang</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sonar-scanner -Dsonar.projectKey=devops-golang-service \</span><br><span class="line">-Dsonar.projectName=devops-golang-service \</span><br><span class="line">-Dsonar.sources=src \</span><br><span class="line">-Dsonar.login=admin \</span><br><span class="line">-Dsonar.password=zhurs@123 \</span><br><span class="line">-Dsonar.host.url=http://192.168.56.131:9000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 有测试用例的情况</span></span></span><br><span class="line">sonar.exclusions=**/*_test.go</span><br><span class="line">sonar.tests=.</span><br><span class="line">sonar.test.inclusions=**/*_test.go</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;Pipeline 流水线配置&#x3D;&#x3D;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def buildTools = [  &quot;maven&quot; : &quot;/usr/local/apache-maven-3.8.1&quot;,</span><br><span class="line">                    &quot;gradle&quot;: &quot;/usr/local/gradle-6.8.3/&quot;,</span><br><span class="line">                    &quot;golang&quot;: &quot;/usr/local/go&quot;,</span><br><span class="line">                    &quot;web&quot;   : &quot;/usr/local/node-v14.16.1-linux-x64/&quot;,</span><br><span class="line">                    &quot;sonar&quot; : &quot;/usr/local/sonar-scanner-4.6.0.2311-linux&quot;]</span><br><span class="line"></span><br><span class="line">pipeline &#123;</span><br><span class="line">// xxx</span><br><span class="line">stages&#123;</span><br><span class="line">stage(&quot;SonarScan&quot;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script &#123;</span><br><span class="line">                    sh &quot;&quot;&quot;</span><br><span class="line">                        $&#123;buildTools[&quot;sonar&quot;]&#125;/bin/sonar-scanner -Dproject.settings=sonar.properties \</span><br><span class="line">                        -Dsonar.login=admin \</span><br><span class="line">                        -Dsonar.password=admin \</span><br><span class="line">                        -Dsonar.host.url=http://192.168.56.131:9000</span><br><span class="line">                       &quot;&quot;&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&quot;...&quot;) &#123;</span><br><span class="line">        // xxx</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"> &#125; </span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;官方参数详解及各语言扫描示例&#x3D;&#x3D;</p><p>关于项目参数可以参考：<a href="https://docs.sonarqube.org/latest/analysis/analysis-parameters/">https://docs.sonarqube.org/latest/analysis/analysis-parameters/</a></p><p>各种语言的扫描示例：<a href="https://docs.sonarqube.org/latest/analysis/languages/">https://docs.sonarqube.org/latest/analysis/languages/</a></p><h4 id="6-3-4-Jenkins-插件"><a href="#6-3-4-Jenkins-插件" class="headerlink" title="6.3.4 Jenkins 插件"></a>6.3.4 Jenkins 插件</h4><blockquote><p>除了以上在配置文件、命令行、jenkinsfile（命令行的一种体现方式）进行质量检测外，也可以使用 Jenkins 插件来实现。</p></blockquote><p>1、Jenkins 安装 <code>SonarQube Scanner</code> 插件</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220727175147391.png" alt="image-20220727175147391"></p><p>2、SonarQube 生成 Token</p><blockquote><p>将 Token 复制下来：6124c774af3b8c0263c4a1d03d790b1f308dd2fd</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220727175627910.png" alt="image-20220727175627910"></p><p>3、将 Token 保存到 Jenkins 凭据中</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220727180205084.png" alt="image-20220727180205084"></p><p>4、Jenkins 系统配置</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220727180555462.png" alt="image-20220727180555462"></p><p>5、利用 Jenkins 片段生成器生成代码片段</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220727180816942.png" alt="image-20220727180816942"></p><p>6、流水线配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//使用sonar服务器</span><br><span class="line">stage(&quot;SonarScanForPlugin&quot;)&#123;</span><br><span class="line">steps&#123;</span><br><span class="line">script&#123;</span><br><span class="line">withSonarQubeEnv(credentialsId: &#x27;SonarQube_Token&#x27;) &#123;</span><br><span class="line">def sonarDate = sh  returnStdout: true, script: &#x27;date  +%Y%m%d%H%M%S&#x27;</span><br><span class="line">sonarDate = sonarDate - &quot;\n&quot;</span><br><span class="line"></span><br><span class="line">sh &quot;&quot;&quot;</span><br><span class="line">$&#123;buildTools[&quot;sonar&quot;]&#125;/bin/sonar-scanner \</span><br><span class="line">-Dsonar.projectKey=$&#123;JOB_NAME&#125; \</span><br><span class="line">-Dsonar.projectName=$&#123;JOB_NAME&#125; \</span><br><span class="line">-Dsonar.projectVersion=$&#123;sonarDate&#125; \</span><br><span class="line">-Dsonar.ws.timeout=30 \</span><br><span class="line">-Dsonar.projectDescription=&quot;my test project&quot; \</span><br><span class="line">-Dsonar.links.homepage=http://www.baidu.com \</span><br><span class="line">-Dsonar.sources=src \</span><br><span class="line">-Dsonar.sourceEncoding=UTF-8 \</span><br><span class="line">-Dsonar.java.binaries=target/classes \</span><br><span class="line">-Dsonar.java.test.binaries=target/test-classes \</span><br><span class="line">-Dsonar.java.surefire.report=target/surefire-reports \</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-检测流程"><a href="#6-4-检测流程" class="headerlink" title="6.4 检测流程"></a>6.4 检测流程</h3><p>1、整体流程</p><ul><li>Scanner 扫描；</li><li>将扫描结果上传 SonarQube；</li><li>SonarQube 以 Web UI 形式进行展示。</li></ul><p>&#x3D;&#x3D;2、如何查看 SonarQube API 详情？&#x3D;&#x3D;</p><ul><li><p><a href="http://192.168.56.131:9000/web_api">http://192.168.56.131:9000/web_api</a></p></li><li><p>基本接口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 查找项目</span><br><span class="line">api/projects/search?projects=$&#123;projectName&#125;&quot;</span><br><span class="line"></span><br><span class="line">// 创建项目</span><br><span class="line">api/projects/create?name=$&#123;projectName&#125;&amp;project=$&#123;projectName&#125;&quot;</span><br><span class="line">   </span><br><span class="line">// 更新语言规则集</span><br><span class="line">api/qualityprofiles/add_project?language=$&#123;language&#125;&amp;qualityProfile=$&#123;qualityProfile&#125;&amp;project=$&#123;projectName&#125;&quot;</span><br><span class="line"></span><br><span class="line">// 项目授权</span><br><span class="line">api/permissions/apply_template?projectKey=$&#123;projectKey&#125;&amp;templateName=$&#123;templateName&#125;&quot;</span><br><span class="line"></span><br><span class="line">// 更新质量阈</span><br><span class="line">api/qualitygates/select?projectKey=$&#123;projectKey&#125;&amp;gateId=$&#123;gateId&#125;&quot;</span><br></pre></td></tr></table></figure></li><li><p>具体案例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">// 封装HTTP</span><br><span class="line"></span><br><span class="line">def HttpReq(reqType,reqUrl,reqBody)&#123;</span><br><span class="line">    def sonarServer = &quot;http://192.168.1.200:9000/api&quot;</span><br><span class="line">   </span><br><span class="line">    response = httpRequest authentication: &#x27;4675830a-4330-4dd6-9185-cf62161967f0&#x27;,</span><br><span class="line">            httpMode: reqType, </span><br><span class="line">            contentType: &quot;APPLICATION_JSON&quot;,</span><br><span class="line">            consoleLogResponseBody: true,</span><br><span class="line">            ignoreSslErrors: true, </span><br><span class="line">            requestBody: reqBody,</span><br><span class="line">            url: &quot;$&#123;sonarServer&#125;/$&#123;reqUrl&#125;&quot;</span><br><span class="line">            //quiet: true</span><br><span class="line">    </span><br><span class="line">    return response</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 搜索Sonar项目</span><br><span class="line">def SerarchProject(projectName)&#123;</span><br><span class="line">    apiUrl = &quot;projects/search?projects=$&#123;projectName&#125;&quot;</span><br><span class="line">    response = HttpReq(&quot;GET&quot;,apiUrl,&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">    response = readJSON text: &quot;&quot;&quot;$&#123;response.content&#125;&quot;&quot;&quot;</span><br><span class="line">    result = response[&quot;paging&quot;][&quot;total&quot;]</span><br><span class="line"></span><br><span class="line">    if(result.toString() == &quot;0&quot;)&#123;</span><br><span class="line">       return &quot;false&quot;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       return &quot;true&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取Sonar质量阈状态</span><br><span class="line">def GetProjectStatus(projectName)&#123;</span><br><span class="line">    apiUrl = &quot;project_branches/list?project=$&#123;projectName&#125;&quot;</span><br><span class="line">    response = HttpReq(&quot;GET&quot;,apiUrl,&#x27;&#x27;)</span><br><span class="line">    </span><br><span class="line">    response = readJSON text: &quot;&quot;&quot;$&#123;response.content&#125;&quot;&quot;&quot;</span><br><span class="line">    result = response[&quot;branches&quot;][0][&quot;status&quot;][&quot;qualityGateStatus&quot;]</span><br><span class="line">    </span><br><span class="line">    //println(response)</span><br><span class="line">    </span><br><span class="line">   return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 创建Sonar项目</span><br><span class="line">def CreateProject(projectName)&#123;</span><br><span class="line">    apiUrl =  &quot;projects/create?name=$&#123;projectName&#125;&amp;project=$&#123;projectName&#125;&quot;</span><br><span class="line">    response = HttpReq(&quot;POST&quot;,apiUrl,&#x27;&#x27;)</span><br><span class="line">    println(response)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 配置项目质量规则</span><br><span class="line">def ConfigQualityProfiles(projectName,lang,qpname)&#123;</span><br><span class="line">    apiUrl = &quot;qualityprofiles/add_project?language=$&#123;lang&#125;&amp;project=$&#123;projectName&#125;&amp;qualityProfile=$&#123;qpname&#125;&quot;</span><br><span class="line">    response = HttpReq(&quot;POST&quot;,apiUrl,&#x27;&#x27;)</span><br><span class="line">    println(response)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取质量阈ID</span><br><span class="line">def GetQualtyGateId(gateName)&#123;</span><br><span class="line">    apiUrl= &quot;qualitygates/show?name=$&#123;gateName&#125;&quot;</span><br><span class="line">    response = HttpReq(&quot;GET&quot;,apiUrl,&#x27;&#x27;)</span><br><span class="line">    response = readJSON text: &quot;&quot;&quot;$&#123;response.content&#125;&quot;&quot;&quot;</span><br><span class="line">    result = response[&quot;id&quot;]</span><br><span class="line">    </span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 配置项目质量阈</span><br><span class="line">def ConfigQualityGates(projectName,gateName)&#123;</span><br><span class="line">    gateId = GetQualtyGateId(gateName)</span><br><span class="line">    apiUrl = &quot;qualitygates/select?gateId=$&#123;gateId&#125;&amp;projectKey=$&#123;projectName&#125;&quot;</span><br><span class="line">    response = HttpReq(&quot;POST&quot;,apiUrl,&#x27;&#x27;)</span><br><span class="line">    println(response)println(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="七、制品库管理"><a href="#七、制品库管理" class="headerlink" title="七、制品库管理"></a>七、制品库管理</h2><p>Jenkins 通过与 <code>Nexus</code> 集成，实现制品上传下载。<a href="https://nexusjs.org/">Nexus 官网</a></p><h3 id="7-1-基本概念"><a href="#7-1-基本概念" class="headerlink" title="7.1 基本概念"></a>7.1 基本概念</h3><p>通常，我们开发项目并没有使用到虚线标识的那两部分，基本都是通过本机的 Maven 直接访问中央仓库，下载jar包到本地仓库，现在我们需要搭建中间虚线部分。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221018101731235.png" alt="image-20221018101731235"></p><h3 id="7-2-服务部署"><a href="#7-2-服务部署" class="headerlink" title="7.2 服务部署"></a>7.2 服务部署</h3><p>1、创建持久化目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /home/data/nexus</span><br><span class="line">chmod 777 /home/data/nexus</span><br></pre></td></tr></table></figure><p>2、运行容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --restart=always \</span><br><span class="line">  --name=nexus \</span><br><span class="line">  -p 8081:8081 \</span><br><span class="line">  -v /data/docker/nexus:/nexus-data sonatype/nexus3:3.42.0</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221018102440469.png" alt="image-20221018102440469"></p><p>3、查询 Nexus 初始密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it nexus /bin/bash</span><br><span class="line">cat /opt/sonatype/sonatype-work/nexus3/admin.password</span><br><span class="line">169cee29-ae5f-481b-b153-206371d93f29</span><br></pre></td></tr></table></figure><blockquote><p>用户名：admin</p><p>密码：169cee29-ae5f-481b-b153-206371d93f29</p><p>之后再按要求重新设置新密码即可（本次新密码：zhurs@123）。</p></blockquote><p>4、验证</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220609174626174.png" alt="image-20220609174626174"></p><p>右上角这里告警了，提示 CPU 至少 4C 及以上：由于我这是测试环境，先不用理会。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221018103554065.png" alt="image-20221018103554065"></p><h3 id="7-3-基本使用"><a href="#7-3-基本使用" class="headerlink" title="7.3 基本使用"></a>7.3 基本使用</h3><p>具体使用方法看我有道云笔记<code>基础服务部署</code>部分的《Docker 部署 Nexus》，这里不再重复演示。</p><h3 id="7-4-Jenkins-集成"><a href="#7-4-Jenkins-集成" class="headerlink" title="7.4 Jenkins 集成"></a>7.4 Jenkins 集成</h3><p>1、Pipeline 脚本</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    tools &#123;</span><br><span class="line">        maven <span class="string">&quot;M3&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    environment &#123;</span><br><span class="line">        NEXUS_VERSION = <span class="string">&quot;nexus3&quot;</span></span><br><span class="line">        NEXUS_PROTOCOL = <span class="string">&quot;http&quot;</span></span><br><span class="line">        NEXUS_URL = <span class="string">&quot;192.168.56.142:8081&quot;</span></span><br><span class="line">        NEXUS_REPOSITORY = <span class="string">&quot;cicd_hosted&quot;</span></span><br><span class="line">        NEXUS_CREDENTIAL_ID = <span class="string">&quot;nexus_kps&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;初始化&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                checkout([<span class="attr">$class:</span> <span class="string">&#x27;GitSCM&#x27;</span>, <span class="attr">branches:</span> [[<span class="attr">name:</span> <span class="string">&quot;v1.0.1&quot;</span>]], <span class="attr">extensions:</span> [], <span class="attr">userRemoteConfigs:</span> [[<span class="attr">credentialsId:</span> <span class="string">&#x27;aliyun-devops&#x27;</span>, <span class="attr">url:</span> <span class="string">&#x27;git@codeup.aliyun.com:6277bcbc11fc0f0c9e2990ab/RAB-ZH/java_code.git&#x27;</span>]]])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Git代码拉取&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                checkout([<span class="attr">$class:</span> <span class="string">&#x27;GitSCM&#x27;</span>, <span class="attr">branches:</span> [[<span class="attr">name:</span> <span class="string">&quot;v1.0.1&quot;</span>]], <span class="attr">extensions:</span> [], <span class="attr">userRemoteConfigs:</span> [[<span class="attr">credentialsId:</span> <span class="string">&#x27;aliyun-devops&#x27;</span>, <span class="attr">url:</span> <span class="string">&#x27;git@codeup.aliyun.com:6277bcbc11fc0f0c9e2990ab/RAB-ZH/java_code.git&#x27;</span>]]])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&quot;Maven打包&quot;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script &#123;</span><br><span class="line">                    sh <span class="string">&quot;/var/jenkins_home/maven/bin/mvn clean package -Dmaven.test.skip=true&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&quot;推送至Nexus制品库&quot;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script &#123;</span><br><span class="line">                    pom = readMavenPom <span class="attr">file:</span> <span class="string">&quot;pom.xml&quot;</span>;</span><br><span class="line">                    filesByGlob = findFiles(<span class="attr">glob:</span> <span class="string">&quot;target/*.$&#123;pom.packaging&#125;&quot;</span>);</span><br><span class="line">                    echo <span class="string">&quot;$&#123;filesByGlob[0].name&#125; $&#123;filesByGlob[0].path&#125; $&#123;filesByGlob[0].directory&#125; $&#123;filesByGlob[0].length&#125; $&#123;filesByGlob[0].lastModified&#125;&quot;</span></span><br><span class="line">                    artifactPath = filesByGlob[<span class="number">0</span>].path;</span><br><span class="line">                    artifactExists = fileExists artifactPath;</span><br><span class="line">                    <span class="keyword">if</span>(artifactExists) &#123;</span><br><span class="line">                        echo <span class="string">&quot;*** File: $&#123;artifactPath&#125;, group: $&#123;pom.groupId&#125;, packaging: $&#123;pom.packaging&#125;, version $&#123;pom.version&#125;&quot;</span>;</span><br><span class="line">                        nexusArtifactUploader(</span><br><span class="line">                            <span class="symbol">nexusVersion:</span> NEXUS_VERSION,</span><br><span class="line">                            <span class="symbol">protocol:</span> NEXUS_PROTOCOL,</span><br><span class="line">                            <span class="symbol">nexusUrl:</span> NEXUS_URL,</span><br><span class="line">                            <span class="symbol">groupId:</span> pom.groupId,</span><br><span class="line">                            <span class="symbol">version:</span> pom.version,</span><br><span class="line">                            <span class="symbol">repository:</span> NEXUS_REPOSITORY,</span><br><span class="line">                            <span class="symbol">credentialsId:</span> NEXUS_CREDENTIAL_ID,</span><br><span class="line">                            <span class="symbol">artifacts:</span> [</span><br><span class="line">                                [<span class="attr">artifactId:</span> pom.artifactId,</span><br><span class="line">                                <span class="symbol">classifier:</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                                <span class="symbol">file:</span> artifactPath,</span><br><span class="line">                                <span class="symbol">type:</span> pom.packaging],</span><br><span class="line">                                [<span class="attr">artifactId:</span> pom.artifactId,</span><br><span class="line">                                <span class="symbol">classifier:</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                                <span class="symbol">file:</span> <span class="string">&quot;pom.xml&quot;</span>,</span><br><span class="line">                                <span class="symbol">type:</span> <span class="string">&quot;pom&quot;</span>]</span><br><span class="line">                            ]</span><br><span class="line">                        );</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        error <span class="string">&quot;*** File: $&#123;artifactPath&#125;, could not be found&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、构建验证</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221018123030679.png" alt="image-20221018123030679"></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221018120302885.png" alt="image-20221018120302885"></p><p>3、去 Nexus 查看一下</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221018120845661.png" alt="image-20221018120845661"></p><h2 id="八、FAQ"><a href="#八、FAQ" class="headerlink" title="八、FAQ"></a>八、FAQ</h2><h3 id="8-1-缺少-Docker-插件"><a href="#8-1-缺少-Docker-插件" class="headerlink" title="8.1 缺少 Docker 插件"></a>8.1 缺少 Docker 插件</h3><p>1、报错类型</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220610145809263.png" alt="image-20220610145809263"></p><p>2、解决方案</p><p>这是 Jenkins 缺少插件问题。Jenkins 安装 Docker 相关插件即可。</p><h3 id="8-2-docker-作为-agent-时报错"><a href="#8-2-docker-作为-agent-时报错" class="headerlink" title="8.2 docker 作为 agent 时报错"></a>8.2 docker 作为 agent 时报错</h3><p>1、报错类型</p><p>使用 docker 作为 agent 时报错，流水线脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        docker &#123;</span><br><span class="line">            image &#x27;maven:3-alpine&#x27;</span><br><span class="line">            args &#x27;-v /root/maven:/root/.m2&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Build&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;mvn -v&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建后报错：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220610145407929.png" alt="image-20220610145407929"></p><p>2、解决方案</p><p>这是权限问题。将 Jenkins 用户加入 root 用户组即可。</p><ul><li><p>创建 docker 用户组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd docker</span><br></pre></td></tr></table></figure></li><li><p>追加 jenkins 用户到 docker 用户组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -a -G docker jenkins</span><br></pre></td></tr></table></figure></li><li><p>查看是否添加成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/group</span><br><span class="line">...</span><br><span class="line">docker:x:994:jenkins</span><br></pre></td></tr></table></figure></li><li><p>赋予 666 权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ll /var/run/docker.sock</span><br><span class="line">srw-rw---- 1 root docker 0 Jun 10 12:54 /var/run/docker.sock</span><br><span class="line"></span><br><span class="line">chmod 666 /var/run/docker.sock</span><br><span class="line"></span><br><span class="line">ll /var/run/docker.sock</span><br><span class="line">srw-rw-rw- 1 root docker 0 Jun 10 12:54 /var/run/docker.sock</span><br></pre></td></tr></table></figure></li></ul><p>再次构建即可。</p><h3 id="8-3-options-timestamps"><a href="#8-3-options-timestamps" class="headerlink" title="8.3 options timestamps()"></a>8.3 options timestamps()</h3><p>1、报错类型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WorkflowScript: 21: Invalid option type &quot;timestamps&quot;. Valid option types: [authorizationMatrix, buildDiscarder, catchError, checkoutToSubdirectory, disableConcurrentBuilds, disableResume, durabilityHint, lock, overrideIndexTriggers, parallelsAlwaysFailFast, preserveStashes, quietPeriod, rateLimitBuilds, retry, script, skipDefaultCheckout, skipStagesAfterUnstable, timeout, waitUntil, warnError, withChecks, withContext, withCredentials, withEnv, wrap, ws] @ line 21, column 3.</span><br><span class="line">   timestamps()</span><br><span class="line">     ^</span><br></pre></td></tr></table></figure><p>2、解决方案</p><p>使用时间戳方式显示日志输出时间时，Jenkins 需要安装 <code>Timestamper</code> 插件，如下图，我已经安装过了，如果你还没安装，就点击 <code>Available</code> 选项进行搜索安装即可。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20220724163819555.png" alt="image-20220724163819555"></p><h3 id="8-4-jar-推送至制品库"><a href="#8-4-jar-推送至制品库" class="headerlink" title="8.4 jar 推送至制品库"></a>8.4 jar 推送至制品库</h3><h4 id="8-4-1-报错一"><a href="#8-4-1-报错一" class="headerlink" title="8.4.1 报错一"></a>8.4.1 报错一</h4><p>1、报错现象</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221018113733372.png" alt="image-20221018113733372"></p><p>2、解决方案</p><blockquote><p>Jenkins 服务安装 <code>pipeline-utility-steps</code> 插件</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221018113953087.png" alt="image-20221018113953087"> </p><h4 id="8-4-2-报错二"><a href="#8-4-2-报错二" class="headerlink" title="8.4.2 报错二"></a>8.4.2 报错二</h4><p>1、报错现象</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221018114245902.png" alt="image-20221018114245902"></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221018114333710.png" alt="image-20221018114333710"></p><p>2、解决方案</p><p>该问题是因为 <code>jenkins</code> 的安全沙箱机制导致的，只要批准不安全的脚本运行即可，对 Jenkins 服务进行配置即可：</p><ul><li><p>系统配置 ——&gt; 安全（看下图）</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221018114604278.png" alt="image-20221018114604278"></p></li><li><p>点击允许使用模板</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221018115218685.png" alt="image-20221018115218685"></p></li><li><p>完成（这时候就可以了）</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221018115136967.png" alt="image-20221018115136967"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CICD </tag>
            
            <tag> Jenkins_Pipeline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 18.04 搭建 DHCP 服务</title>
      <link href="/posts/articles/29eede74.html"/>
      <url>/posts/articles/29eede74.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230314151216808.png" alt="image-20230314151216808"></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在公司进行边缘服务器的部署工作，借此机会和大家交流一下部署中的一个技术环节——DHCP 服务器的搭建，为什么要多此一举搭建这个服务呢，用现成的他不香吗？其实，这个取决于你的实际应用场景，如果你部署的边缘服务器是批量的，你是怎么识别每台边缘服务器的 IP 呢，可能你会想到使用一些内网 IP 扫描工具来进行扫描，但是我们是以动态的方式来获取 IP 的，如果你的客户端服务器重启，那你的 IP 可能就会发生变化，即便通过搭建内网 DNS 的方式也需要明确你的客户端服务器的 IP，以及这个 IP 所对应的服务器跑的应用程序，那你的内网 DNS 才有意义。本文将介绍如何部署 DHCP 服务、如何通过 MAC 来绑定具体 IP。</p><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1-1-DHCP-协议"><a href="#1-1-DHCP-协议" class="headerlink" title="1.1 DHCP 协议"></a>1.1 DHCP 协议</h3><blockquote><p>来自百度百科的解释</p></blockquote><p><strong>DHCP</strong>（Dynamic Host Configuration Protocol），即动态主机配置协议，是一个局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的 IP 地址和子网掩码。默认情况下，DHCP 作为 Windows Server 的一个服务组件不会被系统自动安装，还需要管理员手动安装并进行必要的配置。</p><h3 id="1-2-IP-分配方式"><a href="#1-2-IP-分配方式" class="headerlink" title="1.2 IP 分配方式"></a>1.2 IP 分配方式</h3><p>1、手动分配</p><p>手动分配 IP 的分配方式是需要 DHCP 服务器管理员来具体定制的。</p><p>2、自动分配</p><p>自动分配 IP 的分配方式是在客户端从 DHCP 获取一个 IP 后，就会永久使用这个 IP 地址。</p><p>3、动态分配</p><p>动态分配 IP 的分配方式的话就很好理解，也就是客户端从 DHCP 获取一个 IP 后，并不会永久使用该 IP 地址，而是以租约的方式动态获取 IP 地址，如果租约到期则会释放该 IP 地址而供其他客户端使用。</p><h2 id="二、部署规划"><a href="#二、部署规划" class="headerlink" title="二、部署规划"></a>二、部署规划</h2><table><thead><tr><th>OS</th><th>应用</th><th>备注</th></tr></thead><tbody><tr><td>Ubuntu18.04（192.168.136.130）</td><td>DHCP</td><td>服务端</td></tr><tr><td>Ubuntu18.04（192.168.136.x）</td><td>-</td><td>客户端</td></tr><tr><td>…</td><td>-</td><td>客户端</td></tr></tbody></table><blockquote><p>注：DHCP_Server 和 DHCP_Client 须处于同一个局域网内。</p></blockquote><h2 id="三、DHCP-部署"><a href="#三、DHCP-部署" class="headerlink" title="三、DHCP 部署"></a>三、DHCP 部署</h2><h3 id="3-1-动态获取-IP"><a href="#3-1-动态获取-IP" class="headerlink" title="3.1 动态获取 IP"></a>3.1 动态获取 IP</h3><p>1、安装 DHCP Server</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y isc-dhcp-server</span><br></pre></td></tr></table></figure><p>2、配置 DHCP Server 静态 IP</p><blockquote><p>目的是为了 DHCP Server 的 IP 不发生变化，便于向其他客户端提供稳定服务。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 Netplan</span></span><br><span class="line">sudo apt install -y netplan.io</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改配置文件</span></span><br><span class="line">sudo vim /etc/netplan/01-xxxx.yaml</span><br><span class="line">network:</span><br><span class="line">  ethernets:</span><br><span class="line">        ens33:</span><br><span class="line">            dhcp4: no</span><br><span class="line">            dhcp6: no</span><br><span class="line">            addresses: [192.168.136.130/24]</span><br><span class="line">            gateway4: 192.168.136.2</span><br><span class="line">            nameservers:</span><br><span class="line">                    addresses: [114.114.114.114,8.8.8.8]</span><br><span class="line">  version: 2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">应用配置（使其生效）</span></span><br><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure><p>3、配置 DHCP Server</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/dhcp/dhcpd.conf</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全局配置（若局部配置没设置则以全局配置为准）</span></span><br><span class="line">option domain-name &quot;example.org&quot;;</span><br><span class="line">option domain-name-servers ns1.example.org, ns2.example.org;</span><br><span class="line"></span><br><span class="line">default-lease-time 600;</span><br><span class="line">max-lease-time 7200;</span><br><span class="line"></span><br><span class="line">ddns-update-style none;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">局部配置（若局部配置已设置则以局部配置为准）</span></span><br><span class="line">subnet 192.168.136.0 netmask 255.255.255.0 &#123;         # 定义网络地址和子网掩码</span><br><span class="line">       range 192.168.136.132 192.168.136.135;        # 指定IP地址池的范围</span><br><span class="line">       option domain-name &quot;zrs.com&quot;;                 # 域（比如访问www，就会自动补齐www.zrs.com）</span><br><span class="line">       option domain-name-servers 192.168.136.130;   # DNS服务器（自建的DNS或所在地区的DNS）</span><br><span class="line">       option subnet-mask 255.255.255.0;             # 子网掩码</span><br><span class="line">       option routers 192.168.136.2;                 # 网关IP</span><br><span class="line">       option broadcast-address 255.255.255.0;       # 广播地址</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>4、重启 DHCP Server</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart isc-dhcp-server  # 启动</span><br><span class="line">sudo systemctl enable isc-dhcp-server   # 开机自启</span><br><span class="line">sudo systemctl status isc-dhcp-server   # 查看启动状态</span><br></pre></td></tr></table></figure><p>5、客户端如何获取 IP ？</p><p>DHCP 服务器搭建好后，启动 DHCP_Client（客户端），向客户端发出请求，最后服务端响应客户端的请求并给客户端动态分配 IP 地址，具体的原理这里不做介绍，大家可以自行查阅一下相关资料。下图为验证结果：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230331214435280.png" alt="image-20230331214435280"></p><h3 id="3-2-自动获取-IP"><a href="#3-2-自动获取-IP" class="headerlink" title="3.2 自动获取 IP"></a>3.2 自动获取 IP</h3><p>在以上基础上，只需修改一下 DHCP 服务的配置即可实现 MAC-IP 的形式获取 IP 地址。</p><p>1、先获取客户端 MAC 地址</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230331214455943.png" alt="image-20230331214455943"></p><p>2、修改 DHCP Server 配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/dhcp/dhcpd.conf</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全局配置（若局部配置没设置则以全局配置为准）</span></span><br><span class="line">option domain-name &quot;example.org&quot;;</span><br><span class="line">option domain-name-servers ns1.example.org, ns2.example.org;</span><br><span class="line"></span><br><span class="line">default-lease-time 600;</span><br><span class="line">max-lease-time 7200;</span><br><span class="line"></span><br><span class="line">ddns-update-style none;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">局部配置（若局部配置已设置则以局部配置为准）</span></span><br><span class="line">subnet 192.168.136.0 netmask 255.255.255.0 &#123;         # 定义网络地址和子网掩码</span><br><span class="line">       range 192.168.136.132 192.168.136.135;        # 指定IP地址池的范围</span><br><span class="line">       option domain-name &quot;zrs.com&quot;;                 # 域（比如访问www，就会自动补齐www.zrs.com）</span><br><span class="line">       option domain-name-servers 192.168.136.130;   # DNS服务器（自建的DNS或所在地区的DNS）</span><br><span class="line">       option routers 192.168.136.2;                 # 网关IP</span><br><span class="line">       option broadcast-address 192.168.136.255;     # 广播地址</span><br><span class="line">&#125;</span><br><span class="line">host ubuntu-app &#123;</span><br><span class="line">     hardware ethernet 00:0c:29:1a:74:a1;</span><br><span class="line">     fixed-address 192.168.136.134;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">说明</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">08:00:07:26:c0:a5：这是客户端服务器的MAC地址（即我们所说的物理地址）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">192.168.136.133：这是我指定的IP地址（即这个MAC地址的服务器固定使用这个IP地址）</span></span><br></pre></td></tr></table></figure><p>3、重启 DHCP Server</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart isc-dhcp-server</span><br></pre></td></tr></table></figure><blockquote><p>接下来启动客户端，该客户端就会获得指定的 IP 地址。</p><p>注：不过要注意，在指定 IP 地址的时候，要确保这个 IP 没被其他客户端占用，否则会发生冲突，在指定之前可以先扫描一下所在内网 IP 的存活状态。</p></blockquote><p>4、验证</p><blockquote><p>下图可看到，通过客户端 MAC 指定的固定 IP 已实现。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230331214524089.png" alt="image-20230331214524089"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是关于 DHCP 服务的部署，以及客户端 IP 地址获取的方式配置，经过实际测试验证，最终实现了动态&amp;&amp;自动获取 IP 地址。如果大家实在本地虚拟机（如VMware），需要勾掉本地 DHCP 服务，以免对实验造成影响。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230331214545875.png" alt="image-20230331214545875"></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
          <category> DHCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> DHCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitlab 基础操作快速入门</title>
      <link href="/posts/articles/ad1bd1bd.html"/>
      <url>/posts/articles/ad1bd1bd.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Jenkins访问地址：<a href="http://10.20.10.62:2080/users/sign_in">http://10.20.10.62:2080/users/sign_in</a></p><p>测试的用户&#x2F;密码：zhurongsen&#x2F;moscow@123</p></blockquote><h4 id="1、创建群组"><a href="#1、创建群组" class="headerlink" title="1、创建群组"></a>1、创建群组</h4><blockquote><p>首先研发人员给到项目组所有成员名单（包括：姓名&#x2F;职位&#x2F;邮箱），用于账号注册。</p></blockquote><p>（1）创建群组</p><p>【群组】–&gt;【您的群组】–&gt;【新建群组】</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214173917870.png" alt="image-20221214173917870"></p><p>（2）设置群组</p><blockquote><p>私有：仅该组组员才有权限查看该项目</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214173933305.png" alt="image-20221214173933305"></p><p>（3）将用户添加到群组中</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214173956251.png" alt="image-20221214173956251"></p><h4 id="2、创建项目"><a href="#2、创建项目" class="headerlink" title="2、创建项目"></a>2、创建项目</h4><p>（1）创建项目</p><p>【项目】–&gt;【新建项目】</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214174013966.png" alt="image-20221214174013966"></p><p>【创建空白项目】：当然也可导入项目</p><blockquote><p>注：不同的 Gitlab 版本可能有些差异，我这里是中文版的，英文版的话是 Create a project</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214174032785.png" alt="image-20221214174032785"></p><p>（2）设置项目</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214174107705.png" alt="image-20221214174107705"></p><p>（3）创建分支</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214174135221.png" alt="image-20221214174135221"></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214174155642.png" alt="image-20221214174155642"></p><p>（4）合并分支</p><ul><li><p>研发人员的合并请求</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214174221446.png" alt="image-20221214174221446"></p></li><li><p>项目主管批准并进行合并</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214174355830.png" alt="image-20221214174355830"></p></li></ul><h4 id="3、Clone项目"><a href="#3、Clone项目" class="headerlink" title="3、Clone项目"></a>3、Clone项目</h4><p>（1）生成秘钥</p><blockquote><p>研发人员在 Windows 上生成秘钥</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -C <span class="string">&quot;xxxx@126.com&quot;</span></span></span><br></pre></td></tr></table></figure><p>（2）上传公钥至 Gitlab </p><blockquote><p>把公钥上传至自己的 Gitlab 上（登录gitlab，按下图操作）</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub     <span class="comment"># 上传cat的内容至gitlab</span></span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214174453562.png" alt="image-20221214174453562"></p><p>（3）配置个人的用户名称和电子邮件地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.name <span class="string">&quot;name&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.email <span class="string">&quot;test@163.com&quot;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>注：user.name 和 user.email 是你 gitlab 上的用户名称和电子邮件</p></blockquote><p>（4）clone 项目到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> ssh://git@10.20.10.62:2022/mygroup/myproject.git</span></span><br></pre></td></tr></table></figure><h4 id="4、Gitlab-语言设置"><a href="#4、Gitlab-语言设置" class="headerlink" title="4、Gitlab 语言设置"></a>4、Gitlab 语言设置</h4><p>如果不习惯使用英文版的 Gitlab，可自行设置为中文，保存后刷新一下即可，具体步骤如下：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214174513126.png" alt="image-20221214174513126"></p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
          <category> Gitlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CICD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitlab 备份与恢复</title>
      <link href="/posts/articles/7255efaf.html"/>
      <url>/posts/articles/7255efaf.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、查看版本信息"><a href="#一、查看版本信息" class="headerlink" title="一、查看版本信息"></a>一、查看版本信息</h3><p>在数据备份或数据迁移前，应查看对应的系统版本、软件版本等因素，否则可能会导致迁移后数据的不可用。这里以 CentOS 7 为例进行数据备份、恢复和迁移测试。CentOS 8 操作步骤一样。</p><p><strong>1、CentOS 系统版本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /etc/redhat-release</span> </span><br><span class="line">CentOS Linux release 7.4.1708 (Core)</span><br></pre></td></tr></table></figure><p><strong>2、Gitlab 软件版本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /opt/gitlab/embedded/service/gitlab-rails/VERSION</span></span><br><span class="line">13.5.1</span><br></pre></td></tr></table></figure><h3 id="二、数据备份"><a href="#二、数据备份" class="headerlink" title="二、数据备份"></a>二、数据备份</h3><p>在数据备份这里需要注意，当我们在执行备份操作时，为了保证备份数据的一致性，应事先停掉我们的Gitlab服务，如果不停掉的话，可能我们在备份的过程中有其他研发人员进行数据的上传，从而导致备份数据的不一致性和不完整性，甚至出现一些不可预估的错误。</p><p><strong>1、停Gitlab服务</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gitlab-ctl stop unicorn</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gitlab-ctl stop sidekiq</span></span><br><span class="line">ok: down: sidekiq: 0s, normally up</span><br></pre></td></tr></table></figure><p>打开&#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb配置文件，查看一个和备份相关的配置项：<code>gitlab_rails[&#39;backup_path&#39;] = &quot;/data/gitlab/backups&quot;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vim /etc/gitlab/gitlab.rb</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214173313858.png" alt="image-20221214173313858"></p><p>该项定义了默认备份出文件的路径，可以通过修改该配置，并执行 <strong>gitlab-ctl reconfigure 或者 gitlab-ctl  restart</strong> 重启服务生效。</p><p><strong>2、开始备份</strong></p><blockquote><p>接下来我们通过备份命令进行数据备份，备份后的数据默认存放在该路径下：<code>/var/opt/gitlab/backups/</code></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> /var/opt/gitlab/backups/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gitlab-rake gitlab:backup:create    <span class="comment"># 开始备份（等待..）</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">1604716638_2020_11_07_13.5.1_gitlab_backup.tar     # 备份后的数据包</span><br></pre></td></tr></table></figure><blockquote><p>也可以添加到 crontab 中定时执行：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 3 * * * /opt/gitlab/bin/gitlab-rake gitlab:backup:create</span><br></pre></td></tr></table></figure><p>可以到&#x2F;data&#x2F;gitlab&#x2F;backups找到备份包，解压查看，会发现备份的还是比较全面的，数据库、repositories、build、upload等分类还是比较清晰的。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214173338006.png" alt="image-20221214173338006"></p><h3 id="三、数据恢复"><a href="#三、数据恢复" class="headerlink" title="三、数据恢复"></a>三、数据恢复</h3><p><strong>1、删除数据</strong></p><p>为了测试效果，这里我们模拟不小心删掉了项目的某个文件（当然了这里是可以通过<code>log</code>回滚的，假设这里已经删了很久了）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">html  README.md</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> -r html/   <span class="comment"># 删除文件</span></span></span><br><span class="line">rm &#x27;html/index.html&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add .</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&#x27;意外删除html文件&#x27;</span></span></span><br><span class="line">[dev 0c35330] 意外删除html文件</span><br><span class="line"> 1 file changed, 3 deletions(-)</span><br><span class="line"> delete mode 100644 html/index.html</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push sz dev   <span class="comment"># 提交代码</span></span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214173412504.png" alt="image-20221214173412504"></p><p><strong>2、数据恢复</strong></p><p>（1）停Gitlab服务</p><blockquote><p>当我们在做数据备份和数据迁移时，应先停这两个服务，目的是为了保证数据的一致性。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gitlab-ctl stop unicorn</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gitlab-ctl stop sidekiq</span></span><br><span class="line">ok: down: sidekiq: 0s, normally up</span><br></pre></td></tr></table></figure><p>（2）权限</p><blockquote><p>注意权限：600权限是无权恢复的。 实验环境可改成了777，生产环境建议修改属主属组。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">pwd</span></span></span><br><span class="line">/data/gitlab/backups</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">chmod</span> 777 1604716638_2020_11_07_13.5.1_gitlab_backup.tar</span></span><br></pre></td></tr></table></figure><p>（3）开始恢复数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">1604716638_2020_11_07_13.5.1_gitlab_backup.tar</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gitlab-rake gitlab:backup:restore BACKUP=1604716638_2020_11_07_13.5.1</span></span><br></pre></td></tr></table></figure><p>（3）启动Gitlab服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gitlab-ctl start unicorn</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gitlab-ctl start sidekiq</span></span><br><span class="line">ok: run: sidekiq: (pid 9457) 1s</span><br><span class="line"></span><br><span class="line">或：</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gitlab-ctl restart</span></span><br></pre></td></tr></table></figure><p><strong>3、恢复验证</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214173439273.png" alt="image-20221214173439273"></p><p>至此，数据成功恢复。</p><h3 id="四、数据迁移"><a href="#四、数据迁移" class="headerlink" title="四、数据迁移"></a>四、数据迁移</h3><p>（1）停Gitlab服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gitlab-ctl stop unicorn</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gitlab-ctl stop sidekiq</span></span><br><span class="line">ok: down: sidekiq: 0s, normally up</span><br></pre></td></tr></table></figure><p>（2）数据迁移</p><p>将老服务器<code>/data/gitlab/backups</code>目录下的备份文件拷贝到新服务器上的<code>/data/gitlab/backups</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rsync -avz 1604716638_2020_11_07_13.5.1_gitlab_backup.tar 10.20.151.135:/data/gitlab/backups/</span> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
          <category> Gitlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CICD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitlab 详细操作入门</title>
      <link href="/posts/articles/9e594074.html"/>
      <url>/posts/articles/9e594074.html</url>
      
        <content type="html"><![CDATA[<h4 id="一、Gitlab-配置"><a href="#一、Gitlab-配置" class="headerlink" title="一、Gitlab 配置"></a>一、Gitlab 配置</h4><h5 id="1、部署方式"><a href="#1、部署方式" class="headerlink" title="1、部署方式"></a>1、部署方式</h5><p>通过 Docker 运行 Gitlab 容器，并对相关的端口和目录进行了映射。再就是 GitLab 是基于Ruby语言开发的，另外用了redis 和postgresql 数据库</p><h5 id="2、端口"><a href="#2、端口" class="headerlink" title="2、端口"></a>2、端口</h5><ul><li><p>22 端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022:22      # 将 Gitlab 容器的 22 端口映射到宿主机的 2022 端口</span><br></pre></td></tr></table></figure></li><li><p>443 端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2443:443     # 将 Gitlab 容器的 443 端口映射到宿主机的 2443 端口</span><br></pre></td></tr></table></figure></li><li><p>80 端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2080:80      # 将 Gitlab 容器的 80 端口映射到宿主机的 2080 端口</span><br></pre></td></tr></table></figure><blockquote><p>因此访问 Gitlab 时，应跟上对应的 2080 端口</p></blockquote></li></ul><h5 id="3、文件路径"><a href="#3、文件路径" class="headerlink" title="3、文件路径"></a>3、文件路径</h5><ul><li><p>配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/data/gitlab/etc   # 宿主机</span><br><span class="line">/etc/gitlab             # Gitlab 容器</span><br></pre></td></tr></table></figure></li><li><p>数据文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/home/data/gitlab/data  # 宿主机</span><br><span class="line">/var/opt/gitlab         # Gitlab 容器</span><br><span class="line">/var/opt/gitlab/postgresql/data   # PostgreSQL 数据库，用于存放 Gitlab 数据</span><br></pre></td></tr></table></figure></li><li><p>日志文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/data/gitlab/log   # 宿主机</span><br><span class="line">/var/log/gitlab         # Gitlab 容器</span><br></pre></td></tr></table></figure></li></ul><h5 id="4、用户"><a href="#4、用户" class="headerlink" title="4、用户"></a>4、用户</h5><p>默认用户为 git ，这里也可以修改默认的用户。在 Gitlab 上可以创建相应的用户，用户的数据会存储到对应的数据文件之中。</p><h4 id="二、Gitlab-使用教程"><a href="#二、Gitlab-使用教程" class="headerlink" title="二、Gitlab 使用教程"></a>二、Gitlab 使用教程</h4><h5 id="1、创建用户"><a href="#1、创建用户" class="headerlink" title="1、创建用户"></a>1、创建用户</h5><blockquote><p>首先研发人员给到项目组所有成员名单（包括：姓名&#x2F;职位&#x2F;邮箱），用于账号注册。</p><p>这里是以管理员账号去创建的普通用户（注意是普通用户），权限在添加到群组中时再赋予。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214174734982.png" alt="image-20221214174734982"></p><h5 id="2、用户访问"><a href="#2、用户访问" class="headerlink" title="2、用户访问"></a>2、用户访问</h5><p>账号注册完成后即可登录到自己的 Gitlab 端，首次登录用户需进行初始密码修改，修改后需牢记密码，防止数据丢失。</p><h5 id="3、创建群组"><a href="#3、创建群组" class="headerlink" title="3、创建群组"></a>3、创建群组</h5><p>（1）创建群组</p><p>【群组】–&gt;【您的群组】–&gt;【新建群组】</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214174753848.png" alt="image-20221214174753848"></p><p>（2）设置群组</p><blockquote><p>私有：仅该组组员才有权限查看该项目</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214174808158.png" alt="image-20221214174808158"></p><p>（3）将用户添加到群组中</p><ul><li><p>添加用户到群组</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214174825153.png" alt="image-20221214174825153"></p></li><li><p>用户权限划分</p><p>在这里就涉及到了用户的权限问题，可根据项目组来确定，一般会设置我们的项目主管为该项目的项目管理员，其他成员则为普通的研发人员。</p><ul><li><p>项目管理员（Owner）</p><p>是该群组和项目组的管理员，权限仅次于 Gitlab 管理员，可批准代码合并请求并进行合并（合并到 master 分支）。</p></li><li><p>普通成员（Dev）</p><p>加入群组的普通成员均有权限查看所在组的项目详情，同时可进行相应的 clone 操作。</p></li></ul></li></ul><h5 id="4、创建项目"><a href="#4、创建项目" class="headerlink" title="4、创建项目"></a>4、创建项目</h5><p>（1）创建项目</p><p>【项目】–&gt;【新建项目】</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214174839937.png" alt="image-20221214174839937"></p><p>【创建空白项目】：当然也可导入项目</p><blockquote><p>注：不同的 Gitlab 版本可能有些差异，我这里是中文版的，英文版的话是 Create a project（看不习惯中文可进行中英文切换，设置方法在后面）</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214174854685.png" alt="image-20221214174854685"></p><p>（2）设置项目</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214174912124.png" alt="image-20221214174912124"></p><p>（3）创建分支</p><blockquote><p>具体的分支内容以研发那边为准进行确定。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214181204879.png" alt="image-20221214181204879"></p><blockquote><p>输入分支名称：</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214181222319.png" alt="image-20221214181222319"></p><p>（4）合并分支</p><ul><li><p>研发人员的合并请求操作</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214181244230.png" alt="image-20221214181244230"></p></li><li><p>项目主管批准并进行合并操作</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214181321758.png" alt="image-20221214181321758"></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214181345862.png" alt="image-20221214181345862"></p></li></ul><h5 id="5、Clone-项目"><a href="#5、Clone-项目" class="headerlink" title="5、Clone 项目"></a>5、Clone 项目</h5><p>（1）生成秘钥</p><blockquote><p>研发人员在 Windows 上生成秘钥</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen.exe -C <span class="string">&quot;xxxx@126.com&quot;</span></span></span><br></pre></td></tr></table></figure><p>（2）上传公钥至 Gitlab </p><blockquote><p>把公钥上传至自己的 Gitlab 上（登录gitlab，按下图操作）</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub     <span class="comment"># 上传cat的内容至gitlab</span></span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214181422324.png" alt="image-20221214181422324"></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214181436337.png" alt="image-20221214181436337"></p><p>（3）配置个人的用户名称和电子邮件地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.name <span class="string">&quot;name&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.email <span class="string">&quot;test@163.com&quot;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>注：user.name 和 user.email 是你 gitlab 上的用户名称和电子邮件</p></blockquote><p>（4）clone 项目到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> ssh://git@10.20.10.62:2022/mygroup/myproject.git</span></span><br></pre></td></tr></table></figure><h5 id="6、Gitlab-语言设置"><a href="#6、Gitlab-语言设置" class="headerlink" title="6、Gitlab 语言设置"></a>6、Gitlab 语言设置</h5><p>每个用户登录 Gitlab 默认的语言是 English 可个人情况进行中英文切换，保存后刷新一下即可，具体步骤如下：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214181452446.png" alt="image-20221214181452446"></p><h4 id="三、Gitlab-管理"><a href="#三、Gitlab-管理" class="headerlink" title="三、Gitlab 管理"></a>三、Gitlab 管理</h4><h5 id="1、项目管理"><a href="#1、项目管理" class="headerlink" title="1、项目管理"></a>1、项目管理</h5><p>（1）代码管理</p><p>代码通过相应的开发人员进行开发，将开发好的代码 push 到 Gitlab 上进行代码托管。这里重点在于如何备份&#x2F;恢复&#x2F;迁移数据的问题。</p><p>（2）分支管理</p><p>分支主要有研发人员那边来确定，具体的操作步骤在上述【创建群组】中有提到。</p><h5 id="2、数据备份"><a href="#2、数据备份" class="headerlink" title="2、数据备份"></a>2、数据备份</h5><p>（1）查看版本信息</p><p>在数据备份或数据迁移前，应查看对应的系统版本、软件版本等因素，否则可能会导致迁移后数据的不可用。这里以 CentOS 7 为例进行数据备份、恢复和迁移测试。CentOS 8 操作步骤一样。</p><ul><li><p>CentOS 系统版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /etc/redhat-release</span> </span><br><span class="line">CentOS Linux release 7.4.1708 (Core)</span><br></pre></td></tr></table></figure></li><li><p>Gitlab 软件版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /opt/gitlab/embedded/service/gitlab-rails/VERSION</span></span><br><span class="line">13.5.1</span><br></pre></td></tr></table></figure></li></ul><p>（2）数据备份</p><p>在数据备份这里需要注意，当我们在执行备份操作时，为了保证备份数据的一致性，应事先停掉我们的Gitlab服务，如果不停掉的话，可能我们在备份的过程中有其他研发人员进行数据的上传，从而导致备份数据的不一致性和不完整性，甚至出现一些不可预估的错误。</p><ul><li><p>停Gitlab服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gitlab-ctl stop unicorn</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gitlab-ctl stop sidekiq</span></span><br><span class="line">ok: down: sidekiq: 0s, normally up</span><br></pre></td></tr></table></figure><p>打开&#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb配置文件，查看一个和备份相关的配置项：<code>gitlab_rails[&#39;backup_path&#39;] = &quot;/data/gitlab/backups&quot;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vim /etc/gitlab/gitlab.rb</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214181519087.png" alt="image-20221214181519087"></p><p>该项定义了默认备份出文件的路径，可以通过修改该配置，并执行 <strong>gitlab-ctl reconfigure 或者 gitlab-ctl  restart</strong> 重启服务生效。</p></li></ul><p>（3）开始备份</p><blockquote><p>接下来我们通过备份命令进行数据备份，备份后的数据默认存放在该路径下：<code>/var/opt/gitlab/backups/</code></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> /var/opt/gitlab/backups/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gitlab-rake gitlab:backup:create    <span class="comment"># 开始备份（等待..）</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">1604716638_2020_11_07_13.5.1_gitlab_backup.tar     # 备份后的数据包</span><br></pre></td></tr></table></figure><blockquote><p>也可以添加到 crontab 中定时执行：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 3 * * * /opt/gitlab/bin/gitlab-rake gitlab:backup:create</span><br></pre></td></tr></table></figure><p>可以到&#x2F;data&#x2F;gitlab&#x2F;backups找到备份包，解压查看，会发现备份的还是比较全面的，数据库、repositories、build、upload等分类还是比较清晰的。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214181534308.png" alt="image-20221214181534308"></p><h5 id="3、数据恢复"><a href="#3、数据恢复" class="headerlink" title="3、数据恢复"></a>3、数据恢复</h5><p>（1）删除数据</p><p>为了测试效果，这里我们模拟不小心删掉了项目的某个文件（当然了这里是可以通过<code>log</code>回滚的，假设这里已经删了很久了）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">html  README.md</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> -r html/   <span class="comment"># 删除文件</span></span></span><br><span class="line">rm &#x27;html/index.html&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add .</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&#x27;意外删除html文件&#x27;</span></span></span><br><span class="line">[dev 0c35330] 意外删除html文件</span><br><span class="line"> 1 file changed, 3 deletions(-)</span><br><span class="line"> delete mode 100644 html/index.html</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push sz dev   <span class="comment"># 提交代码</span></span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214181552992.png" alt="image-20221214181552992"></p><p>（2）停Gitlab服务</p><blockquote><p>当我们在做数据备份和数据迁移时，应先停这两个服务，目的是为了保证数据的一致性。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gitlab-ctl stop unicorn</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gitlab-ctl stop sidekiq</span></span><br><span class="line">ok: down: sidekiq: 0s, normally up</span><br></pre></td></tr></table></figure><p>（3）权限</p><blockquote><p>注意权限：600权限是无权恢复的。 实验环境可改成了777，生产环境建议修改属主属组。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">pwd</span></span></span><br><span class="line">/data/gitlab/backups</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">chmod</span> 777 1604716638_2020_11_07_13.5.1_gitlab_backup.tar</span></span><br></pre></td></tr></table></figure><p>（4）开始恢复数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">1604716638_2020_11_07_13.5.1_gitlab_backup.tar</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gitlab-rake gitlab:backup:restore BACKUP=1604716638_2020_11_07_13.5.1</span></span><br></pre></td></tr></table></figure><p>（5）启动Gitlab服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gitlab-ctl start unicorn</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gitlab-ctl start sidekiq</span></span><br><span class="line">ok: run: sidekiq: (pid 9457) 1s</span><br><span class="line"></span><br><span class="line">或：</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gitlab-ctl restart</span></span><br></pre></td></tr></table></figure><p>（6）恢复验证</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214181610920.png" alt="image-20221214181610920"></p><p>至此，数据成功恢复。</p><h5 id="4、数据迁移"><a href="#4、数据迁移" class="headerlink" title="4、数据迁移"></a>4、数据迁移</h5><p>（1）停Gitlab服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gitlab-ctl stop unicorn</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gitlab-ctl stop sidekiq</span></span><br><span class="line">ok: down: sidekiq: 0s, normally up</span><br></pre></td></tr></table></figure><p>（2）数据迁移</p><p>将老服务器<code>/data/gitlab/backups</code>目录下的备份文件拷贝到新服务器上的<code>/data/gitlab/backups</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rsync -avz 1604716638_2020_11_07_13.5.1_gitlab_backup.tar 10.20.151.135:/data/gitlab/backups/</span> </span><br></pre></td></tr></table></figure><h5 id="5、用户管理"><a href="#5、用户管理" class="headerlink" title="5、用户管理"></a>5、用户管理</h5><p>（1）用户创建</p><p>用户创建的过程在使用教程的那一节已经做了详细的介绍，可按照该方法进行用户创建。</p><p>（2）用户权限</p><p>在创建用户的时候是不需要授权的，也就说刚开始创建的时候都是普通用户，其授权是在将成员添加到群组的时候进行的，即该用户对该群组所拥有的权限，一般我们的项目主管会设置为群组管理员，其他成员为普通的开发人员，在该群组的这些成员可以查看当前组的所有项目并进行 clone 操作。</p><p>（3）员工离职</p><p>对于员工离职删除员工账户数据保留的问题，员工要离职前，他应将他所写的代码 push 到 gitlab 的对应分支上，这样在后面有新员工入职时可接手其上一个项目。比如要离职的某员工先将代码 push 到 dev 分支上，后面新员工注册相应的账户后 <code>git pull --rebase origin dev</code>整合代码，该命令的作用是：取回远程主机某个分支的更新，再与本地的指定分支合并。</p><h4 id="四、Gitlab-客户端"><a href="#四、Gitlab-客户端" class="headerlink" title="四、Gitlab 客户端"></a>四、Gitlab 客户端</h4><h5 id="1、Client1"><a href="#1、Client1" class="headerlink" title="1、Client1"></a>1、Client1</h5><p>（1）Git下载</p><p>下载地址：<a href="https://gitforwindows.org/">https://gitforwindows.org/</a></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214181630869.png" alt="image-20221214181630869"></p><p>（2）Git 使用教程</p><ul><li><p>打开 Git 客户端</p><p>安装完成后，点击【开始菜单】–&gt;【Git Bash】 </p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214181650294.png" alt="image-20221214181650294"></p></li><li><p>生成秘钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen  -t rsa -C <span class="string">&quot;xxxx@126.com&quot;</span>    <span class="comment"># 你Gitlab对应的邮箱账户</span></span></span><br></pre></td></tr></table></figure></li><li><p>上传公钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub     <span class="comment"># 将cat的内容上传至 Gitlab</span></span> </span><br></pre></td></tr></table></figure></li><li><p>配置 Git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.email <span class="string">&quot;xxxx@126.com&quot;</span>     <span class="comment"># 你 Gitlab 邮箱对应的邮箱账户</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.name <span class="string">&quot;win&quot;</span>      <span class="comment"># 你 Gitlab 的用户名</span></span></span><br></pre></td></tr></table></figure></li><li><p>Clone 项目</p><p>首先 clone 的项目需要放到哪里，选择好文件夹，比如我 D 盘下的 project 文件夹，操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /d/project/      <span class="comment"># 作为项目仓库</span></span></span><br></pre></td></tr></table></figure><p>SSH方式：</p><blockquote><p>这种方式clone项目的优势在于不需要每次clone时都需要输密码</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> ssh://git@10.20.10.62:2022/mygroup/myproject.git</span></span><br></pre></td></tr></table></figure><p>HTTP方式：</p><blockquote><p>这种方式clone的项目时每次都需要输入账户和密码</p><p>账户：是你当前登录的 Gitlab 账户</p><p>密码：Gitlab 账户对应的登录密码</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> http://10.20.10.62:2080/mygroup/myproject.git</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>在每次编写代码时，第一步先去 Git 仓库拉取（pull）代码，否则会造成冲突，因为不添加的话，你修改了别人的内容，就会造成相关错误。</p></li><li><p>创建分支</p><p>创建分支并切换到分支：一般会在 gitlab 上创建好分支，研发人员根据gitlab上的分支，再在Git客户端上创建对应的分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b dev    <span class="comment"># 创建dev分支并切换到dev分支</span></span></span><br><span class="line">或</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch dev      <span class="comment"># 创建dev分支</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout dev    <span class="comment"># 切换到dev分支</span></span></span><br></pre></td></tr></table></figure></li><li><p>删除分支</p><p>删除已合并分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d 分支名</span><br></pre></td></tr></table></figure><p>删除未合并分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D 分支名</span><br></pre></td></tr></table></figure></li></ul><h5 id="2、Client2"><a href="#2、Client2" class="headerlink" title="2、Client2"></a>2、Client2</h5><p>下载地址：<a href="https://tortoisegit.org/download/">https://tortoisegit.org/download/</a></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221214181720622.png" alt="image-20221214181720622"></p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
          <category> Gitlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CICD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitlab 项目自动同步</title>
      <link href="/posts/articles/c74519c0.html"/>
      <url>/posts/articles/c74519c0.html</url>
      
        <content type="html"><![CDATA[<p><strong>1、同步思路</strong></p><ul><li><p>A 和 B 两台 Gitlab 服务；</p></li><li><p>将 A 项目同步到 B；</p></li><li><p>在 A 上 Settings –&gt; Repository –&gt; Mirroring repositories 设置 B 的镜像仓库；</p></li><li><p>当 A 每次 push 时，就会自动同步到 B。</p></li></ul><p><strong>2、版本问题</strong></p><ul><li><p>保证两台服务的 Gitlab 版本一致且版本不要太低，保证在 12 及以上，因为老版本可能没有 <strong>Mirroring repositories</strong> 这个设置；</p></li><li><p>版本过低，可进行版本升级。注意在升级前做好数据备份，防止升级失败；</p></li><li><p>Gitlab 向上兼容，新版本的数据无法导入旧版本；</p></li></ul><p><strong>3、目前版本</strong></p><ul><li><p>A：gitlab-ce      10.2.2</p></li><li><p>B：gitlab-ce      13.7.1</p><blockquote><p><strong>问题：</strong></p><p>由于 A 服务的 Gitlab 版本过低，缺少 <strong>Mirroring repositories</strong>（该参数用来配置远程服务器），所以无法实现项目自动同步。 </p><p><strong>解决方案：</strong></p><p>升级 A 服务的 Gitlab 版本同 B 一致。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
          <category> Gitlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CICD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitlab 备份与迁移</title>
      <link href="/posts/articles/3da9adc.html"/>
      <url>/posts/articles/3da9adc.html</url>
      
        <content type="html"><![CDATA[<p><strong>1、服务器</strong></p><table><thead><tr><th>主机</th><th>版本</th><th>备注</th></tr></thead><tbody><tr><td>10.20.10.3</td><td>10.2.2</td><td>老服务器（数据备份）</td></tr><tr><td>10.20.10.4</td><td>10.2.2</td><td>新服务器（将老服务器迁移至新服务器）</td></tr></tbody></table><p><strong>2、需要备份的文件</strong></p><ul><li>gitlab.rb 配置文件：&#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb</li><li>nginx 配置文件：&#x2F;var&#x2F;opt&#x2F;gitlab&#x2F;nginx&#x2F;conf </li><li>postfix 配置文件：&#x2F;etc&#x2F;postfix&#x2F;main.cf</li></ul><p><strong>3、数据备份</strong></p><ul><li><p>备份整体数据</p><blockquote><p>在不停掉 Gitlab 的情况下进行备份，实际备份的数据会包含：数据库脚本、代码仓库、wiki、大文件、ssh用户秘钥等数据。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /var/opt/gitlab/backups  # 默认备份路径（可修改）</span><br><span class="line">gitlab-rake gitlab:backup:create</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定时备份</span></span><br><span class="line">00 00 * * 6 /usr/bin/gitlab-rake gitlab:backup:create</span><br></pre></td></tr></table></figure></li><li><p>备份 gitlab.rb</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/gitlab/gitlab.rb /root/</span><br><span class="line">或</span><br><span class="line">rz 到本地</span><br></pre></td></tr></table></figure></li><li><p>备份 nginx conf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp /var/opt/gitlab/nginx/conf /root/ </span><br><span class="line">或</span><br><span class="line">rz 到本地</span><br></pre></td></tr></table></figure></li><li><p>备份 postfix</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/postfix/main.cf /root/</span><br><span class="line">或</span><br><span class="line">rz 到本地</span><br></pre></td></tr></table></figure></li><li><p>设置备份过期时间（单位：s）</p><blockquote><p>设置只保存最近7天的备份</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/gitlab/gitlab.rb</span><br><span class="line">gitlab_rails[&#x27;backup_keep_time&#x27;] = 604800</span><br></pre></td></tr></table></figure></li></ul><p><strong>4、数据迁移</strong></p><ul><li><p>将老服务器备份数据 scp 到新服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp 1611821930_2021_01_28_10.2.2_gitlab_backup.tar root@10.20.10.4:/var/opt/gitlab/backups</span><br></pre></td></tr></table></figure></li><li><p>数据包权限</p><blockquote><p>如果是在本地进行恢复，可以不用赋权。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 1611821930_2021_01_28_10.2.2_gitlab_backup.tar</span><br></pre></td></tr></table></figure></li></ul><p><strong>5、数据恢复</strong></p><ul><li><p>停 Gitlab 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl stop unicorn</span><br><span class="line">gitlab-ctl stop sidekiq</span><br></pre></td></tr></table></figure></li><li><p>进行数据恢复</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-rake gitlab:backup:restore BACKUP=1611821930_2021_01_28_10.2.2</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ul><li><p>BACKUP&#x3D;备份文件编号，没有后面的_gitlab_backup.tar部分</p></li><li><p>恢复过程中出现两个（yes&#x2F;no），输入两个yes即可。</p></li><li><p>在进行数据恢复时，会根据新服务器的gitlab.rb配置路径进行恢复，如：旧服务器的仓库存储位置为&#x2F;var&#x2F;opt&#x2F;gitlab&#x2F;git-data&#x2F;repositories，新服务器的仓库存储位置为&#x2F;data&#x2F;gitlab&#x2F;git-data&#x2F;repositories。进行数据恢复时都会对&#x2F;data&#x2F;gitlab&#x2F;git-data&#x2F;repositories进行自动备份：&#x2F;data&#x2F;gitlab&#x2F;git-data&#x2F;repositories.old.1611903424</p></li><li><p>进行数据恢复时，尽量保持新老服务器的 Gitlab 文件配置一致，如：仓库路径、备份路径等。如果仓库路径不一致可能会导致数据恢复失败，恢复完成后再自行修改为其他的仓库路径。</p></li></ul></blockquote></li></ul><p><strong>6、Gitlab仓库存储更改</strong></p><blockquote><p><strong>注意：</strong></p><ul><li>每次修改仓库存储路径更改前，都<strong>必需</strong>先完整备份一次数据，用于更改仓库路径后进行数据恢复，否则会导致项目数据丢失。</li><li>该路径用于存放项目代码。默认路径：&#x2F;var&#x2F;opt&#x2F;gitlab&#x2F;git-data&#x2F;</li><li>git_data_dir “&#x2F;mnt&#x2F;sda3&#x2F;git-data”这种修改方式刷新配置时会错误，原因是该方式已经在11.0被废弃了，所以11.0以后版本使用git_data_dirs代替了。测试了10.2.2版本两种方式都可用。</li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vim /etc/gitlab/gitlab.rb</span></span><br><span class="line">git_data_dirs(&#123;</span><br><span class="line">  &quot;default&quot; =&gt; &#123;</span><br><span class="line">    &quot;path&quot; =&gt; &quot;/home/gitlab/git-data/&quot;,</span><br><span class="line">    &quot;failure_count_threshold&quot; =&gt; 10,</span><br><span class="line">    &quot;failure_wait_time&quot; =&gt; 30,</span><br><span class="line">    &quot;failure_reset_time&quot; =&gt; 1800,</span><br><span class="line">    &quot;failure_timeout&quot; =&gt; 30</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><p><strong>7、Gitlab 备份路径</strong></p><blockquote><p>默认路径：&#x2F;var&#x2F;opt&#x2F;gitlab&#x2F;backups</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vim /etc/gitlab/gitlab.rb</span></span><br><span class="line"></span><br><span class="line">gitlab_rails[‘manage_backup_path’] = true</span><br><span class="line">gitlab_rails[‘backup_path’] = &quot;/data/gitlab/backups&quot;    # gitlab备份目录</span><br><span class="line">gitlab_rails[‘backup_archive_permissions’] = 0644       # 生成的备份文件权限</span><br><span class="line">gitlab_rails[‘backup_keep_time’] = 604800               # 备份保留天数为7天</span><br><span class="line">“</span><br><span class="line">mkdir -p /data/gitlab/backups</span><br><span class="line">chown -R git.root /data/gitlab/backups</span><br><span class="line">chmod -R 777 /data/gitlab/backups</span><br><span class="line"></span><br><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
          <category> Gitlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CICD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitlab-ce 跨大版本升级</title>
      <link href="/posts/articles/8dd1dd53.html"/>
      <url>/posts/articles/8dd1dd53.html</url>
      
        <content type="html"><![CDATA[<p><strong>1、升级路径</strong></p><blockquote><p>官方提供的升级路径如下</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230330222121129.png" alt="image-20230330222121129"></p><table><thead><tr><th>目前版本</th><th>可升级路径</th><th>最终版本</th></tr></thead><tbody><tr><td>10.2.2</td><td>10.2.2-&gt;10.8.7-&gt;11.11.8-&gt;12.0.12-&gt;12.1.17-&gt;12.10.14-&gt;13.0.14-&gt;13.1.11-&gt;13.x(latest)</td><td>13.7.1</td></tr></tbody></table><p><strong>2、记录当前版本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list | grep gitlab-ce</span><br></pre></td></tr></table></figure><p><strong>3、备份数据</strong></p><blockquote><p>提前修改备份目录（如果数据少，默认备份目录也行）</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line">gitlab_rails[‘manage_backup_path’] = true</span><br><span class="line">gitlab_rails[‘backup_path’] = “/data/gitlab/backups”    # gitlab备份目录</span><br><span class="line">gitlab_rails[‘backup_archive_permissions’] = 0644       # 生成的备份文件权限</span><br><span class="line">gitlab_rails[‘backup_keep_time’] = 604800               # 备份保留天数为7天</span><br></pre></td></tr></table></figure><blockquote><p>权限：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/gitlab/backups</span><br><span class="line">chown -R git.root /data/gitlab/backups</span><br><span class="line">chmod -R 777 /data/gitlab/backups</span><br></pre></td></tr></table></figure><blockquote><p>重载：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><blockquote><p>备份：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-rake gitlab:backup:create</span><br></pre></td></tr></table></figure><p><strong>4、配置 gitlab-yum 源</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt; EOF &gt; /etc/yum.repos.d/gitlab-ce.repo</span><br><span class="line">[gitlab-ce]</span><br><span class="line">name=gitlab-ce</span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgcheck=0</span><br><span class="line">enable=1</span><br><span class="line">gpgkey=https://packages.gitlab.com/gpg.key</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p><strong>5、 yum install 安装（在线升级）</strong></p><blockquote><p>参照官方推荐升级路径，依次执行下面指令逐步升级：每次只能升级到当前版本的最大版本，才能升级下一个大版本。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl stop unicorn &amp;&amp; gitlab-ctl stop sidekiq &amp;&amp; gitlab-ctl stop nginx</span><br><span class="line">yum install -y gitlab-ce-10.8.7</span><br><span class="line">gitlab-rake db:migrate</span><br><span class="line">gitlab-ctl start unicorn &amp;&amp; gitlab-ctl start sidekiq &amp;&amp; gitlab-ctl start nginx</span><br><span class="line">cat /opt/gitlab/embedded/service/gitlab-rails/VERSION</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">完成后会在备份目录自动备份一份数据</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果发现界面500，不可访问，那么执行gitlab-ctl reconfigure指令刷新配置文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一定保证数据可以正常访问方可执行下一步升级指令</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以下按同样操作执行...</span><br><span class="line">yum install -y gitlab-ce-11.11.8</span><br><span class="line">yum install -y gitlab-ce-12.0.12</span><br><span class="line">yum install -y gitlab-ce-12.1.17</span><br><span class="line">yum install -y gitlab-ce-12.10.14</span><br><span class="line">yum install -y gitlab-ce-13.0.14</span><br><span class="line">yum install -y gitlab-ce-13.1.11</span><br><span class="line">yum install -y gitlab-ce-13.7.1     # 最终版本（根据实际情况选择最终版本）</span><br></pre></td></tr></table></figure><p><strong>6、注意事项</strong></p><p>安装完成后，根据需要修改配置文件<code>/etc/gitlab/gitlab.rb</code>，也可以直接使用原来备份好的<code>gitlab.rb</code>文件，执行重新配置命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><p>接着重启即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl restart</span><br></pre></td></tr></table></figure><p>如果返回500状态码，重载一下配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><p>数据库版本问题：</p><blockquote><p>升级完成后报错，有时候可能是数据库版本问题，可执行下条命令进行升级：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl pg-upgrade -V 12  # 指定对应版本</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
          <category> Gitlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CICD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 18.04 永久设置 DNS</title>
      <link href="/posts/articles/b22a3008.html"/>
      <url>/posts/articles/b22a3008.html</url>
      
        <content type="html"><![CDATA[<p>查看当前操作系统版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure><p><strong>这里 Ubuntu 修改 DNS 只适用与18.0左右以上的操作系统</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim  /etc/systemd/resolved.conf</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先修改 /etc/systemd/resolved.conf 配置文件，</span></span><br><span class="line"></span><br><span class="line">sudo vim  /etc/systemd/resolved.conf</span><br><span class="line">DNS=8.8.8.8</span><br><span class="line">DNS=114.114.114.114</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存退出后执行 systemctl daemon-reload 重新加载配置文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重要步骤，不reload 服务重启不生效新配置</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在执行 systemctl restart systemd-resolved 重启服务</span></span><br><span class="line">systemctl restart systemd-resolved</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份原resolve.conf, 在将新的 resolv.conf 做个链接到 /etc</span></span><br><span class="line">mv /etc/resolv.conf /etc/resolv.conf.bak</span><br><span class="line">ln -s /run/systemd/resolve/resolv.conf /etc/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
          <category> DNS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
