<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rabcnops</title>
  
  <subtitle>Welcome to my tech blog</subtitle>
  <link href="https://blog.rabcnops.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.rabcnops.cn/"/>
  <updated>2023-06-05T03:48:29.487Z</updated>
  <id>https://blog.rabcnops.cn/</id>
  
  <author>
    <name>Rab</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker attach VS exec</title>
    <link href="https://blog.rabcnops.cn/posts/articles/1968d59e.html"/>
    <id>https://blog.rabcnops.cn/posts/articles/1968d59e.html</id>
    <published>2023-06-05T03:33:14.000Z</published>
    <updated>2023-06-05T03:48:29.487Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/docker-attach.webp" alt="docker-attach"></p><hr><p>我们知道，进入容器常用的两种方式为：<code>docker exec ...</code>、<code>docker attach ...</code>，那这两者有什么区别呢？</p><p>首先，运行一个测试容器，并在启动容器时运行相关指令，如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name <span class="built_in">test</span> -d ubuntu /bin/bash -c <span class="string">&quot;while true; do sleep 1; echo hello world; done&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230605112140003.png" alt="image-20230605112140003"></p><p><strong>1、attach 进入容器</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/20230605112331.png"></p><p>如何退出容器而不停止容器运行？方法：<code>Ctrl + p  + q</code>，如果使用 <code>exit</code> 那退出容器后，容器也会随之停止运行。</p><p><strong>2、exec 进入容器</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230605113008592.png" alt="image-20230605113008592"></p><p>那这又如何退出容器呢？exec 方式的话，直接 exit 退出容器即可（且容器不会停止运行）。</p><p>从这两者方式进入容器，不难发现，这两者的主要区别如下：</p><ul><li>attach 直接进入容器启动命令的终端，不会启动新进程，并以 <code>Ctrl + p  + q</code> 不终止容器退出；</li><li>exec 则是在容器中打开新的终端，且可启动新的进程，以 <code>exit</code> 不终止容器退出；</li><li>因此，如果想直接在终端中查看启动命令的输出，可使用 <code>attach</code>，否则使用 <code>exec</code>。</li></ul><p>但实际生产中，看启动输出，一般我们是通过 <code>docker logs -f ...</code> 命令，如下图所示：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230605113739418.png" alt="image-20230605113739418"></p><p>其中 <code>-f</code> 选项是以动态的形式查看输出结果，效果类似 <code>tailf</code> 或 <code>tail -f</code>。</p><p>-–END</p>]]></content>
    
    
    <summary type="html">Docker attach 与 exec 的区别。</summary>
    
    
    
    <category term="云原生" scheme="https://blog.rabcnops.cn/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    <category term="Docker" scheme="https://blog.rabcnops.cn/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/Docker/"/>
    
    
    <category term="Docker" scheme="https://blog.rabcnops.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>基于 VuePress 的 RECO 主题博客系统搭建</title>
    <link href="https://blog.rabcnops.cn/posts/articles/a90bd9b5.html"/>
    <id>https://blog.rabcnops.cn/posts/articles/a90bd9b5.html</id>
    <published>2023-05-28T05:33:14.000Z</published>
    <updated>2023-05-28T06:08:35.207Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230528135648671.png" alt="image-20230528135648671"></p><hr><h2 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h2><ul><li><strong>Windows</strong>：10</li><li><strong>NodeJs</strong>：v18.15.0</li><li><strong>Npm</strong>：v9.5.0（含于NodeJs）</li><li><strong>Yarn</strong>：1.22.19（通过 npm 安装）</li></ul><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><p><strong>1、npm 安装 yarn</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn --registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置源</span></span><br><span class="line">yarn config <span class="built_in">set</span> registry https://registry.npm.taobao.org -g</span><br><span class="line">yarn config <span class="built_in">set</span> sass_binary_site http://cdn.npm.taobao.org/dist/node-sass -g</span><br></pre></td></tr></table></figure><p><strong>2、初始化项目</strong></p><blockquote><p><a href="https://v1.vuepress.vuejs.org/zh/guide/getting-started.html">https://v1.vuepress.vuejs.org/zh/guide/getting-started.html</a></p><p>按照步骤一步步执行，并最终启动即可，过程中若遇到错误，请看 FAQ 部分。</p></blockquote><p><strong>3、本地访问验证</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230427111334709.png" alt="image-20230427111334709"></p><p><mark>如何添加状态栏？</mark></p><p><strong>4、docs 目录下创建 .vuepress 目录</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> .vuepress </span><br></pre></td></tr></table></figure><p><strong>5、.vuepress  目录下创建 config.js 文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> config.js</span><br></pre></td></tr></table></figure><p><strong>6、config.js 文件中添加如下内容</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    title: <span class="string">&#x27;Rabcnops&#x27;</span>,</span><br><span class="line">    description: <span class="string">&#x27;云计算、云原生、云开发学习文档！&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230427170306751.png" alt="image-20230427170306751"></p><h2 id="三、RECO-主题"><a href="#三、RECO-主题" class="headerlink" title="三、RECO 主题"></a>三、RECO 主题</h2><blockquote><p>主题地址：<a href="https://vuepress-theme-reco.recoluan.com/">vuepress-reco (recoluan.com)</a></p></blockquote><h3 id="3-1-初始化"><a href="#3-1-初始化" class="headerlink" title="3.1 初始化"></a>3.1 初始化</h3><p>1、初始化环境</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化，并选择 2.x</span></span><br><span class="line">npm install @vuepress-reco/theme-cli@1.0.7 -g</span><br><span class="line">theme-cli init my-blog   <span class="comment"># 初始化一个my-blog工程（自定义）</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230427173913739.png" alt="image-20230427173913739"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230427183712771.png" alt="image-20230427183712771"></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230427183517241.png" alt="image-20230427183517241"></p><h3 id="3-2-说明"><a href="#3-2-说明" class="headerlink" title="3.2 说明"></a>3.2 说明</h3><p>这个主题暂时先不研究了，后面打算通过 Python 自行开发一套。</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="启动服务报错"><a href="#启动服务报错" class="headerlink" title="启动服务报错"></a>启动服务报错</h3><p><strong>1、报错现象</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn docs:dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行报错</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221209113113605.png" alt="image-20221209113113605"></p><p><strong>2、报错原因</strong></p><p>出现这个错误是因为 node.js V17 版本中最近发布的OpenSSL3.0, 而OpenSSL3.0对允许算法和密钥大小增加了严格的限制，可能会对生态系统造成一些影响.</p><p><strong>3、解决方案</strong></p><p>有两种解决方案：<code>降级到 Node.js v16</code>或<code>启用旧版 OpenSSL 提供程序</code></p><ul><li><p>降低版本至 node.js V16（永久解决）</p></li><li><p>终端执行启用旧版 OpenSSL 相关命令（临时解决）</p><ul><li><p>在类 Unix 上（Linux、macOS、Git bash 等）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NODE_OPTIONS=--openssl-legacy-provider</span><br></pre></td></tr></table></figure></li><li><p>在 Windows 命令提示符下（CMD）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> NODE_OPTIONS=--openssl-legacy-provider</span><br></pre></td></tr></table></figure></li><li><p>在 Windows PowerShell 上</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$env</span>:NODE_OPTIONS = <span class="string">&quot;--openssl-legacy-provider&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>完成之后，再次启动服务即可解决！</p>]]></content>
    
    
    <summary type="html">基于 VuePress 的 RECO 主题博客系统搭建。</summary>
    
    
    
    <category term="Blog" scheme="https://blog.rabcnops.cn/categories/Blog/"/>
    
    <category term="VuePress" scheme="https://blog.rabcnops.cn/categories/Blog/VuePress/"/>
    
    
    <category term="VuePress" scheme="https://blog.rabcnops.cn/tags/VuePress/"/>
    
  </entry>
  
  <entry>
    <title>EduSoho 网校部署</title>
    <link href="https://blog.rabcnops.cn/posts/articles/e7cab59a.html"/>
    <id>https://blog.rabcnops.cn/posts/articles/e7cab59a.html</id>
    <published>2023-05-24T09:05:00.000Z</published>
    <updated>2023-05-24T09:08:37.837Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230524094717828.png" alt="image-20230524094717828"></p><hr><h2 id="一、初始化环境"><a href="#一、初始化环境" class="headerlink" title="一、初始化环境"></a>一、初始化环境</h2><p><strong>1、安装wget</strong></p><p>如果系统已安装wget,请跳过此步骤</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install wget</span><br></pre></td></tr></table></figure><p><strong>2、关闭防火墙&#x2F;Selinux</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure><p>在命令行输入：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0</span><br></pre></td></tr></table></figure><p>或者修改配置文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/selinux/config</span><br></pre></td></tr></table></figure><p>将<code>SELINUX=enforcing</code>改为：<code>SELINUX=disabled</code></p><h2 id="二、安装-Nginx"><a href="#二、安装-Nginx" class="headerlink" title="二、安装 Nginx"></a>二、安装 Nginx</h2><p><strong>1、安装nginx源</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#下载源</span></span><br><span class="line">wget https://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装源</span></span><br><span class="line">rpm -ivh nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br></pre></td></tr></table></figure><p><strong>2、安装配置nginx包</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装nginx</span></span><br><span class="line">yum install -y nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改nginx默认配置</span></span><br><span class="line">vim /etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#在http&#123;&#125;配置中加入：</span></span><br><span class="line">client_max_body_size 1024M;</span><br></pre></td></tr></table></figure><p><strong>3、启动nginx</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx.service</span><br></pre></td></tr></table></figure><p><strong>4、设置nginx为开机启动</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> nginx.service</span><br></pre></td></tr></table></figure><h2 id="三、安装-MySQL"><a href="#三、安装-MySQL" class="headerlink" title="三、安装 MySQL"></a>三、安装 MySQL</h2><p><strong>1、安装mysql官方源</strong></p><p>注意 CentOS 7 默认 mysql 版本过低，这里我们采用 mysql 官方发行的 MySQL57 源,当然，也可以安装MySQL80的源。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://repo.mysql.com/mysql57-community-release-el7.rpm</span><br><span class="line">rpm -ivh mysql57-community-release-el7.rpm</span><br></pre></td></tr></table></figure><p><strong>2、建立 Yum 缓存</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><p><strong>3、安装mysql包</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y mysql mysql-server</span><br></pre></td></tr></table></figure><p><strong>4、启动mysql</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld.service</span><br></pre></td></tr></table></figure><p><strong>5、设置mysql为开机启动</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> mysqld.service</span><br></pre></td></tr></table></figure><p><strong>6、mysql 配置</strong></p><p>默认安装结束，mysql的root密码不为空，系统默认创建临时密码，执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&#x27;temporary password&#x27;</span> /var/log/mysqld.log</span><br></pre></td></tr></table></figure><p>可以看到密码，如例子</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-02-28T06:52:06.110216Z 1 [Note] A temporary password is generated <span class="keyword">for</span> root@localhost: **************</span><br></pre></td></tr></table></figure><p>后面<code>*</code>的位置就是临时密码，要手动修改mysql <code>root</code>账户密码，否则mysql会不允许创核表等操作，mysql 修改密码操作请自行搜索解决。</p><p>修改密码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -u root -p<span class="string">&#x27;&lt;初始密码&gt;&#x27;</span>  password <span class="string">&#x27;&lt;新密码&gt;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="四、安装-PHP"><a href="#四、安装-PHP" class="headerlink" title="四、安装 PHP"></a>四、安装 PHP</h2><blockquote><p>参考：<a href="https://www.myfreax.com/install-php-7-on-centos-7/">https://www.myfreax.com/install-php-7-on-centos-7/</a></p></blockquote><p><strong>1、安装php源</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release yum-utils</span><br><span class="line">yum install -y http://rpms.remirepo.net/enterprise/remi-release-7.rpm</span><br></pre></td></tr></table></figure><p><strong>2、启用 73 版本</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --<span class="built_in">enable</span> remi-php73</span><br></pre></td></tr></table></figure><p><strong>3、安装php包</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上一步源中，可供安装的php版本有很多，本文安装的php73</span></span><br><span class="line">yum install -y \</span><br><span class="line">  php \</span><br><span class="line">  php-cli \</span><br><span class="line">  php-common \</span><br><span class="line">  php-fpm \</span><br><span class="line">  php-gd \</span><br><span class="line">  php-mbstring \</span><br><span class="line">  php-intl \</span><br><span class="line">  php-mcrypt \</span><br><span class="line">  php-mysql \</span><br><span class="line">  php-pdo \</span><br><span class="line">  php-xml</span><br></pre></td></tr></table></figure><p><strong>4、修改PHP配置</strong></p><p>编辑 php.ini , 将以下配置的值修改为1024M</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/php.ini</span><br><span class="line"></span><br><span class="line">post_max_size = 1024M</span><br><span class="line">memory_limit = 1024M</span><br><span class="line">upload_max_filesize = 1024M</span><br></pre></td></tr></table></figure><p><strong>5、启动php-fpm</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start php-fpm.service</span><br></pre></td></tr></table></figure><p><strong>6、设置fpm开机启动</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> php-fpm.service</span><br></pre></td></tr></table></figure><h2 id="五、上线-EduSoho"><a href="#五、上线-EduSoho" class="headerlink" title="五、上线 EduSoho"></a>五、上线 EduSoho</h2><p><strong>1、创建EduSoho数据库</strong></p><blockquote><p>这里创不创建无所谓，在浏览器访问的时候会自动创建。</p></blockquote><ul><li><p>登录mysql</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line"><span class="comment">#按照提示，如果设置了密码，请输入正确的密码，`Enter`键登录mysql；如果未设置密码，请直接`Enter`键登录mysql.</span></span><br></pre></td></tr></table></figure></li><li><p>创建数据库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE edusoho DEFAULT CHARACTER SET utf8;</span><br><span class="line">GRANT ALL PRIVILEGES ON `edusoho`.* TO <span class="string">&#x27;esuser&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;Zhurs@123&#x27;</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></li></ul><p><strong>2、下载解压EduSoho</strong></p><blockquote><p>资源包下载：<a href="http://www.edusoho.com/open/show">http://www.edusoho.com/open/show</a></p><p>安装文档：<a href="http://www.qiqiuyu.com/my/course/20">http://www.qiqiuyu.com/my/course/20</a></p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230524093931660.png" alt="image-20230524093931660"></p><p><strong>3、增加 EduSoho nginx 配置</strong></p><blockquote><p>注意1：教培版和企培版的项目包目录有些许不一样，稍微更改即可。</p><p>注意2：edusoho访问目录是edusoho&#x2F;web,只有在nginx或者Apache配置里面把根目录定位到web目录下，才不会出现奇怪的问题，否则就会出现图片不能显示或者文件无法上传的问题。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/edusoho.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意端口不要冲突</span></span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.example.com;</span><br><span class="line">    <span class="attribute">root</span> /var/www/edusoho/web;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/edusoho.access.log;</span><br><span class="line">    <span class="attribute">error_log</span> /var/log/nginx/edusoho.<span class="literal">error</span>.log;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span> app.php;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">@rewriteapp</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> <span class="variable">@rewriteapp</span> &#123;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> /app.php/<span class="variable">$1</span> <span class="literal">last</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> <span class="regexp">~ ^/udisk</span> &#123;</span><br><span class="line">        internal;</span><br><span class="line">        <span class="attribute">root</span> /var/www/edusoho/app/data/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> <span class="regexp">~ ^/(app|app_dev)\.php(/|$)</span> &#123;</span><br><span class="line">        <span class="attribute">fastcgi_pass</span>   <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">        <span class="attribute">fastcgi_split_path_info</span><span class="regexp"> ^(.+\.php)(/.*)$</span>;</span><br><span class="line">        <span class="attribute">include</span> fastcgi_params;</span><br><span class="line">        <span class="attribute">fastcgi_param</span>  SCRIPT_FILENAME    <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">        <span class="attribute">fastcgi_param</span>  HTTPS              <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">fastcgi_param</span> HTTP_X-Sendfile-Type X-Accel-Redirect;</span><br><span class="line">        <span class="attribute">fastcgi_param</span> HTTP_X-Accel-Mapping /udisk=/var/www/edusoho/app/data/udisk;</span><br><span class="line">        <span class="attribute">fastcgi_buffer_size</span> <span class="number">128k</span>;</span><br><span class="line">        <span class="attribute">fastcgi_buffers</span> <span class="number">8</span> <span class="number">128k</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> <span class="regexp">~* \.(jpg|jpeg|gif|png|ico|swf)$</span> &#123;</span><br><span class="line">        <span class="attribute">expires</span> <span class="number">3y</span>;</span><br><span class="line">        <span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">gzip</span> <span class="literal">off</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> <span class="regexp">~* \.(css|js)$</span> &#123;</span><br><span class="line">        <span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">expires</span> <span class="number">3y</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> <span class="regexp">~ ^/files/.*\.(php|php5)$</span> &#123;</span><br><span class="line">        <span class="attribute">deny</span> all;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">        <span class="attribute">fastcgi_pass</span>   <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">        <span class="attribute">fastcgi_split_path_info</span><span class="regexp"> ^(.+\.php)(/.*)$</span>;</span><br><span class="line">        <span class="attribute">fastcgi_param</span>  SCRIPT_FILENAME    <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">        <span class="attribute">fastcgi_param</span>  HTTPS              <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">include</span>        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、重启nginx服务</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx.service</span><br></pre></td></tr></table></figure><h2 id="六、验证"><a href="#六、验证" class="headerlink" title="六、验证"></a>六、验证</h2><p>本地浏览器访问：<a href="http://192.168.56.153/">http://192.168.56.153/</a></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>访问 <a href="http://192.168.56.153/">http://192.168.56.153/</a> 后，在预检查阶段显示 web 不可写：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230524004417917.png" alt="image-20230524004417917"></p><p>解决方案：对项目<code>edusoho</code>目录 777 权限即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 -R edusoho</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="built_in">chown</span> apache.apache -R edusoho</span><br></pre></td></tr></table></figure><p>完成后，再次点击上图的<code>重新检测按钮</code>即可！</p>]]></content>
    
    
    <summary type="html">EduSoho 网校系统部署，适合 Linux 入门学员练手项目！</summary>
    
    
    
    <category term="Linux 服务器运维实战" scheme="https://blog.rabcnops.cn/categories/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E7%BB%B4%E5%AE%9E%E6%88%98/"/>
    
    <category term="项目实战部署篇" scheme="https://blog.rabcnops.cn/categories/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E7%BB%B4%E5%AE%9E%E6%88%98/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E9%83%A8%E7%BD%B2%E7%AF%87/"/>
    
    
    <category term="Linux" scheme="https://blog.rabcnops.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Git 推送(提交)时如何忽略某个文件或目录？</title>
    <link href="https://blog.rabcnops.cn/posts/articles/e8e17be2.html"/>
    <id>https://blog.rabcnops.cn/posts/articles/e8e17be2.html</id>
    <published>2023-05-15T06:20:00.000Z</published>
    <updated>2023-05-15T06:45:49.057Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/improved-git-flow-2.png" alt="improved-git-flow-2"></p><p><strong>1、在工作目录下新建 <code>.gitignore</code> 文件</strong></p><blockquote><p>阿里云效 DevOps 实测！</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> .gitignore</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230511182631942.png" alt="image-20230511182631942"></p><p><strong>2、配置忽略规则（支持正则）</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略项目根目录下所有以 .a 结尾的文件</span></span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># lib.a 除外（也就是说，除了lib.a文件外，项目根目录下其他文件或目录均被忽略）</span></span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO（就是说如果其他目录下有同名的目录，那与下面指定的是没关系的）</span></span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略 build/ 目录下的所有文件（如果远程仓库也没有build目录，该目录也不会被推送，因为此时相当于空目录，空目录无法推送）</span></span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略项目根目录下的 doc 目录下的所有以 .txt 结尾的文件，但不包括 doc/server/*.txt</span></span><br><span class="line">doc/*.txt</span><br></pre></td></tr></table></figure><p><code>.gitignore</code> 只能忽略那些原来没有被 <code>track</code> 的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。解决方法就是先把本地缓存删除（改变成未 <code>track</code> 状态），然后再提交。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> -r --cached .</span><br></pre></td></tr></table></figure><p>代码提交（根据自己分支提交即可）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;update .gitignore&#x27;</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.jianshu.com/p/854672c36692">https://www.jianshu.com/p/854672c36692</a></p><p>-–END</p>]]></content>
    
    
    <summary type="html">Git 推送(提交)时如何忽略某个文件或目录？</summary>
    
    
    
    <category term="Git" scheme="https://blog.rabcnops.cn/categories/Git/"/>
    
    
    <category term="Git" scheme="https://blog.rabcnops.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 主从复制涉及到了几个线程？</title>
    <link href="https://blog.rabcnops.cn/posts/articles/f4b248ff.html"/>
    <id>https://blog.rabcnops.cn/posts/articles/f4b248ff.html</id>
    <published>2023-05-09T01:38:00.000Z</published>
    <updated>2023-05-09T01:39:22.795Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/ms-mysql.png" alt="ms-mysql"></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说到主从，我相信大家在 MySQL 这一节面试经常被问到<code>MySQL 的主从复制原理</code>，而且大家背得滚瓜烂熟。但是在主从复制的过程中，是如何进程数据同步的，又涉及到了哪些线程呢？这些线程又是充当的什么角色呢？</p><p>首先，MySQL 有如下几种复制模式：</p><ul><li>主从复制模式：A - - &gt; B</li><li>主主复制模式：A &lt; - - &gt; B</li><li>链式复制模式：A - - &gt; B - - &gt; C</li><li>环形复制模式：A - - &gt; B - - &gt; C - - &gt; A</li></ul><p>生产环境中一般建议部署为<code>主从模式</code>，这也是比较稳健的一种 MySQL 复制方式，如果想实现一定程度上的高可用，可选择使用主主模式，但是主主模式必须确保任何一个时刻都只有一个数据库是 Active 状态（即读写状态），另一个数据库作为备用，否则就要解决<code>自增键/主键</code>的冲突问题。</p><h2 id="一、主从同步原理"><a href="#一、主从同步原理" class="headerlink" title="一、主从同步原理"></a>一、主从同步原理</h2><p>简单的主从复制基本原理如下：</p><ul><li>主库将更新写入二进制文件，并维护文件的一个索引来跟踪日志循环；</li><li>从库复制主库的二进制日志事件到本地的中继日志（relay log）；</li><li>从库重放中继日志实现与主库的数据同步。</li></ul><p>这里不进行深入的源码分析，有兴趣的自行查阅<a href="https://dev.mysql.com/doc/">官方文档</a>。</p><h2 id="二、主从同步分析"><a href="#二、主从同步分析" class="headerlink" title="二、主从同步分析"></a>二、主从同步分析</h2><p>MySQL 使用 3 个线程来实现同步（复制）功能，一个线程在主库上，另两个线程在从库上。</p><p>当从库执行 <code>start slave</code>指令时，从库将创建一个 I&#x2F;O 线程，该线程用于连接主库并让主库发送记录在其二进制日志（主库二进制日志）中的语句。此时，主库会创建一个线程将其二进制日志的内容发送到从库，如下图，就是其创建的线程，有两个线程，是因为我的 MySQL 复制是双主双从架构（关于如何部署双主，可看看我前面的博文<a href="https://blog.rabcnops.cn/posts/articles/96e13b9f.html">《基于 Docker 的 MySQL GTID 主从复制与测试》</a>），下图是在某个一个主库上查询的，因此它有两个从库，所有就会生成两个 Binlog Dump 线程，该线程会发送更新的二进制内容到从库，并等待新的二进制日志更新，有更新就会推送。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show processlist\G</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230505182639729.png" alt="image-20230505182639729"></p><p>然后从库的 I&#x2F;O 线程读取主库 Binlog Dump 线程发送的内容并将读取的数据存储到从库的中继日志文件中，最后从库的 SQL 线程会将中继日志中的事件重演并最终落盘。I&#x2F;O 线程与 SQL 线程位于从库上，如下图：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230508095040342.png" alt="image-20230508095040342"></p><p>而且要确保这两个线程均处于 <code>Yes</code> 状态，才能实现主从复制。</p><p><mark>以上就是 MySQL 主从复制过程涉及到的三个线程！</mark></p>]]></content>
    
    
    <summary type="html">MySQL 主从复制涉及到了几个线程？</summary>
    
    
    
    <category term="数据库" scheme="https://blog.rabcnops.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="关系型数据库" scheme="https://blog.rabcnops.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="https://blog.rabcnops.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://blog.rabcnops.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>基于 Docker 的 MySQL GTID 主从复制与测试</title>
    <link href="https://blog.rabcnops.cn/posts/articles/96e13b9f.html"/>
    <id>https://blog.rabcnops.cn/posts/articles/96e13b9f.html</id>
    <published>2023-05-03T15:20:00.000Z</published>
    <updated>2023-05-03T15:44:30.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于-Docker-的-MySQL-GTID-主从复制与测试"><a href="#基于-Docker-的-MySQL-GTID-主从复制与测试" class="headerlink" title="基于 Docker 的 MySQL GTID 主从复制与测试"></a><center>基于 Docker 的 MySQL GTID 主从复制与测试</center></h1><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/ms-mysql.png" alt="ms-mysql"></p><hr><h2 id="一、规划"><a href="#一、规划" class="headerlink" title="一、规划"></a>一、规划</h2><h3 id="1-1-基础环境"><a href="#1-1-基础环境" class="headerlink" title="1.1 基础环境"></a>1.1 基础环境</h3><p>1、服务器环境</p><ul><li><p>Linux：CentOS 7.9</p></li><li><p>Docker：23.0.4</p></li><li><p>Docker-compose：2.7.0</p></li><li><p>Sysbench：1.0.20</p></li></ul><p>2、服务&#x2F;应用</p><ul><li>MySQL：8.0.33</li></ul><h3 id="1-2-应用架构"><a href="#1-2-应用架构" class="headerlink" title="1.2 应用架构"></a>1.2 应用架构</h3><blockquote><p>复制：双主双从，实现主从复制、主主复制；</p><p>读写：master 实例具备<code>读写权限</code>，slave 实例具备<code>只读权限</code>。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/M-S.png" alt="M-S"></p><h3 id="1-3-路径规划"><a href="#1-3-路径规划" class="headerlink" title="1.3 路径规划"></a>1.3 路径规划</h3><blockquote><p>数据持久化管理。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">├── master1</span><br><span class="line">│   ├── conf</span><br><span class="line">│   ├── data</span><br><span class="line">│   └── logs</span><br><span class="line">├── master2</span><br><span class="line">│   ├── conf</span><br><span class="line">│   ├── data</span><br><span class="line">│   └── logs</span><br><span class="line">├── slave1</span><br><span class="line">│   ├── conf</span><br><span class="line">│   ├── data</span><br><span class="line">│   └── logs</span><br><span class="line">└── slave2</span><br><span class="line">    ├── conf</span><br><span class="line">    ├── data</span><br><span class="line">    └── logs</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230429181901803.png" alt="image-20230429181901803"></p><h2 id="二、部署"><a href="#二、部署" class="headerlink" title="二、部署"></a>二、部署</h2><h3 id="2-1-服务部署"><a href="#2-1-服务部署" class="headerlink" title="2.1 服务部署"></a>2.1 服务部署</h3><p>1、安装 docker 服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://csdn-rab.oss-cn-chengdu.aliyuncs.com/shellscript/docker_install.sh | bash</span><br></pre></td></tr></table></figure><p>2、安装 docker-compse 编排工具</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://rab-package.oss-cn-hangzhou.aliyuncs.com/binary/el7/docker-compose/2.7.0/docker-compose-linux-x86_64</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x docker-compose-linux-x86_64 &amp;&amp; <span class="built_in">mv</span> docker-compose-linux-x86_64 /usr/bin/docker-compose</span><br></pre></td></tr></table></figure><p>3、安装 MySQL 服务</p><blockquote><p>使用 Docker-compose 进行编排。</p></blockquote><ul><li><p>创建持久化目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /root/mysql_install/&#123;master1/&#123;data,logs,conf&#125;,master2/&#123;data,logs,conf&#125;,slave1/&#123;data,logs,conf&#125;,slave2/&#123;data,logs,conf&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改权限</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> -R 777 /root/mysql_install/&#123;master1/&#123;data,logs&#125;,master2/&#123;data,logs&#125;,slave1/&#123;data,logs&#125;,slave2/&#123;data,logs&#125;&#125;</span><br></pre></td></tr></table></figure><p>临时测试-删除</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf /root/mysql_install/&#123;master1/&#123;data/*,logs/*&#125;,master2/&#123;data/*,logs/*&#125;,slave1/&#123;data/*,logs/*&#125;,slave2/&#123;data/*,logs/*&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>分别上传配置文件（my.cnf）至 conf 目录下</p><blockquote><p>Master1 配置文件（server-id 为1，其他不变）</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">port = 3306</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># innodb_force_recovery = 6  # 数据恢复参数，在数据表结构异常时使用（缺省值为0）</span></span><br><span class="line">port = 3306</span><br><span class="line">datadir         = /var/lib/mysql</span><br><span class="line">log-error       = /var/log/mysql/error.log</span><br><span class="line">innodb-data-file-path = /var/lib/mysql/ibdata1:1G;/var/lib/mysql/ibdata2:1G;/var/lib/mysql/ibdata3:1G</span><br><span class="line"></span><br><span class="line"><span class="comment"># Disabling symbolic-links is recommended to prevent assorted security risks</span></span><br><span class="line">symbolic-links = 0</span><br><span class="line">max_connections = 2000</span><br><span class="line">max_user_connections = 1900</span><br><span class="line">max_connect_errors = 100000</span><br><span class="line">max_allowed_packet = 50M</span><br><span class="line">lower_case_table_names = 1</span><br><span class="line">default-time_zone = <span class="string">&#x27;+8:00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1055异常处理</span></span><br><span class="line">sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</span><br><span class="line"></span><br><span class="line"><span class="comment"># GTID及二进制日志</span></span><br><span class="line">server-id = 1</span><br><span class="line">gtid_mode = on</span><br><span class="line">enforce_gtid_consistency = on</span><br><span class="line">master-info-repository = TABLE</span><br><span class="line">relay-log-info-repository = TABLE</span><br><span class="line"><span class="comment"># 设置binlog日志</span></span><br><span class="line">log-bin = /var/log/mysql/mysql-binlog</span><br><span class="line"><span class="comment"># 为每个session分配的内存，在事务过程中用来存储二进制日志的缓存</span></span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line"><span class="comment"># 主从复制的格式（mixed,statement,row，默认格式是statement）官方推荐在使用GTID情况下，基于行复制</span></span><br><span class="line">binlog_format=row</span><br><span class="line"><span class="comment"># 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。</span></span><br><span class="line">expire_logs_days=7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不需要同步的数据库</span></span><br><span class="line">binlog-ignore-db = mysql</span><br><span class="line">binlog_ignore_db = information_schema</span><br><span class="line">binlog_ignore_db = performation_schema</span><br><span class="line">binlog_ignore_db = sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql_native_password</span></span><br><span class="line">default_authentication_plugin = <span class="string">&#x27;mysql_native_password&#x27;</span></span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">skip-name-resolve</span><br></pre></td></tr></table></figure><blockquote><p>Master2 配置文件（server-id 为2，其他不变）</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">port = 3306</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># innodb_force_recovery = 6  # 数据恢复参数，在数据表结构异常时使用（缺省值为0）</span></span><br><span class="line">port = 3306</span><br><span class="line">datadir         = /var/lib/mysql</span><br><span class="line">log-error       = /var/log/mysql/error.log</span><br><span class="line">innodb-data-file-path = /var/lib/mysql/ibdata1:1G;/var/lib/mysql/ibdata2:1G;/var/lib/mysql/ibdata3:1G</span><br><span class="line"></span><br><span class="line"><span class="comment"># Disabling symbolic-links is recommended to prevent assorted security risks</span></span><br><span class="line">symbolic-links = 0</span><br><span class="line">max_connections = 2000</span><br><span class="line">max_user_connections = 1900</span><br><span class="line">max_connect_errors = 100000</span><br><span class="line">max_allowed_packet = 50M</span><br><span class="line">lower_case_table_names = 1</span><br><span class="line">default-time_zone = <span class="string">&#x27;+8:00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1055异常处理</span></span><br><span class="line">sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</span><br><span class="line"></span><br><span class="line"><span class="comment"># GTID及二进制日志</span></span><br><span class="line">server-id = 2</span><br><span class="line">gtid_mode = on</span><br><span class="line">enforce_gtid_consistency = on</span><br><span class="line">master-info-repository = TABLE</span><br><span class="line">relay-log-info-repository = TABLE</span><br><span class="line"><span class="comment"># 设置binlog日志</span></span><br><span class="line">log-bin = /var/log/mysql/mysql-binlog</span><br><span class="line"><span class="comment"># 为每个session分配的内存，在事务过程中用来存储二进制日志的缓存</span></span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line"><span class="comment"># 主从复制的格式（mixed,statement,row，默认格式是statement）官方推荐在使用GTID情况下，基于行复制</span></span><br><span class="line">binlog_format=row</span><br><span class="line"><span class="comment"># 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。</span></span><br><span class="line">expire_logs_days=7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不需要同步的数据库</span></span><br><span class="line">binlog-ignore-db = mysql</span><br><span class="line">binlog_ignore_db = information_schema</span><br><span class="line">binlog_ignore_db = performation_schema</span><br><span class="line">binlog_ignore_db = sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql_native_password</span></span><br><span class="line">default_authentication_plugin = <span class="string">&#x27;mysql_native_password&#x27;</span></span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">skip-name-resolve</span><br></pre></td></tr></table></figure><blockquote><p>Slave1 配置文件（server-id 为3，其他不变）</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">port = 3306</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># innodb_force_recovery = 6  # 数据恢复参数，在数据表结构异常时使用（缺省值为0）</span></span><br><span class="line">port = 3306</span><br><span class="line">datadir         = /var/lib/mysql</span><br><span class="line">log-error       = /var/log/mysql/error.log</span><br><span class="line">innodb-data-file-path = /var/lib/mysql/ibdata1:1G;/var/lib/mysql/ibdata2:1G;/var/lib/mysql/ibdata3:1G</span><br><span class="line"></span><br><span class="line"><span class="comment"># Disabling symbolic-links is recommended to prevent assorted security risks</span></span><br><span class="line">symbolic-links = 0</span><br><span class="line">max_connections = 2000</span><br><span class="line">max_user_connections = 1900</span><br><span class="line">max_connect_errors = 100000</span><br><span class="line">max_allowed_packet = 50M</span><br><span class="line">lower_case_table_names = 1</span><br><span class="line">default-time_zone = <span class="string">&#x27;+8:00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1055异常处理</span></span><br><span class="line">sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</span><br><span class="line"></span><br><span class="line"><span class="comment"># GTID及二进制日志</span></span><br><span class="line">server-id = 3</span><br><span class="line">gtid_mode = on</span><br><span class="line">enforce_gtid_consistency = on</span><br><span class="line">master-info-repository = TABLE</span><br><span class="line">relay-log-info-repository = TABLE</span><br><span class="line"><span class="comment"># 设置binlog日志</span></span><br><span class="line">log-bin = /var/log/mysql/mysql-binlog</span><br><span class="line"><span class="comment"># 为每个session分配的内存，在事务过程中用来存储二进制日志的缓存</span></span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line"><span class="comment"># 主从复制的格式（mixed,statement,row，默认格式是statement）官方推荐在使用GTID情况下，基于行复制</span></span><br><span class="line">binlog_format=row</span><br><span class="line"><span class="comment"># 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。</span></span><br><span class="line">expire_logs_days=7</span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql_native_password</span></span><br><span class="line">default_authentication_plugin = <span class="string">&#x27;mysql_native_password&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># slave实例设置为只读</span></span><br><span class="line">read_only = on</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">skip-name-resolve</span><br></pre></td></tr></table></figure><blockquote><p>Slave2 配置文件（server-id 为4，其他不变）</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">port = 3306</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># innodb_force_recovery = 6  # 数据恢复参数，在数据表结构异常时使用（缺省值为0）</span></span><br><span class="line">port = 3306</span><br><span class="line">datadir         = /var/lib/mysql</span><br><span class="line">log-error       = /var/log/mysql/error.log</span><br><span class="line">innodb-data-file-path = /var/lib/mysql/ibdata1:1G;/var/lib/mysql/ibdata2:1G;/var/lib/mysql/ibdata3:1G</span><br><span class="line"></span><br><span class="line"><span class="comment"># Disabling symbolic-links is recommended to prevent assorted security risks</span></span><br><span class="line">symbolic-links = 0</span><br><span class="line">max_connections = 2000</span><br><span class="line">max_user_connections = 1900</span><br><span class="line">max_connect_errors = 100000</span><br><span class="line">max_allowed_packet = 50M</span><br><span class="line">lower_case_table_names = 1</span><br><span class="line">default-time_zone = <span class="string">&#x27;+8:00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1055异常处理</span></span><br><span class="line">sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</span><br><span class="line"></span><br><span class="line"><span class="comment"># GTID及二进制日志</span></span><br><span class="line">server-id = 3</span><br><span class="line">gtid_mode = on</span><br><span class="line">enforce_gtid_consistency = on</span><br><span class="line">master-info-repository = TABLE</span><br><span class="line">relay-log-info-repository = TABLE</span><br><span class="line"><span class="comment"># 设置binlog日志</span></span><br><span class="line">log-bin = /var/log/mysql/mysql-binlog</span><br><span class="line"><span class="comment"># 为每个session分配的内存，在事务过程中用来存储二进制日志的缓存</span></span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line"><span class="comment"># 主从复制的格式（mixed,statement,row，默认格式是statement）官方推荐在使用GTID情况下，基于行复制</span></span><br><span class="line">binlog_format=row</span><br><span class="line"><span class="comment"># 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。</span></span><br><span class="line">expire_logs_days=7</span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql_native_password</span></span><br><span class="line">default_authentication_plugin = <span class="string">&#x27;mysql_native_password&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># slave实例设置为只读</span></span><br><span class="line">read_only = on</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">skip-name-resolve</span><br></pre></td></tr></table></figure></li><li><p>编写 docker-compose 文件</p><blockquote><p>指定 IP 时，注意不要与原网段重复，否则将创建失败！</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  master1:</span><br><span class="line">    image: mysql:8.0.33</span><br><span class="line">    container_name: master1</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 33061:3306</span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_ROOT_PASSWORD=Zhurs@123!</span><br><span class="line">    volumes:</span><br><span class="line">      - /root/mysql_install/master1/conf:/etc/mysql/conf.d</span><br><span class="line">      - /root/mysql_install/master1/logs:/var/log/mysql</span><br><span class="line">      - /root/mysql_install/master1/data:/var/lib/mysql</span><br><span class="line">    networks:</span><br><span class="line">      mysql-network:</span><br><span class="line">        ipv4_address: 172.31.1.11</span><br><span class="line">  master2:</span><br><span class="line">    image: mysql:8.0.33</span><br><span class="line">    container_name: master2</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 33062:3306</span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_ROOT_PASSWORD=Zhurs@123!</span><br><span class="line">    volumes:</span><br><span class="line">      - /root/mysql_install/master2/conf:/etc/mysql/conf.d</span><br><span class="line">      - /root/mysql_install/master2/logs:/var/log/mysql</span><br><span class="line">      - /root/mysql_install/master2/data:/var/lib/mysql</span><br><span class="line">    networks:</span><br><span class="line">      mysql-network:</span><br><span class="line">        ipv4_address: 172.31.1.12</span><br><span class="line">  slave1:</span><br><span class="line">    image: mysql:8.0.33</span><br><span class="line">    container_name: slave1</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 33063:3306</span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_ROOT_PASSWORD=Zhurs@123!</span><br><span class="line">    volumes:</span><br><span class="line">      - /root/mysql_install/slave1/conf:/etc/mysql/conf.d</span><br><span class="line">      - /root/mysql_install/slave1/logs:/var/log/mysql</span><br><span class="line">      - /root/mysql_install/slave1/data:/var/lib/mysql</span><br><span class="line">    networks:</span><br><span class="line">      mysql-network:</span><br><span class="line">        ipv4_address: 172.31.1.13</span><br><span class="line">  slave2:</span><br><span class="line">    image: mysql:8.0.33</span><br><span class="line">    container_name: slave2</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 33064:3306</span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_ROOT_PASSWORD=Zhurs@123!</span><br><span class="line">    volumes:</span><br><span class="line">      - /root/mysql_install/slave2/conf:/etc/mysql/conf.d</span><br><span class="line">      - /root/mysql_install/slave2/logs:/var/log/mysql</span><br><span class="line">      - /root/mysql_install/slave2/data:/var/lib/mysql</span><br><span class="line">    networks:</span><br><span class="line">      mysql-network:</span><br><span class="line">        ipv4_address: 172.31.1.14</span><br><span class="line">      </span><br><span class="line">networks:</span><br><span class="line">  mysql-network:</span><br><span class="line">    driver: bridge</span><br><span class="line">    ipam:</span><br><span class="line">      driver: default</span><br><span class="line">      config:</span><br><span class="line">        - subnet: 172.31.1.0/24</span><br><span class="line">          gateway: 172.31.1.1</span><br></pre></td></tr></table></figure></li><li><p>运行 MySQL 服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><blockquote><p>查看容器是否正常运行。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230502225451248.png" alt="image-20230502225451248"></p></li></ul><h3 id="2-2-主从配置"><a href="#2-2-主从配置" class="headerlink" title="2.2 主从配置"></a>2.2 主从配置</h3><h4 id="2-2-1-主从同步配置"><a href="#2-2-1-主从同步配置" class="headerlink" title="2.2.1 主从同步配置"></a>2.2.1 主从同步配置</h4><p>1、配置 <code>master1 - - &gt; slave1</code> 主从</p><ul><li><p>master1 实例创建主从同步账号</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入master1容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it master1 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录MySQL</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line"><span class="comment"># 注意：MySql8有新的安全要求，不能像之前的版本那样一次性创建用户并授权需要先创建用户，再进行授权操作</span></span><br><span class="line">create user <span class="string">&#x27;repl_master1&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&#x27;zhurs@123.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权（主从同步权限即可）</span></span><br><span class="line"><span class="comment"># replication slave权限：拥有此权限可以查看从服务器，从主服务器读取二进制日志。</span></span><br><span class="line"><span class="comment"># super权限：允许用户使用修改全局变量的SET语句以及CHANGE（属于MASTER语句）</span></span><br><span class="line"><span class="comment"># reload权限：必须拥有reload权限，才可以执行flush  [tables | logs | privileges]</span></span><br><span class="line">grant replication  slave,reload,super on *.* to <span class="string">&#x27;repl_master1&#x27;</span>@<span class="string">&#x27;%&#x27;</span> with grant option;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新授权</span></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></li><li><p>slave1 实例进行同步</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入slave1容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it slave1 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录MySQL</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接master1主库</span></span><br><span class="line">CHANGE MASTER TO master_host=<span class="string">&#x27;172.31.1.11&#x27;</span>, master_port=3306, master_user=<span class="string">&#x27;repl_master1&#x27;</span>, master_password=<span class="string">&#x27;zhurs@123.com&#x27;</span>, master_auto_position=1;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动slave连接</span></span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure></li><li><p>查看同步状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status\G</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503000000879.png" alt="image-20230503000000879"></p></li></ul><p>2、配置 <code>master2 - - &gt; slave2</code> 主从</p><ul><li><p>master2 实例创建主从同步账号</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入master2容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it master2 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录MySQL</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line"><span class="comment"># 注意：MySql8有新的安全要求，不能像之前的版本那样一次性创建用户并授权需要先创建用户，再进行授权操作</span></span><br><span class="line">create user <span class="string">&#x27;repl_master2&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&#x27;zhurs@123.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权（主从同步权限即可）</span></span><br><span class="line"><span class="comment"># replication slave权限：拥有此权限可以查看从服务器，从主服务器读取二进制日志。</span></span><br><span class="line"><span class="comment"># super权限：允许用户使用修改全局变量的SET语句以及CHANGE（属于MASTER语句）</span></span><br><span class="line"><span class="comment"># reload权限：必须拥有reload权限，才可以执行flush  [tables | logs | privileges]</span></span><br><span class="line">grant replication  slave,reload,super on *.* to <span class="string">&#x27;repl_master2&#x27;</span>@<span class="string">&#x27;%&#x27;</span> with grant option;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新授权</span></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></li><li><p>slave2 实例进行同步</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入slave2容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it slave2 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录MySQL</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接master2主库</span></span><br><span class="line">CHANGE MASTER TO master_host=<span class="string">&#x27;172.31.1.12&#x27;</span>, master_port=3306, master_user=<span class="string">&#x27;repl_master2&#x27;</span>, master_password=<span class="string">&#x27;zhurs@123.com&#x27;</span>, master_auto_position=1;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动slave连接</span></span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure></li><li><p>查看同步状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status\G</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503001352692.png" alt="image-20230503001352692"></p></li></ul><p><mark>至此，MySQL 的主从复制完成！接下来配置主主复制过程！</mark></p><h4 id="2-2-2-主主同步配置"><a href="#2-2-2-主主同步配置" class="headerlink" title="2.2.2 主主同步配置"></a>2.2.2 主主同步配置</h4><p>1、配置 <code>master1 - - &gt; master2</code> 主从</p><blockquote><p>master1 为主，master2 为从</p></blockquote><ul><li><p>master1 实例创建主从同步账号</p><blockquote><p>已经创建。</p></blockquote></li><li><p>master2 实例进行同步</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入slave1容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it master2 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录MySQL</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接master1主库</span></span><br><span class="line">CHANGE MASTER TO master_host=<span class="string">&#x27;172.31.1.11&#x27;</span>, master_port=3306, master_user=<span class="string">&#x27;repl_master1&#x27;</span>, master_password=<span class="string">&#x27;zhurs@123.com&#x27;</span>, master_auto_position=1;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动slave连接</span></span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure></li><li><p>查看同步状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status\G</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503001450209.png" alt="image-20230503001450209"></p></li></ul><p>2、配置 <code>master2 - - &gt; master1</code> 主从</p><blockquote><p>master2 为主，master1 为从</p></blockquote><ul><li><p>master2 实例创建主从同步账号</p><blockquote><p>已经创建。</p></blockquote></li><li><p>master1 实例进行同步</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入slave1容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it master1 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录MySQL</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接master1主库</span></span><br><span class="line">CHANGE MASTER TO master_host=<span class="string">&#x27;172.31.1.12&#x27;</span>, master_port=3306, master_user=<span class="string">&#x27;repl_master2&#x27;</span>, master_password=<span class="string">&#x27;zhurs@123.com&#x27;</span>, master_auto_position=1;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动slave连接</span></span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure></li><li><p>查看同步状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status\G</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503001757491.png" alt="image-20230503001757491"></p></li></ul><p><mark>至此，主从复制、主主复制结束！</mark></p><blockquote><p><strong>注</strong>：在配置 SLAVE 同步时</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先停止数据同步相关的线程： slave I/O 线程和 slave SQL 线程</span></span><br><span class="line">STOP SLAVE;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了避免可能发生的错误，直接重置客户端</span></span><br><span class="line">RESET  SLAVE;</span><br></pre></td></tr></table></figure><h3 id="2-3-主从验证"><a href="#2-3-主从验证" class="headerlink" title="2.3 主从验证"></a>2.3 主从验证</h3><h4 id="2-3-1-主从同步验证"><a href="#2-3-1-主从同步验证" class="headerlink" title="2.3.1 主从同步验证"></a>2.3.1 主从同步验证</h4><p>1、master1 创建测试数据库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database <span class="keyword">if</span> not exists master1 default charset utf8 collate utf8_general_ci;</span><br></pre></td></tr></table></figure><p>2、slave1 验证是否同步</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如下图，已经同步</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503002355116.png" alt="image-20230503002355116"></p><h4 id="2-3-2-主主同步验证"><a href="#2-3-2-主主同步验证" class="headerlink" title="2.3.2 主主同步验证"></a>2.3.2 主主同步验证</h4><p>此时，master2、slave2 也都有名为 <code>master1</code> 的测试数据库，因为 master2 与 master1 互为主从，而 slave2 又是 master2 的从库。</p><p>因此得出结论，这种数据库架构下，只要你在任意一 master 节点上创建数据库，每个 MySQL 实例都会实现数据同步。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503002458446.png" alt="image-20230503002458446"></p><h3 id="2-4-客户端连接"><a href="#2-4-客户端连接" class="headerlink" title="2.4 客户端连接"></a>2.4 客户端连接</h3><h4 id="2-4-1-控制台"><a href="#2-4-1-控制台" class="headerlink" title="2.4.1 控制台"></a>2.4.1 控制台</h4><blockquote><p>需安装MySQL客户端命令（mysql）。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -pZhurs@123! -h 192.168.56.120 -P 33061</span><br></pre></td></tr></table></figure><h4 id="2-4-2-图形化"><a href="#2-4-2-图形化" class="headerlink" title="2.4.2 图形化"></a>2.4.2 图形化</h4><blockquote><p>如 client 通过 navicat 客户端软件连接 master 节点（只需要连接其中之一即可），或以 VIP 的方式连接（配置 keepalived 实现 master 节点高可用），由于在单台 Host 虚拟机下运行的多 MySQL 实例，就无法做高可用演示，生产中至少两台 master 的 Host 节点来实现高可用。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503003905267.png" alt="image-20230503003905267"></p><p><strong>查看数据库：</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503003945019.png" alt="image-20230503003945019"></p><p><mark>至此，主从复制 + 主主复制 + 客户端连接已经配置完毕！</mark></p><h2 id="三、压测"><a href="#三、压测" class="headerlink" title="三、压测"></a>三、压测</h2><blockquote><p>测试：主从读写性能。</p><p>工具：<code>sysbench</code></p></blockquote><h3 id="3-1-安装-sysbench"><a href="#3-1-安装-sysbench" class="headerlink" title="3.1 安装 sysbench"></a>3.1 安装 sysbench</h3><p>1、执行脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://packagecloud.io/install/repositories/akopytov/sysbench/script.rpm.sh | sudo bash</span><br></pre></td></tr></table></figure><p>2、开始安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y install sysbench</span><br></pre></td></tr></table></figure><p>3、验证</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysbench --version</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503213303900.png" alt="image-20230503213303900"></p><h3 id="3-2-sysbench-压测"><a href="#3-2-sysbench-压测" class="headerlink" title="3.2 sysbench 压测"></a>3.2 sysbench 压测</h3><blockquote><p>由于我的系统主机资源有限，因此就简单的 10 张表、每张表 1千条数据进行 5 分钟压测</p><p>参考：<a href="https://help.aliyun.com/document_detail/146103.html">https://help.aliyun.com/document_detail/146103.html</a></p></blockquote><h4 id="3-2-1-读性能"><a href="#3-2-1-读性能" class="headerlink" title="3.2.1  读性能"></a>3.2.1  读性能</h4><p>1、准备数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sysbench \</span><br><span class="line">  --db-driver=mysql \</span><br><span class="line">  --mysql-host=192.168.56.120 \</span><br><span class="line">  --mysql-port=33061 \</span><br><span class="line">  --mysql-user=root \</span><br><span class="line">  --mysql-password=Zhurs@123! \</span><br><span class="line">  --mysql-db=master1 \</span><br><span class="line">  --table_size=1000 \</span><br><span class="line">  --tables=10 \</span><br><span class="line">  --events=0 \</span><br><span class="line">  --time=300  oltp_read_only prepare</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 说明：</span></span><br><span class="line"><span class="comment"># --table_size：表记录数</span></span><br><span class="line"><span class="comment"># --tables：表数量</span></span><br></pre></td></tr></table></figure><blockquote><p>执行完毕后，来查看数据库。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503223241087.png" alt="image-20230503223241087"></p><p>2、运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sysbench \</span><br><span class="line">  --db-driver=mysql \</span><br><span class="line">  --mysql-host=192.168.56.120 \</span><br><span class="line">  --mysql-port=33061 \</span><br><span class="line">  --mysql-user=root \</span><br><span class="line">  --mysql-password=Zhurs@123! \</span><br><span class="line">  --mysql-db=master1 \</span><br><span class="line">  --table_size=1000 \</span><br><span class="line">  --tables=10 \</span><br><span class="line">  --events=0 \</span><br><span class="line">  --time=300 \</span><br><span class="line">  --threads=5 \</span><br><span class="line">  --percentile=95 \</span><br><span class="line">  --range_selects=0 \</span><br><span class="line">  --skip-trx=1 \</span><br><span class="line">  --report-interval=1 oltp_read_only run</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 说明：</span></span><br><span class="line"><span class="comment"># --threads：并发线程数，可以理解为模拟的客户端并发连接数</span></span><br><span class="line"><span class="comment"># --skip-trx：省略begin/commit语句。默认是off</span></span><br></pre></td></tr></table></figure><p>**执行结果：**从中可看出每秒查询，每秒事务等执行结果。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503224520488.png" alt="image-20230503224520488"></p><p>除此之外，Host 系统的平均负载也在升高：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503225222279.png" alt="image-20230503225222279"></p><p>3、清理</p><blockquote><p>测试完成后清理数据，释放空间</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sysbench \</span><br><span class="line">  --db-driver=mysql \</span><br><span class="line">  --mysql-host=192.168.56.120 \</span><br><span class="line">  --mysql-port=33061 \</span><br><span class="line">  --mysql-user=root \</span><br><span class="line">  --mysql-password=Zhurs@123! \</span><br><span class="line">  --mysql-db=master1 \</span><br><span class="line">  --table_size=1000 \</span><br><span class="line">  --tables=10 \</span><br><span class="line">  --events=0 \</span><br><span class="line">  --time=300   \</span><br><span class="line">  --threads=5 \</span><br><span class="line">  --percentile=95 \</span><br><span class="line">  --range_selects=0 oltp_read_only cleanup</span><br></pre></td></tr></table></figure><h4 id="3-2-2-写性能"><a href="#3-2-2-写性能" class="headerlink" title="3.2.2 写性能"></a>3.2.2 写性能</h4><p>1、准备数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sysbench \</span><br><span class="line">  --db-driver=mysql \</span><br><span class="line">  --mysql-host=192.168.56.120 \</span><br><span class="line">  --mysql-port=33061 \</span><br><span class="line">  --mysql-user=root \</span><br><span class="line">  --mysql-password=Zhurs@123! \</span><br><span class="line">  --mysql-db=master1 \</span><br><span class="line">  --table_size=1000 \</span><br><span class="line">  --tables=10 \</span><br><span class="line">  --events=0 \</span><br><span class="line">  --time=300  oltp_write_only prepare</span><br></pre></td></tr></table></figure><p>2、运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sysbench \</span><br><span class="line">  --db-driver=mysql \</span><br><span class="line">  --mysql-host=192.168.56.120 \</span><br><span class="line">  --mysql-port=33061 \</span><br><span class="line">  --mysql-user=root \</span><br><span class="line">  --mysql-password=Zhurs@123! \</span><br><span class="line">  --mysql-db=master1 \</span><br><span class="line">  --table_size=1000 \</span><br><span class="line">  --tables=10 \</span><br><span class="line">  --events=0 \</span><br><span class="line">  --time=300 \</span><br><span class="line">  --threads=5 \</span><br><span class="line">  --percentile=95 \</span><br><span class="line">  --report-interval=1 oltp_write_only run</span><br></pre></td></tr></table></figure><p><strong>执行结果：</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503225733818.png" alt="image-20230503225733818"></p><p>3、清理</p><blockquote><p>测试完成后清理数据，释放空间</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sysbench \</span><br><span class="line">  --db-driver=mysql \</span><br><span class="line">  --mysql-host=192.168.56.120 \</span><br><span class="line">  --mysql-port=33061 \</span><br><span class="line">  --mysql-user=root \</span><br><span class="line">  --mysql-password=Zhurs@123! \</span><br><span class="line">  --mysql-db=master1 \</span><br><span class="line">  --table_size=1000 \</span><br><span class="line">  --tables=10 \</span><br><span class="line">  --events=0 \</span><br><span class="line">  --time=300 \</span><br><span class="line">  --threads=5 \</span><br><span class="line">  --percentile=95 oltp_write_only cleanup</span><br></pre></td></tr></table></figure><h4 id="3-2-3-读写性能"><a href="#3-2-3-读写性能" class="headerlink" title="3.2.3 读写性能"></a>3.2.3 读写性能</h4><p>1、准备数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sysbench \</span><br><span class="line">  --db-driver=mysql \</span><br><span class="line">  --mysql-host=192.168.56.120 \</span><br><span class="line">  --mysql-port=33061 \</span><br><span class="line">  --mysql-user=root \</span><br><span class="line">  --mysql-password=Zhurs@123! \</span><br><span class="line">  --mysql-db=master1 \</span><br><span class="line">  --table_size=1000 \</span><br><span class="line">  --tables=10 \</span><br><span class="line">  --events=0 \</span><br><span class="line">  --time=300 oltp_read_write prepare</span><br></pre></td></tr></table></figure><p>2、运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sysbench \</span><br><span class="line">  --db-driver=mysql  \</span><br><span class="line">  --mysql-host=192.168.56.120 \</span><br><span class="line">  --mysql-port=33061 \</span><br><span class="line">  --mysql-user=root \</span><br><span class="line">  --mysql-password=Zhurs@123! \</span><br><span class="line">  --mysql-db=master1 \</span><br><span class="line">  --table_size=1000 \</span><br><span class="line">  --tables=10 \</span><br><span class="line">  --events=0 \</span><br><span class="line">  --time=300 \</span><br><span class="line">  --threads=5 \</span><br><span class="line">  --percentile=95 \</span><br><span class="line">  --report-interval=1 oltp_read_write run</span><br></pre></td></tr></table></figure><p><strong>执行结果：</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503231502157.png" alt="image-20230503231502157"></p><p>3、清理</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sysbench \</span><br><span class="line">  --db-driver=mysql \</span><br><span class="line">  --mysql-host=192.168.56.120 \</span><br><span class="line">  --mysql-port=33061 \</span><br><span class="line">  --mysql-user=root \</span><br><span class="line">  --mysql-password=Zhurs@123! \</span><br><span class="line">  --mysql-db=master1 \</span><br><span class="line">  --table_size=1000 \</span><br><span class="line">  --tables=10 \</span><br><span class="line">  --events=0 \</span><br><span class="line">  --time=300 \</span><br><span class="line">  --threads=5 \</span><br><span class="line">  --percentile=95 oltp_read_write cleanup</span><br></pre></td></tr></table></figure><h4 id="3-2-4-主从复制延迟"><a href="#3-2-4-主从复制延迟" class="headerlink" title="3.2.4 主从复制延迟"></a>3.2.4 主从复制延迟</h4><p>以 10 张表，每张表 1000 条记录，读写压测 5 分钟的数据来看，主从复制的延迟在为 1s，不超过 2s（本次测试结果），如下图所示。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503225703898.png" alt="image-20230503225703898"></p><h2 id="四、扩展"><a href="#四、扩展" class="headerlink" title="四、扩展"></a>四、扩展</h2><h3 id="4-1-主从复制方式"><a href="#4-1-主从复制方式" class="headerlink" title="4.1 主从复制方式"></a>4.1 主从复制方式</h3><h4 id="4-1-1-异步复制（Asynchronous-replication）"><a href="#4-1-1-异步复制（Asynchronous-replication）" class="headerlink" title="4.1.1 异步复制（Asynchronous replication）"></a>4.1.1 异步复制（Asynchronous replication）</h4><p>MySQL 默认使用的是异步复制，官方解释如下：</p><p><code>the master writes events to its binary log and slaves request them when they are ready. There is no guarantee that any event will ever reach any slave.</code></p><p>即 master 服务器将事件写入其二进制日志，slave 服务器在事件准备好时请求事件。不能保证任何事件都会影响到任何一个 slave。</p><p><strong>说白了就是</strong>：主库只管把 events 写入 binlog 中，不管从库有没有收到。</p><h4 id="4-1-2-全同步复制（Fully-synchronous-replication）"><a href="#4-1-2-全同步复制（Fully-synchronous-replication）" class="headerlink" title="4.1.2 全同步复制（Fully synchronous replication）"></a>4.1.2 全同步复制（Fully synchronous replication）</h4><p>官方解释如下：</p><p><code>when a master commits a transaction, all slaves also will have committed the transaction before the master returns to the session that performed the transaction. The drawback of this is that there might be a lot of delay to complete a transaction.</code></p><p>即 master 服务器提交事务时，在 master 服务器返回到执行该事务的会话之前，所有 slave 服务器也将提交该事务。这样做的缺点是完成事务可能会有很多延迟。</p><p><strong>说白了就是</strong>：主库提交一个事物，需要等待所有从库先提交才能返回结果，执行这个事物。这样会造成一个事物延时。</p><h4 id="4-1-3-半同步复制（Semisynchronous-replication）"><a href="#4-1-3-半同步复制（Semisynchronous-replication）" class="headerlink" title="4.1.3 半同步复制（Semisynchronous replication）"></a>4.1.3 半同步复制（Semisynchronous replication）</h4><p>官方解释如下：</p><p><code>falls between asynchronous and fully synchronous replication. The master waits only until at least one slave has received and logged the events. It does not wait for all slaves to acknowledge receipt, and it requires only receipt, not that the events have been fully executed and committed on the slave side.</code></p><p>即介于异步复制和全同步复制之间。master 服务器只等待至少一个 slave 服务器接收并记录事件。它不等待所有从服务器确认接收，它只需要接收，而不需要在从服务器端完全执行和提交事件。</p><p><strong>说白了就是</strong>：介于异步复制和全复制之间，主库仅仅只要等待至少一个从库收到和记录 events。它不需要等待所有的从库告诉它收到events，也不需要从库执行和提交事物，从库只是收到 events 就会告诉主库，这样主库就可以提前提交事物了。</p><h3 id="4-2-GTID-与-Binary-Log"><a href="#4-2-GTID-与-Binary-Log" class="headerlink" title="4.2 GTID 与 Binary Log"></a>4.2 GTID 与 Binary Log</h3><p>1、GTID</p><p><code>MySQL GTID（Global Transaction ID）</code>是一种用于在复制环境中唯一标识事务的机制。GTID 能够在复制拓扑中帮助识别和跟踪每个事务的状态，从而更方便的进行数据同步和故障恢复。在 MySQL 5.6 版本及以上，可以使用 GTID 进行复制。</p><p>2、Binary Log</p><p><code>binlog（Binary Log）</code>是 MySQL 中的一种日志文件，用于记录对 MySQL 数据库进行的更改操作。它记录了所有的数据更改操作，包括对表的插入、更新和删除等操作。binlog 日志可以用于数据恢复、复制和备份等操作。</p><p>3、两者区别</p><ul><li>功能不同：GTID 用于唯一标识复制环境中的事务，而 binlog 用于记录数据库的更改操作。</li><li>数据结构不同：GTID 是由服务器生成的唯一标识符，用于标识每个事务。而 binlog 是一种二进制格式的日志文件，记录了每个事务的更改操作。</li><li>使用方式不同：GTID 用于在复制拓扑中标识和跟踪每个事务的状态，从而更方便地进行数据同步和故障恢复。而 binlog 可以用于数据恢复、复制和备份等操作。</li></ul><p><mark>需要注意的是</mark>：使用 GTID 进行复制需要 MySQL 5.6 及以上版本的支持。在 MySQL 5.5 及以下版本中，只能使用 binlog 进行数据复制和备份。本次使用的是基于 GTID 的主从复制。</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>MySQL 5.1.7 + 已经不支持 <code>“master-host”</code> 类似的参数。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503195146922.png" alt="image-20230503195146922"></p><p>因此 <code>docker-compose</code> 中就无法实现启动时主从同步（如下图 command 部分）：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230503195256475.png" alt="image-20230503195256475"></p><p>所以，通过 docker-compose 运行主从时，需进入从库进行配置！</p>]]></content>
    
    
    <summary type="html">基于 Docker 的 MySQL GTID 主从复制与测试。</summary>
    
    
    
    <category term="数据库" scheme="https://blog.rabcnops.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="关系型数据库" scheme="https://blog.rabcnops.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="https://blog.rabcnops.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://blog.rabcnops.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis 的 Protected Mode 解读</title>
    <link href="https://blog.rabcnops.cn/posts/articles/e42dd192.html"/>
    <id>https://blog.rabcnops.cn/posts/articles/e42dd192.html</id>
    <published>2023-04-25T09:38:00.000Z</published>
    <updated>2023-04-25T09:38:30.658Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/redis-social-1200x628-1.webp" alt="redis-social-1200x628-1"></p><hr><p><strong>官方配置文件自带的注释：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Protected mode is a layer of security protection, <span class="keyword">in</span> order to avoid that Redis instances left open on the internet are accessed and exploited.</span><br><span class="line"></span><br><span class="line">When protected mode is on and <span class="keyword">if</span>:</span><br><span class="line"></span><br><span class="line">1) The server is not binding explicitly to a <span class="built_in">set</span> of addresses using the <span class="string">&quot;bind&quot;</span> directive.</span><br><span class="line">2) No password is configured.</span><br><span class="line"></span><br><span class="line">The server only accepts connections from clients connecting from the IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain sockets.</span><br><span class="line"></span><br><span class="line">By default protected mode is enabled. You should <span class="built_in">disable</span> it only <span class="keyword">if</span> you are sure you want clients from other hosts to connect to Redis even <span class="keyword">if</span> no authentication is configured, nor a specific <span class="built_in">set</span> of interfaces are explicitly listed using the <span class="string">&quot;bind&quot;</span> directive.</span><br></pre></td></tr></table></figure><p><strong>Google 的翻译结果：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">保护模式是一层安全保护，以避免在互联网上开放的 Redis 实例被访问和利用。</span><br><span class="line"></span><br><span class="line">当保护模式打开时，如果：</span><br><span class="line"></span><br><span class="line">1) 服务器未使用“<span class="built_in">bind</span>”指令显式绑定到一组地址。</span><br><span class="line">2) 没有配置密码。</span><br><span class="line"></span><br><span class="line">服务器只接受来自环回地址127.0.0.1（IPv4）和 ::1（IPv6）以及来自 Unix 域套接字的客户端的连接。</span><br><span class="line"></span><br><span class="line">默认情况下启用保护模式。仅当您确定希望来自其他主机的客户端连接到 Redis，即使没有配置身份验证，也没有使用“<span class="built_in">bind</span>”指令明确列出一组特定接口时，才应禁用它。</span><br></pre></td></tr></table></figure><p><mark>也就是说，会存在这两种情况：</mark></p><p><strong>1、当 <code>protected-mode yes</code></strong></p><ul><li><p><code># bind 192.168.56.120</code>     - - &gt;   注释</p></li><li><p><code># requirepass zhurs@123</code> - - &gt;   注释</p><blockquote><p>此时，redis 的保护模式生效；</p><p>客户端只能通过本地连接，即环回地址127.0.0.1（IPv4）和 ::1（IPv6）以及来自 Unix 域套接字的客户端的连接。</p></blockquote></li><li><p><code># bind 192.168.56.120</code>     - - &gt;   注释</p></li><li><p><code>requirepass zhurs@123</code></p><blockquote><p>此时，redis 的保护模式不生效（yes 或 no 都无影响）；</p><p>客户端可指定 <code>IP（192.168.56.120）+ 端口 + 密码</code>来连接 redis。</p></blockquote></li><li><p><code>bind 192.168.56.120</code></p></li><li><p><code># requirepass zhurs@123</code> - - &gt;   注释</p><blockquote><p>此时，redis 的保护模式不生效（yes 或 no 都无影响）；</p><p>客户端可指定 <code>IP（192.168.56.120）+ 端口</code>来连接 redis（此时无密码）。</p></blockquote></li><li><p><code>bind 192.168.56.120</code></p></li><li><p><code>requirepass zhurs@123</code></p><blockquote><p>此时，redis 的保护模式不生效（yes 或 no 都无影响）；</p><p>客户端可指定 <code>IP（192.168.56.120）+ 端口 + 密码</code>来连接 redis。</p></blockquote></li></ul><p><strong>2、当 <code>protected-mode no</code></strong></p><ul><li>无论上面的哪种场景，客户端都可以根据 <code>bind</code> 及 <code>requirepass</code> 实际参数来连接到 redis；</li><li>然后通过指定 <code>IP（192.168.56.120）</code> 或 <code>IP（192.168.56.120） + 端口</code>或<code>IP（192.168.56.120）+ 端口 + 密码</code>来连接 redis。</li></ul><p>—END</p>]]></content>
    
    
    <summary type="html">Redis 的 Protected Mode 解读。</summary>
    
    
    
    <category term="数据库" scheme="https://blog.rabcnops.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="非关系型数据库" scheme="https://blog.rabcnops.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Redis" scheme="https://blog.rabcnops.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"/>
    
    
    <category term="Redis" scheme="https://blog.rabcnops.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 6.0+ 的 ACL 常用操作指令</title>
    <link href="https://blog.rabcnops.cn/posts/articles/b4beeb2a.html"/>
    <id>https://blog.rabcnops.cn/posts/articles/b4beeb2a.html</id>
    <published>2023-04-25T07:00:00.000Z</published>
    <updated>2023-04-25T07:39:25.295Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/Screenshot-2022-09-28-135602.png" alt="Redis Encryption"></p><hr><p>关于 redis 6.0+ 的 ACL 机制与基本配置在<a href="https://blog.rabcnops.cn/posts/articles/464f6e46.html">《Redis 6.0+ 的 ACL 机制》</a>一文中已经有提到，现在列举一些与 ACL 相关常用的指令。</p><p><strong>1、查看当前登录用户</strong></p><blockquote><p>如果你是这样登录的，默认就是 default 用户：</p><p>redis-cli -p 7001</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL WHOAMI</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425144116317.png" alt="image-20230425144116317"></p><p><strong>2、创建用户</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acl setuser rab</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425121649936.png" alt="image-20230425121649936"></p><blockquote><p>不设置密码与权限，则默认没有密码没有任何权限，且用户处于未激活状态（off），此时用户不可登录。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425121933381.png" alt="image-20230425121933381"></p><p><strong>3、启用（激活）用户</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acl setuser rab on</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425122108069.png" alt="image-20230425122108069"></p><p><strong>4、给用户增加密码</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acl setuser rab on &gt;Zhurs@2023!</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425143800401.png" alt="image-20230425143800401"></p><p><strong>5、查看命令分类</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acl <span class="built_in">cat</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425152710868.png" alt="image-20230425152710868"></p><p>查看某个分类具体可以执行哪些命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acl <span class="built_in">cat</span> slow</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425152907538.png" alt="image-20230425152907538"></p><p><strong>6、给用户设置权限</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acl setuser rab on &gt;Zhurs@2023! ~* +@all</span><br><span class="line"></span><br><span class="line"><span class="comment"># rab 用户对所有的 key 具备所有权限</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425144500649.png" alt="image-20230425144500649"></p><blockquote><p>查看用户权限</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acl list</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425144615971.png" alt="image-20230425144615971"></p><blockquote><p>设置对指定 key 拥有指定的权限</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acl setuser rab on &gt;Zhurs@2023! ~dum* -@all +<span class="built_in">set</span> +get</span><br><span class="line"></span><br><span class="line"><span class="comment"># rab 用户对 dum 开头的 key 具备 set、get 权限</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425150207114.png" alt="image-20230425150207114"></p><p><strong>7、列出所有用户</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acl list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 入下图，共三个用户</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425150020060.png" alt="image-20230425150020060"></p><p><strong>8、删除用户</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acl deluser rab</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425145717048.png" alt="image-20230425145717048"></p><blockquote><p>再次查看用户列表，发现用户已经被删除。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425145749678.png" alt="image-20230425145749678"></p><p><mark>以上的设置，如创建用户、给用户授权等操作都是在命令行（终端执行），那我们如何持久化这些设置呢？通过外部 aclfile 文件来存储这些信息，具体操作如下，aclfile 如何配置？在前面的文章中有具体演示。</mark></p><p>比如，先创建一个用户并授权：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acl setuser tom on &gt;Zhurs@2023! ~* +@all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可见，下图中有4个用户</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425150754669.png" alt="image-20230425150754669"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acl sava</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425151005484.png" alt="image-20230425151005484"></p><p>最后去 aclfile 文件去查看是否有用户信息记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> users.acl</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230425151203149.png" alt="image-20230425151203149"></p><p><strong>小结：</strong></p><ul><li>关于更多 ACL 命令，我们可以通过 ACL HELP 去查看；</li><li>acl 的持久化方式我们可以这样操作：<ul><li>登录集群，通过 acl save 指令来持久化；</li><li>直接在 aclfile 文件中添加用户相关信息（包括权限等）。</li></ul></li></ul><p>—END</p>]]></content>
    
    
    <summary type="html">Redis 6.0+ 的 ACL 常用操作指令。</summary>
    
    
    
    <category term="数据库" scheme="https://blog.rabcnops.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="非关系型数据库" scheme="https://blog.rabcnops.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Redis" scheme="https://blog.rabcnops.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"/>
    
    
    <category term="Redis" scheme="https://blog.rabcnops.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>如何理解 Linux 的 CPU 上下文切换？（连载）</title>
    <link href="https://blog.rabcnops.cn/posts/articles/fe7524c5.html"/>
    <id>https://blog.rabcnops.cn/posts/articles/fe7524c5.html</id>
    <published>2023-04-24T10:20:00.000Z</published>
    <updated>2023-04-27T08:02:06.365Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/linux-protection-rings.jpg" alt="linux-protection-rings"></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇说到了 CPU 的上下文切换，以及各种场景下的上下文切换，如<code>进程上下文切换</code>、<code>线程上下文切换</code>、<code>中断上下文切换</code>。我们知道，过多的上下文切换，会把 CPU 时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，缩短进程真正运行的时间，造成系统性能大幅下降。那我们怎么查看操作系统上的 CPU 上下文切换情况呢？在这里，我们可以使用 vmstat 这个工具，来查询系统的上下文切换情况。</p><h2 id="一、查看系统上下文切换"><a href="#一、查看系统上下文切换" class="headerlink" title="一、查看系统上下文切换"></a>一、查看系统上下文切换</h2><h3 id="1-1-vmstat-基本使用"><a href="#1-1-vmstat-基本使用" class="headerlink" title="1.1 vmstat 基本使用"></a>1.1 vmstat 基本使用</h3><p>vmstat 是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vmstat 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没隔 5s 输出一组数据。</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230423141944922.png" alt="image-20230423141944922"></p><p>上图中的结果重点关注这几项：</p><ul><li><strong>cs（context switch）</strong>：每秒上下文切换的次数；</li><li><strong>in（interrupt）</strong>：每秒中断次数；</li><li><strong>r（running or runnable）</strong>：就绪队列长度（即正在运行和等待 CPU 的进程数）；</li><li><strong>b（blocked）</strong>：处于不可中断睡眠状态的进程数。</li></ul><p>可看见上图中第一条内容：上下文切换次数 cs 为 19 次，系统中断次数 in 为 12 次，就绪队列长度 r 为 1，不可中断睡眠进程数 b 为 0。</p><p>而上图中的结果只是给出了系统总体的上下文切换情况，如果想要每个进程的详细情况，可使用 <code>pidstat</code> 命令，如下。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pidstat -w 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没隔 5s 输出一组数据。</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230423143205743.png" alt="image-20230423143205743"></p><p>上图中的结果重点关注这两项：</p><ul><li><p>cswch：每秒自愿上下文切换次数；</p><p>指进程无法获取所需资源，导致的上下文切换。比如 I&#x2F;O、内存等系统资源不足时，就会发生自愿上下文切换。</p></li><li><p>nvcswch：秒非自愿上下文切换次数。</p><p>指进程由于时间片已到（即分配到的 CPU 时间使用完了），被系统强制调度，进而发生的上下文切换。比如，大量进程竞争 CPU 时，就容易发生非自愿上下文切换。</p></li></ul><h3 id="1-2-模拟多线程调度切换"><a href="#1-2-模拟多线程调度切换" class="headerlink" title="1.2 模拟多线程调度切换"></a>1.2 模拟多线程调度切换</h3><p>1、环境</p><p>使用 sysbench 来模拟系统多线程调度切换的情况。sysbench 是一个多线程的基准测试工具，一般用来评估不同系统参数下的数据库负载情况。当然，在这次案例中，我们只把它当成一个异常进程来看，作用是模拟上下文切换过多的问题。</p><p>虚拟机配置：</p><ul><li>Linux：CentOS 7.9</li><li>配置：2C 4G</li><li>服务器安装软件：yum install -y sysbench sysstat</li></ul><p>2、开始实验</p><ul><li><p>在第一个终端运行 sysbench，模拟系统多线程调度的瓶颈</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以 10 个线程运行 5 分钟的基准测试，模拟多线程切换的问题</span></span><br><span class="line">sysbench --threads=10 --max-time=300 threads run</span><br></pre></td></tr></table></figure></li><li><p>在第二个终端运行 vmstat ，观察上下文切换情况</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔 1 秒输出 1 组数据</span></span><br><span class="line">vmstat 1</span><br></pre></td></tr></table></figure><blockquote><p>可见 cs 上下文切换瞬间上升到 329 万。</p><p><code>r</code>就绪队列：平均达到了 7~8，远远超过了系统 CPU 的个数 2，所以肯定会有大量的 CPU 竞争；</p><p><code>us（user）</code>和 <code>sy（system）</code>CPU使用率：几乎达到 100%，且明显看到时系统 CPU 使用率占大头（高达 86% 以上），说明 CPU 主要是被内核占用了；</p><p><code>in</code> 中断次数：中断次数也上升到了 5 万左右，说明中断处理也是个潜在的问题。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230424170358753.png" alt="image-20230424170358753"></p><p>综合这几个指标，我们可以知道，系统的就绪队列过长，也就是正在运行和等待 CPU 的进程数过多，导致了大量的上下文切换，而上下文切换又导致了系统 CPU 的占用率升高。</p></li><li><p>在第三个终端再用 pidstat 来看到底是什么进程导致了这些问题</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔 1 秒输出 1 组数据</span></span><br><span class="line"><span class="comment"># -w 参数表示输出进程切换指标，而 -u 参数则表示输出 CPU 使用指标</span></span><br><span class="line">pidstat -w -u 1</span><br></pre></td></tr></table></figure><p>下图中可见，sysbench 这个进程的 CPU 使用率已经高达 190%。但 CPU 上下文切换与上图进行对比，你会发现上图中通过 vmstat 查询的 CPU 上下文切换达到了 300 多万，而下图中通过 pidstat 查询的 CPU 自愿上下文切换才几十（20 多），为什么会相差这么大呢？</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230424172801619.png" alt="image-20230424172801619"></p><p>实际上是因为 pidstat 默认查看的是进程的相关指标，如果你要显示线程的相关指标数据，你需要添加 <code>-t</code> 选项，再次测试一下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -wt 1</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230424174500386.png" alt="image-20230424174500386"></p><p>可见，这才是 sysbench 进程的线程的 CPU 上下文切换指标数据，与 vmstat 看到的数据基本吻合。</p><p>此时，我们已经找出了导致 CPU 大量上下文切换的进程，那除此之外，还可能有什么系统性能影响因素吗？显然是还有的，在第二个终端的时候可看到，除了 CPU 上下文飙升之外，中断也是骤然飙升，因此，还有中断问题可能会影响系统性能。</p><p>那是什么类型的中断会真么高呢？前面几个命令都没有输出详细的中断信息，因此我们需要参考系统中的 <code>/proc/interrupts</code> 文件，该文件用于内核空间与用户空间之间的通信使用。因此，我们继续来观察该文件的变化情况：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -d <span class="built_in">cat</span> /proc/interrupts</span><br></pre></td></tr></table></figure><blockquote><p>在压测下，可以发现，变化速度最快的是<code>重调度中断(RES)</code>，表示唤醒空闲状态的 <code>CPU</code> 来调度新的任务运行。这是多处理器系统(SMP)中，调度器用来分散任务队列到不同 <code>CPU</code> 的机制，通常也被称为<code>处理器间中断</code>。根本原因还是因为过多任务的调度问题，跟前边分析结果是一致的。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230424180408568.png" alt="image-20230424180408568"></p></li></ul><h2 id="二、每秒上下文切换多少次算正常"><a href="#二、每秒上下文切换多少次算正常" class="headerlink" title="二、每秒上下文切换多少次算正常"></a>二、每秒上下文切换多少次算正常</h2><p><strong>这个数值其实取决于系统本身的 CPU 性能</strong>。如果系统的上下文切换次数比较稳定，那么从数百到一万以内，都应该算是正常的。但当上下文切换次数超过一万次，或者切换次数出现数量级的增长时，就很可能已经出现了性能问题。</p><p>这时，你还需要根据上下文切换的类型，再做具体分析。比方说：</p><ul><li>自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I&#x2F;O 等其他问题；</li><li>非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈；</li><li>中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 &#x2F;proc&#x2F;interrupts 文件来分析具体的中断类型。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于 CPU 上下文切换，我们应该灵活使用相关的命令工具，如 <strong>mpstat、vmstat 、 pidstat</strong>等命令，关键是要明白每个工具输出的指标数据代表的是什么，会对系统有什么影响。</p>]]></content>
    
    
    <summary type="html">如何理解 Linux 的 CPU 上下文切换（连载）。</summary>
    
    
    
    <category term="优化篇" scheme="https://blog.rabcnops.cn/categories/%E4%BC%98%E5%8C%96%E7%AF%87/"/>
    
    <category term="Linux 系统" scheme="https://blog.rabcnops.cn/categories/%E4%BC%98%E5%8C%96%E7%AF%87/Linux-%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="CPU" scheme="https://blog.rabcnops.cn/categories/%E4%BC%98%E5%8C%96%E7%AF%87/Linux-%E7%B3%BB%E7%BB%9F/CPU/"/>
    
    
    <category term="优化" scheme="https://blog.rabcnops.cn/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>如何理解 Linux 的 CPU 上下文切换？</title>
    <link href="https://blog.rabcnops.cn/posts/articles/371209c6.html"/>
    <id>https://blog.rabcnops.cn/posts/articles/371209c6.html</id>
    <published>2023-04-23T04:12:00.000Z</published>
    <updated>2023-04-23T09:53:28.801Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/linux-protection-rings.jpg#pic_center" alt="linux-protection-rings"></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们说，Linux 是一个多用户多任务的操作系统，前面说到理想情况下如果每个 CPU 都执行着一个进程，那我们说 CPU 的使用率刚刚完全被利用（无 CPU 浪费），如果进程数超过 CPU  个数，可能会出现 CPU 使用率或系统平均负载升高的问题。</p><p>实际上，Linux 操作系统支持远大于 CPU 数量的任务（进程）同时运行，而这些进程实际上并不是真正的在同时运行，就好比在你的 windows 上同时运行多个软件（如听歌的同时在玩游戏），宏观上貌似是同时运行的，但实际上是轮流运行的。之所以会有这样的感觉，是因为操作系统在短时间内将 CPU 轮流分配给它们，造成多任务同时运行的错觉。此时就会设计到<code>并发</code>与<code>并行</code>的基本概念（这里指的就是<code>并发</code>），大家可以自行 Google 它们之间的区别，这里不作为重点。</p><p>此时，你会想，进程在竞争 CPU 时并没有真正运行，那为什么会导致系统负载升高呢？实际上就是因为 CPU 上下文切换导致。</p><h2 id="一、什么是-CPU-上下文？"><a href="#一、什么是-CPU-上下文？" class="headerlink" title="一、什么是 CPU 上下文？"></a>一、什么是 CPU 上下文？</h2><p>首先，在每个任务（进程）运行之前，CPU 都需要知道任务从哪里加载、又从哪里开始运行，也就是说，需要操作系统事先帮它设置好 <code>CPU 寄存器和程序计数器</code>。</p><ul><li><strong>CPU 寄存器</strong>：CPU 内置的容量小、但速度快的内存；</li><li><strong>程序计数器</strong>：用来存储 CPU 正在执行的指令位置或即将执行的下一条指令位置。</li></ul><p>这两项都是 CPU 在运行任何进程前，必须依赖的环境，因此我们也称之为 <code>CPU 上下文</code>。</p><h2 id="二、什么是-CPU-上下文切换？"><a href="#二、什么是-CPU-上下文切换？" class="headerlink" title="二、什么是 CPU 上下文切换？"></a>二、什么是 CPU 上下文切换？</h2><p>通过上面的 CPU 上下文概念，我想应该很好理解<code>CPU 上下文切换</code>的概念。</p><p>所谓的 <code>CPU 上下文切换</code>，就是先把前一个任务的 <code>CPU</code> 上下文保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳到程序计数器所指的新位置，运行新任务。而前面这些保存下来的上下文，会存储在系统内核中，并在这些任务被重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</p><p>此时，根据任务的不同，<code>CPU</code> 的上下文切换可以分为几个不同的场景：<code>进程上下文切换</code>、<code>线程上下文切换</code>、<code>中断上下文切换</code>。</p><h3 id="2-1-进程上下文切换"><a href="#2-1-进程上下文切换" class="headerlink" title="2.1 进程上下文切换"></a>2.1 进程上下文切换</h3><p>Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间，分别对应着下图中， CPU 特权等级的 Ring 0 和 Ring 3。</p><ul><li>内核空间（Ring 0）具有最高权限，可以直接访问所有资源；</li><li>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。</li></ul><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/4d3f622f272c49132ecb9760310ce1a7.png" alt="img"></p><p>也就是说，进程既可以在用户空间运行，又可以在内核空间中运行。进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。从用户态到内核态的转变，需要通过<strong>系统调用</strong>来完成。比如，当我们查看文件内容时，就需要多次系统调用来完成：首先调用 open() 打开文件，然后调用 read() 读取文件内容，并调用 write() 将内容写到标准输出，最后再调用 close() 关闭文件。</p><p>那么，系统调用的过程有没有发生 CPU 上下文的切换呢？答案自然是肯定的。</p><p>CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。</p><p>而系统调用结束后，CPU 寄存器需要<strong>恢复</strong>原来保存的用户态，然后再切换到用户空间，继续运行进程。所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换。简单理解系统调用时发生的两次 CPU 上下文切换就是：</p><ul><li><code>进程1上下文（用户态）</code> - - 1次切换 - - &gt; <code>进程1上下文（内核态）</code> - - 2次切换 - - &gt; <code>进程1上下文（用户态）</code></li></ul><p>不过，需要注意的是，系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。这跟我们通常所说的进程上下文切换是不一样的：</p><ul><li>进程上下文切换，是指从一个进程切换到另一个进程运行。</li><li>而系统调用过程中一直是同一个进程在运行。</li></ul><p>需要注意的是：<strong>系统调用过程通常称为特权模式切换，而不是上下文切换</strong>。而实际上，系统调用过程中，CPU 的上下文切换还是无法避免的。</p><p><strong>那么，进程上下文切换跟系统调用又有什么区别呢？</strong></p><p>首先，你需要知道，进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以，进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。</p><p>因此，进程的上下文切换就比系统调用时多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。</p><p>如下图所示，保存上下文和恢复上下文的过程并不是“免费”的，需要内核在 CPU 上运行才能完成。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/395666667d77e718da63261be478a96b.png" alt="img"></p><p>根据<a href="https://blog.tsunanet.net/2010/11/how-long-does-it-take-to-make-context.html"> Tsuna </a>的测试报告，每次上下文切换都需要几十纳秒到数微秒的 CPU 时间。这个时间还是相当可观的，特别是在进程上下文切换次数较多的情况下，很容易导致 CPU 将大量时间耗费在寄存器、内核栈以及虚拟内存等资源的保存和恢复上，进而大大缩短了真正运行进程的时间。这也正是上一节中我们所讲的，导致平均负载升高的一个重要因素。</p><p>另外，我们知道， Linux 通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB 也需要刷新，内存的访问也会随之变慢。特别是在多处理器系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程。</p><p>知道了进程上下文切换潜在的性能问题后，我们再来看，究竟什么时候会切换进程上下文。</p><p>显然，进程切换时才需要切换上下文，换句话说，只有在进程调度的时候，才需要切换上下文。Linux 为每个 CPU 都维护了一个就绪队列，将活跃进程（即正在运行和正在等待 CPU 的进程）按照优先级和等待 CPU 的时间排序，然后选择最需要 CPU 的进程，也就是优先级最高和等待 CPU 时间最长的进程来运行。</p><p><strong>那么，进程在什么时候才会被调度到 CPU 上运行呢？</strong></p><p>最容易想到的一个时机，就是进程执行完终止了，它之前使用的 CPU 会释放出来，这个时候再从就绪队列里，拿一个新的进程过来运行。其实还有很多其他场景，也会触发进程调度，在这里我给你逐个梳理下。</p><ul><li><p>其一：为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行。</p></li><li><p>其二：进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。</p></li><li><p>其三：当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。</p></li><li><p>其四：当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。</p></li><li><p>最后一个：发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。</p></li></ul><p>了解这几个场景是非常有必要的，因为一旦出现上下文切换的性能问题，它们就是幕后凶手。</p><h3 id="2-2-线程上下文切换"><a href="#2-2-线程上下文切换" class="headerlink" title="2.2 线程上下文切换"></a>2.2 线程上下文切换</h3><p>说完了进程的上下文切换，我们再来看看线程相关的问题。</p><p>线程与进程最大的区别在于，<strong>线程是调度的基本单位，而进程则是资源拥有的基本单位</strong>。说白了，所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源。所以，对于线程和进程，我们可以这么理解：</p><ul><li>当进程只有一个线程时，可以认为进程就等于线程。</li><li>当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。</li><li>另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。</li></ul><p>这么一来，线程的上下文切换其实就可以分为两种情况：</p><ul><li><p>第一种：前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。</p></li><li><p>第二种：前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。</p></li></ul><p>到这里你应该也发现了，虽然同为上下文切换，但同进程内的线程切换，要比多进程间的切换消耗更少的资源，而这也正是多线程代替多进程的一个优势。</p><h3 id="2-3-中断上下文切换"><a href="#2-3-中断上下文切换" class="headerlink" title="2.3 中断上下文切换"></a>2.3 中断上下文切换</h3><p>除了前面两种上下文切换，还有一个场景也会切换 CPU 上下文，那就是中断。</p><p>为了快速响应硬件的事件，<strong>中断处理会打断进程的正常调度和执行</strong>，转而调用中断处理程序，响应设备事件。而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。</p><p>跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。</p><p><strong>对同一个 CPU 来说，中断处理比进程拥有更高的优先级</strong>，所以中断上下文切换并不会与进程上下文切换同时发生。同样道理，由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。</p><p>另外，跟进程上下文切换一样，中断上下文切换也需要消耗 CPU，切换次数过多也会耗费大量的 CPU，甚至严重降低系统的整体性能。所以，当你发现中断次数过多时，就需要注意去排查它是否会给你的系统带来严重的性能问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>CPU 上下文切换，是保证 Linux 系统正常工作的核心功能之一，一般情况下不需要我们特别关注；</li><li>但过多的上下文切换，会把 CPU 时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，从而缩短进程真正运行的时间，导致系统的整体性能大幅下降。</li></ul>]]></content>
    
    
    <summary type="html">如何理解 Linux 的 CPU 上下文切换。</summary>
    
    
    
    <category term="优化篇" scheme="https://blog.rabcnops.cn/categories/%E4%BC%98%E5%8C%96%E7%AF%87/"/>
    
    <category term="Linux 系统" scheme="https://blog.rabcnops.cn/categories/%E4%BC%98%E5%8C%96%E7%AF%87/Linux-%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="CPU" scheme="https://blog.rabcnops.cn/categories/%E4%BC%98%E5%8C%96%E7%AF%87/Linux-%E7%B3%BB%E7%BB%9F/CPU/"/>
    
    
    <category term="优化" scheme="https://blog.rabcnops.cn/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>你真理解 Linux 系统的平均负载吗？</title>
    <link href="https://blog.rabcnops.cn/posts/articles/f026fcb9.html"/>
    <id>https://blog.rabcnops.cn/posts/articles/f026fcb9.html</id>
    <published>2023-04-20T09:12:00.000Z</published>
    <updated>2023-04-23T09:53:35.635Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420135405814.png" alt="image-20230420135405814"></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们经常用到 top、uptime 来查看系统的平均负载，那下图的这三个值的含义你真正理解了吗？</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420133044303.png" alt="image-20230420133044303"></p><p><strong>平均负载是 CPU 使用率吗？</strong></p><p>显然不是，平均负载指的是<code>单位时间内，系统处于“可运行状态”和“不可中断状态”的平均进程数</code>，即<code>平均活跃进程数</code>，它和 CPU 的使用率并没有直接关系。</p><p><strong>什么是可运行状态？什么又是不可中断状态？</strong></p><ul><li><p><code>可运行状态</code>：正在使用 CPU 或正在等待 CPU 的调度的进程（如 R 状态的进程 - - Running&#x2F;Runnable）；</p></li><li><p><code>不可中断状态</code>：处于系统内核态关键流程中的进程，且这些流程是不可打断的（如 D 状态的进程）。</p><blockquote><p>比如：向磁盘写入数据，这个过程在未得到磁盘响应前一般是不允许中断的，否则将导致磁盘数据与进程数据不一致的问题。因此，不可中断状态实际上是系统对进程和硬件设备的一种保护机制。</p></blockquote></li></ul><p><strong>因此，理想情况下就是每个 CPU 上都刚好运行着一个进程，这样每个 CPU 都得到了充分的利用。</strong></p><p><strong>当平均负载为 2 时，意味着什么呢？</strong></p><ul><li>在只有 2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用；</li><li>在 4 个 CPU 的系统上，意味着 CPU 有 50% 的空闲；</li><li>而在只有 1 个 CPU 的系统上，则意味着有一半的进程竞争不到 CPU。</li></ul><h2 id="一、如何判断系统是否过载？"><a href="#一、如何判断系统是否过载？" class="headerlink" title="一、如何判断系统是否过载？"></a>一、如何判断系统是否过载？</h2><p>上面我们大体了解了什么是平均负载，那在实际工作中，如何判定某台服务器的平均负载过高呢？上面说到可通过 <code>top</code>、<code>uptime</code> 等命令来查看 Linux 系统的负载情况。</p><p>理想情况下，平均负载等于 CPU 个数，因此，判断负载是否过高，首先要知道你当前系统有几个 CPU，可通过 <code>top</code> 命令 + 快捷键 <code>1</code> 查看 CPU  个数：如下图，我当前的 Linux 系统只有 1 个 CPU（%Cpu0）。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420144125852.png" alt="image-20230420144125852"></p><p>或通过 shell 命令查看也是可以的：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&#x27;model name&#x27;</span> /proc/cpuinfo | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420144308842.png" alt="image-20230420144308842"></p><p>有了 CPU 个数，我们就可以判断：当平均负载 &gt; CPU 个数时，系统就已经过载。在 Linux 中，系统给我们提供了三个值，这三个值分别表示过去 1 分钟、5 分钟、15 分钟的系统平均负载。那我们主要看哪一个值呢？答案是都要看，这三个值是作为变化趋势的参考，仅凭一个值是很难准确判断的。</p><ul><li>如果 1 分钟、5 分钟、15 分钟的三个值基本相同（或者相差不大），那就说明系统负载很稳定；</li><li>但如果 1 分钟的值远小于 15 分钟的值，就说明系统最近 1 分钟的负载在减少，而过去 15 分钟内却有很大的负载；</li><li>反过来，如果 1 分钟的值远大于 15 分钟的值，就说明近 1 分钟的负载在增加，这种增加可能是临时性的（因为就短短的 1 分钟），也有持续增加或逐步减少的可能，因此这种情况需要持续观察。</li></ul><p>再举个例子：假设在单个 CPU 的系统上有 1.73，0.60，7.98 的负载，那就说明过去 1 分钟内系统有 73% 的过载、15 分钟内系统有 698% 的超载，但是从整体来看，系统的负载在降低。</p><p><strong>那么，在实际生产环境中，平均负载多高时，需要我们重点关注呢？</strong></p><p>一般，<strong>当平均负载高于 CPU 数量 70% 的时候</strong>，就应该分析排查负载高的问题了。因为负载过高，就可能导致进程响应变慢，进而影响服务的正常功能。</p><p><mark>因此，对于系统平均负载是否过载的问题，我们最好是通过 Zabbix 或 Prometheus 等监控工具监控起来，这样便于观察系统平均负载在某个时间段的变化趋势。</mark></p><h2 id="二、平均负载与-CPU-使用率关联"><a href="#二、平均负载与-CPU-使用率关联" class="headerlink" title="二、平均负载与 CPU 使用率关联"></a>二、平均负载与 CPU 使用率关联</h2><p>前面说到，平均负载与 CPU 使用率并不是同一个 <code>“东西”</code>，是有一定的区别和联系的。一般在实际生产中会遇到这三种情况：CPU 使用率高系统平均负载低、CPU 使用率低系统平均负载高、CPU 使用率与系统平均负载都高。</p><p>其实，这是在特定场景下产生的不同现象：</p><ul><li>对于 CPU 密集型进程而言：使用大量 CPU 会导致平均负载过高。此时就是 CPU 使用率高平均负载也会过高的情况；</li><li>对于 I&#x2F;O 密集型进程而言：等待 I&#x2F;O 会导致平均负载过高，但 CPU 不一定很高。此时就是 CPU 使用率低平均负载过高的情况；</li><li>大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。</li></ul><p><strong>什么是 CPU 密集型？什么又是 I&#x2F;O 密集型？</strong></p><blockquote><p>参考：<a href="https://blog.csdn.net/youanyyou/article/details/78990156">什么是CPU密集型、IO密集型？</a></p></blockquote><ul><li><p><code>CPU 密集型（CPU-bound）</code>：也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作大部分的状况是 CPU Loading 100%，CPU 要读&#x2F;写I&#x2F;O(硬盘&#x2F;内存)，I&#x2F;O 在很短的时间就可以完成，而 CPU 还有许多运算要处理，CPU Loading 很高。</p><p>在多重程序系统中，大部份时间用来做计算、逻辑判断等 CPU 动作的程序称之 CPU bound。例如一个计算圆周率至小数点一千位以下的程序，在执行的过程当中绝大部份时间用在三角函数和开根号的计算，便是属于 CPU bound 的程序。</p><p>CPU bound 的程序一般而言 CPU 占用率相当高。这可能是因为任务本身不太需要访问 I&#x2F;O 设备，也可能是因为程序是多线程实现因此屏蔽掉了等待 I&#x2F;O 的时间。</p></li><li><p><code>IO 密集型（I/O bound）</code>：IO 密集型指的是系统的 CPU 性能相对硬盘、内存要好很多，此时，系统运作大部分的状况是 CPU 在等 I&#x2F;O (硬盘&#x2F;内存) 的读&#x2F;写操作，此时 CPU Loading 并不高。</p><p>I&#x2F;O bound 的程序一般在达到性能极限时，CPU 占用率仍然较低。这可能是因为任务本身需要大量 I&#x2F;O 操作，而 Pipeline 做得不是很好，没有充分利用处理器能力。</p></li></ul><h2 id="三、案例分析"><a href="#三、案例分析" class="headerlink" title="三、案例分析"></a>三、案例分析</h2><p>准备实现所需环境：</p><ul><li>Linux 系统：CentOS 7.9 2C&#x2F;4G</li><li>压测工具：stress</li><li>性能分析工具：sysstat（包含 mpstat、pidstat 等工具）</li></ul><p>安装相关工具：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y stress sysstat</span><br></pre></td></tr></table></figure><h3 id="3-1-CPU-密集型进程"><a href="#3-1-CPU-密集型进程" class="headerlink" title="3.1 CPU 密集型进程"></a>3.1 CPU 密集型进程</h3><p>1、终端1 - - 压测：模拟一个进程 CPU 使用率 100% 的场景</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress --cpu 1 --<span class="built_in">timeout</span> 600</span><br></pre></td></tr></table></figure><p>2、终端2 - - 查看负载：运行 uptime 查看系统平均负载变化情况</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">watch -d <span class="built_in">uptime</span></span><br><span class="line"><span class="comment"># -d 参数表示高亮显示变化的区域</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420162317536.png" alt="image-20230420162317536"></p><p>3、终端3 - - 查看 CPU 使用率：运行 mpstat 查看 CPU 使用率的变化情况</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mpstat -P ALL 5</span><br><span class="line"><span class="comment"># -P ALL 表示监控所有 CPU，后面数字 5 表示间隔 5 秒后输出一组数据</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420160456532.png" alt="image-20230420160456532"></p><p>输出结果可见：%Cpu1 的使用率基本上也是 100% 了。</p><p>那么，到底是哪个进程导致了 CPU 使用率为 100% 呢？可以使用 <code>pidstat</code> 来查询：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pidstat -u 5 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 间隔 5 秒后输出一组数据</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420161018814.png" alt="image-20230420161018814"></p><p>Command 字段就是对应的执行程序。</p><p>当然，方法有很多，你也可以通过 <code>top + C + P</code> 来查看占用 CPU 的程序，如下图：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420161231638.png" alt="image-20230420161231638"></p><h3 id="3-2-I-x2F-O-密集型进程"><a href="#3-2-I-x2F-O-密集型进程" class="headerlink" title="3.2 I&#x2F;O 密集型进程"></a>3.2 I&#x2F;O 密集型进程</h3><p>1、同理进行 I&#x2F;O 测试</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress -i 1 --<span class="built_in">timeout</span> 600</span><br></pre></td></tr></table></figure><p>2、uptime 查看系统平均负载变化情况</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -d <span class="built_in">uptime</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420162638463.png" alt="image-20230420162638463"></p><p>3、mpstat 查看 CPU 使用率的变化情况</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpstat -P ALL 5</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420162908212.png" alt="image-20230420162908212"></p><p>可见，其中一个 CPU 的系统 CPU 使用率升高，但并不是因为 <code>iowait</code>  导致（但实际场景中一般会因为 IO 等待导致），说明系统 IO 还未出现瓶颈。</p><p>查看是由那个进程导致的系统层 CPU 使用率过高的方法同上！</p><h3 id="3-3-大量进程的场景"><a href="#3-3-大量进程的场景" class="headerlink" title="3.3 大量进程的场景"></a>3.3 大量进程的场景</h3><p>当系统中运行进程超出 CPU 运行能力时，就会出现等待 CPU 的进程。</p><p>1、模拟 8 个进程使用 CPU 的场景</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress --cpu 8 --<span class="built_in">timeout</span> 600</span><br></pre></td></tr></table></figure><p>2、查看系统平均负载</p><blockquote><p>由于系统只有 2 个 CPU，明显比 8 个进程要少得多，因而，系统的 CPU 处于严重过载状态，平均负载高达 7.23。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -d <span class="built_in">uptime</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420165023013.png" alt="image-20230420165023013"></p><p>3、查看 CPU 使用率的变化情况</p><blockquote><p>这两个 CPU 几乎都跑满了。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420165117693.png" alt="image-20230420165117693"></p><p>查看导致 CPU 过高的进程</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -u 5 1</span><br></pre></td></tr></table></figure><blockquote><p>这 8 个进程几乎竞争到了相同的 CPU，整体算下来严重过载了。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420165216815.png" alt="image-20230420165216815"></p><p>由于 CentOS 没有 iowait 字段，我换到 ubuntu 去看看效果：</p><blockquote><p>Linux：Ubuntu 20 1C 2G</p><p>可见，8 个进程在争抢 1 个 CPU，每个进程等待 CPU 的时间（也就是代码块中的 %wait 列）高达 87%。这些超出 CPU 计算能力的进程，最终导致 CPU 过载。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -u 5 1</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230420170058200.png" alt="image-20230420170058200"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>平均负载高有可能是 CPU 密集型进程导致的；</li><li>平均负载高并不一定代表 CPU 使用率高，还有可能是 I&#x2F;O 更繁忙了；</li><li>当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源。</li></ul>]]></content>
    
    
    <summary type="html">Linux 系统平均负载解读。</summary>
    
    
    
    <category term="优化篇" scheme="https://blog.rabcnops.cn/categories/%E4%BC%98%E5%8C%96%E7%AF%87/"/>
    
    <category term="Linux 系统" scheme="https://blog.rabcnops.cn/categories/%E4%BC%98%E5%8C%96%E7%AF%87/Linux-%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="CPU" scheme="https://blog.rabcnops.cn/categories/%E4%BC%98%E5%8C%96%E7%AF%87/Linux-%E7%B3%BB%E7%BB%9F/CPU/"/>
    
    
    <category term="优化" scheme="https://blog.rabcnops.cn/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Redis 6.0+ 的 ACL 机制</title>
    <link href="https://blog.rabcnops.cn/posts/articles/464f6e46.html"/>
    <id>https://blog.rabcnops.cn/posts/articles/464f6e46.html</id>
    <published>2023-04-19T14:00:00.000Z</published>
    <updated>2023-04-25T07:38:58.699Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/Screenshot-2022-09-28-135602.png" alt="Redis Encryption"></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redis 6.0+ 引入了 ACL 机制，类似 MySQL 一样全部权限管理，Redis 6.0 之前默认为 default 用户登录，该用户具备 root 权限，在生产中实际上是不安全的，因为只要具备 Redis 实例的密码，就可以以 root 身份对 Redis 进行操作。</p><p>因此 Redis 6.0+ 引入了 ACL 机制，ACL是使用 DSL（domain specific language）定义的，该 DSL 描述了给定用户能够执行的操作。那引用 ACL 的目的是什么呢？</p><ul><li><strong>访问安全性</strong>：ACL 使不受信任的客户端无法访问，而受信任的客户端仅具有对数据库的最低访问级别才能执行所需的工作。</li><li><strong>操作安全性</strong>：以防止由于软件错误或人为错误而导致进程或人员访问 Redis，从而损坏数据或配置。例如，没有必要让其他人员从 Redis 调用 <code>FLUSHALL</code> 命令。</li></ul><h2 id="一、安装-Redis-服务"><a href="#一、安装-Redis-服务" class="headerlink" title="一、安装 Redis 服务"></a>一、安装 Redis 服务</h2><p><strong>1、安装 Docker</strong></p><p><strong>2、安装 Redis</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name=redis-server-6.0 -p 16379:6379 redis:6.0-alpine</span><br></pre></td></tr></table></figure><p><strong>3、登录验证</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it redis-server-6.0 redis-cli</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418163454677.png" alt="image-20230418163454677"></p><h2 id="二、创建-ACL-用户"><a href="#二、创建-ACL-用户" class="headerlink" title="二、创建 ACL 用户"></a>二、创建 ACL 用户</h2><p><strong>1、创建用户并设置明文密码</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER rab on &gt;zhurs@123</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;&gt;&#x27;符号后是明文密码</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418162643165.png" alt="image-20230418162643165"></p><p><strong>2、创建用户并设置 Hash 密码</strong></p><ul><li><p>获取 Hash 值</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;zhurs@123&quot;</span> | shasum -a 256</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418162937832.png" alt="image-20230418162937832"></p><blockquote><p>随机获取 Hash 值密码</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419151021926.png" alt="image-20230419151021926"></p></li><li><p>创建用户</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER ops on <span class="comment">#a9db6465cac424cb70a81fae6f42cd63b7e2292b45795ea88695e9da2baea040</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;#&#x27;符号后是Hash值</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418163257814.png" alt="image-20230418163257814"></p></li></ul><p><strong>3、查看所有用户</strong></p><blockquote><p>会发现，不管是明文还是Hash设置密码，Redis 最终存储都是以 Hash 值存储密码。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418163600209.png" alt="image-20230418163600209"></p><p>这些用户是没有权限的，如果你要在创建用户时添加权限，你可以：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER rab on &gt;zhurs@123 ~* +@all</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;~*&#x27; 表示该用户可以访问所有key</span></span><br><span class="line"><span class="comment"># &#x27;+@all&#x27; 表示拥有这些key的所有权   + 表示授权  - 表示销权</span></span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>user</td><td>用户</td></tr><tr><td>default</td><td>用户名（default为默认用户）- - 也可是自定义用户（redis 6.0+）</td></tr><tr><td>on</td><td>是否启用该用户（on 启用，off 禁用）</td></tr><tr><td>#…</td><td>用户密码（#… 密文形式显示，oppass 表示无密码）</td></tr><tr><td>~*</td><td>用户可访问的 key（正则匹配 - -  <code>~*</code> 表示用户可访问所有 key）</td></tr><tr><td>+@</td><td>用户权限，+ 代表授权，- 代表销权；@ 后为权限类型，+@all 表示用户对 redis 具备所有权限</td></tr></tbody></table><p><strong>4、查看指定用户信息</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL GETUSER rab</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418175412239.png" alt="image-20230418175412239"></p><p><strong>5、用户登录认证</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 6.0-</span></span><br><span class="line">AUTH &lt;密码&gt;     <span class="comment"># 这种方式的用户为default用户，相当于MySQL的root用户</span></span><br><span class="line"><span class="comment"># 6.0+</span></span><br><span class="line">AUTH &lt;用户&gt; &lt;密码&gt;</span><br><span class="line"></span><br><span class="line">AUTH rab zhurs@123</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418175604891.png" alt="image-20230418175604891"></p><p>Windows 客户端工具登录：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418174020712.png" alt="image-20230418174020712"></p><p>正常连接：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418174311679.png" alt="image-20230418174311679"></p><h2 id="三、用户密码管理"><a href="#三、用户密码管理" class="headerlink" title="三、用户密码管理"></a>三、用户密码管理</h2><h3 id="3-1-删除密码"><a href="#3-1-删除密码" class="headerlink" title="3.1 删除密码"></a>3.1 删除密码</h3><p><strong>1、通过 <code>&lt;</code> 与 <code>!</code> 删除用户密码</strong></p><blockquote><p>删除密码后，AUTH 无法登录，redis 客户端也无法连接，想要连接，需再次设置密码。</p><p>相当于是删除密码，而不是设置密码为<code>空</code>，如果要设置密码为<code>空</code>，可使用<code>nopass</code>来设置。</p></blockquote><ul><li><p>明文密码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER rab &lt;zhurs@123</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;&lt;&#x27; 符号之后是前面创建用户时设置的明文密码</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418180333209.png" alt="image-20230418180333209"></p></li><li><p>Hash 密码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER ops !a9db6465cac424cb70a81fae6f42cd63b7e2292b45795ea88695e9da2baea040</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;!&#x27; 符号之后是前面创建用户时设置的Hash密码</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418180444997.png" alt="image-20230418180444997"></p></li></ul><p><strong>2、通过 <code>nopass</code> 删除用户密码</strong></p><p>为了演示，再创建一个用户 <code>test</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER <span class="built_in">test</span> on &gt;nba ~* +@all</span><br></pre></td></tr></table></figure><p>注意：一个用户可设置多个密码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER <span class="built_in">test</span> on &gt;cba ~* +@all</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418181412964.png" alt="image-20230418181412964"></p><p>查看用户详细信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL GETUSER <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418181917296.png" alt="image-20230418181917296"></p><p>开始设置 <code>test</code> 用户密码为 <code>空</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER <span class="built_in">test</span> nopass</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418182159429.png" alt="image-20230418182159429"></p><p>与<code>&lt;</code>、<code>#</code>不同的是，该用户是可以登录的，因为密码是空，只需设置密码为空即可登录，如果不设置空密码，也是无法进行用户认证。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auth <span class="built_in">test</span>      <span class="comment"># 无法认证</span></span><br><span class="line">auth <span class="built_in">test</span> <span class="string">&#x27;&#x27;</span>   <span class="comment"># 可以认证（为空或填任意密码都不影响）</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418182501637.png" alt="image-20230418182501637"></p><p>redis 客户端测试验证：</p><blockquote><p>密码处填不填不影响。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418182609602.png" alt="image-20230418182609602"></p><p>连接验证：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418182640220.png" alt="image-20230418182640220"></p><h3 id="3-2-重置用户和密码"><a href="#3-2-重置用户和密码" class="headerlink" title="3.2 重置用户和密码"></a>3.2 重置用户和密码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER <span class="built_in">test</span> reset</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419150556176.png" alt="image-20230419150556176"></p><p>重置后，该用户无法登录连接，可见 test 用户处于 <code>off</code> 禁用状态。</p><h2 id="四、权限管理"><a href="#四、权限管理" class="headerlink" title="四、权限管理"></a>四、权限管理</h2><h3 id="4-1-key-管理"><a href="#4-1-key-管理" class="headerlink" title="4.1 key 管理"></a>4.1 key 管理</h3><p><strong>1、对 test 用户设置可操作的 key</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER <span class="built_in">test</span> on &gt;zhurs@123 ~foo* ~bar* +@all</span><br><span class="line"></span><br><span class="line"><span class="comment"># test用户可管理foo、bar开头的key</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419152531283.png" alt="image-20230419152531283"></p><p><strong>2、取消用户可操作的 key</strong></p><p>通过 resetkeys 实现，此时只能操作 ob 开头的 key，<code>~foo*、~bar*</code> key 已经被 resetkeys 清空。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER <span class="built_in">test</span> on &gt;zhurs@123 ~foo* ~bar* resetkeys ~ob* +@all</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419152823519.png" alt="image-20230419152823519"></p><p><strong>3、操作所有 key</strong></p><blockquote><p><code>allkeys</code> 和 <code>~*</code> 效果一样</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER <span class="built_in">test</span> on &gt;zhurs@123 ~* +@all</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419170056975.png" alt="image-20230419170056975"></p><h3 id="4-2-权限管理"><a href="#4-2-权限管理" class="headerlink" title="4.2 权限管理"></a>4.2 权限管理</h3><p><strong>1、权限类型</strong></p><p>权限有很多，如下是 redis 所有的权限列表：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL CAT</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419171923038.png" alt="image-20230419171923038"></p><p>如查看某个权限的具体信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL CAT <span class="built_in">read</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419172131962.png" alt="image-20230419172131962"></p><p><strong>2、权限设置</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER <span class="built_in">test</span> on &gt;zhurs@123 ~foo* ~bar* +@<span class="built_in">hash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># test用户只有对hash类型的key有权限</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419172659504.png" alt="image-20230419172659504"></p><p>可见，取消了所有权限，仅限制为 hash 权限。其他权限就不一一举例了，各位可自行尝试。</p><h2 id="五、ACL-用户存储"><a href="#五、ACL-用户存储" class="headerlink" title="五、ACL 用户存储"></a>五、ACL 用户存储</h2><p>这里注意一下，以上的操作是通过 ACL 命令实现的，这些操作都只是临时存储与内存中，如果服务器或实例重启后，ACL 所设置的数据将会丢失。如下图你会发现，前面创建的 test 用户已经不见了。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419173312166.png" alt="image-20230419173312166"></p><p>那 Redis 6.0+ 是如何存储创建的用户呢？<strong>官方给出了两种方法</strong>：直接将用户信息写入配置文件 redis.conf 中、指定外部 ACL 文件。</p><p>这两种方法是<em>相互不兼容</em>的，因此，我们只能选择其中任意一种，考虑到生产上的复杂环境问题，官方建议使用外部 ACL 文件方式。</p><h3 id="5-1-配置文件实现"><a href="#5-1-配置文件实现" class="headerlink" title="5.1 配置文件实现"></a>5.1 配置文件实现</h3><p>方法比较简单，直接在 redis.conf 配置文件中追加以下内容，如果有多个用户继续往下追加即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user worker +@list +@connection ~<span class="built_in">jobs</span>:* on &gt;ffa9203c493aa99</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419175928830.png" alt="image-20230419175928830"></p><p>然后重启一下 redis 实例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart redis</span><br></pre></td></tr></table></figure><p>登录验证：</p><blockquote><p>是没问题的。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419180108307.png" alt="image-20230419180108307"></p><h3 id="5-2-外部-ACL-文件实现"><a href="#5-2-外部-ACL-文件实现" class="headerlink" title="5.2 外部 ACL 文件实现"></a>5.2 外部 ACL 文件实现</h3><p>因为不兼容，所以在做这个实验前先去掉配置文件中追加的 <code>user work ...</code> 内容，然后在配置文件中指定外部 ACL 文件路径：</p><p>找到配置文件 <code>aclfile /etc/redis/users.acl</code> 部分，并打开注释。</p><blockquote><p>我自定义的配置文件路径为：&#x2F;data&#x2F;users.acl</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419180652171.png" alt="image-20230419180652171"></p><p>手动创建 <code>users.acl</code> 文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim users.acl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件加入下面内容</span></span><br><span class="line">user root +@all ~* on &gt;zhurs@123</span><br><span class="line">user dev +@list +@connection ~<span class="built_in">jobs</span>:* on &gt;ffa9203c493aa99</span><br><span class="line">user ops +@list +@connection ~<span class="built_in">jobs</span>:* on &gt;kka2023addwedw4</span><br></pre></td></tr></table></figure><p>重启 Redis 实例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart redis</span><br></pre></td></tr></table></figure><p>登录查看：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419181841209.png" alt="image-20230419181841209"></p><p>此时<code>redis.conf</code> 配置文件中定义的密码已经失效，因此这就导致原本的 default 用户又可以无密码登录了，所以我们需要禁用 default 用户：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER default reset</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419183105049.png" alt="image-20230419183105049"></p><p><mark>哨兵和副本的 ACL 规则可查看<a href="https://redis.io/docs/management/security/acl/">官方文档。</a></mark></p><p><strong>参考</strong>：<a href="https://redis.io/docs/management/security/acl/">官方文档</a></p>]]></content>
    
    
    <summary type="html">Redis 6.0+ 的 ACL 机制。</summary>
    
    
    
    <category term="数据库" scheme="https://blog.rabcnops.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="非关系型数据库" scheme="https://blog.rabcnops.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Redis" scheme="https://blog.rabcnops.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"/>
    
    
    <category term="Redis" scheme="https://blog.rabcnops.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>如何将 Linux 系统时区设置为 CST ？</title>
    <link href="https://blog.rabcnops.cn/posts/articles/a20318db.html"/>
    <id>https://blog.rabcnops.cn/posts/articles/a20318db.html</id>
    <published>2023-04-19T08:27:14.000Z</published>
    <updated>2023-04-19T08:33:43.678Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419162034139.png" alt="image-20230419162034139"></p><hr><p>有时候，你的 Linux 系统的时区默认为 UTC：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419160158341.png" alt="image-20230419160158341"></p><p>为了能与我们本地时间对应，我们可以将系统时区设置为 CST，如何设置？接下来是详细步骤。</p><p>开始设置时区：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419160646623.png" alt="image-20230419160646623"></p><p>复制时区：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> -rf /etc/localtime</span><br><span class="line">sudo <span class="built_in">ln</span> -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要设置UTC时间</span></span><br><span class="line"><span class="comment"># sudo rm -rf /etc/localtime</span></span><br><span class="line"><span class="comment"># sudo ln -s /usr/share/zoneinfo/UTC /etc/localtime</span></span><br></pre></td></tr></table></figure><p>重新登录终端进行验证：</p><blockquote><p>PM 下午</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230419161028327.png" alt="image-20230419161028327"></p><p>如果时区设置了 CST 但时间还不准确时，可进行时间同步：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y ntp ntpdate</span><br><span class="line">sudo ntpdate 0.asia.pool.ntp.org</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux 时区设置。</summary>
    
    
    
    <category term="Linux 服务器运维实战" scheme="https://blog.rabcnops.cn/categories/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E7%BB%B4%E5%AE%9E%E6%88%98/"/>
    
    <category term="系统基础运维篇" scheme="https://blog.rabcnops.cn/categories/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E7%BB%B4%E5%AE%9E%E6%88%98/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E8%BF%90%E7%BB%B4%E7%AF%87/"/>
    
    
    <category term="Linux" scheme="https://blog.rabcnops.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 用户如何与系统内核通信？</title>
    <link href="https://blog.rabcnops.cn/posts/articles/f96953ab.html"/>
    <id>https://blog.rabcnops.cn/posts/articles/f96953ab.html</id>
    <published>2023-04-18T02:33:14.000Z</published>
    <updated>2023-04-18T02:33:31.065Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/v2-7a788c9f21efafc861328add1802a614_720w.jpg" alt="oss"></p><hr><p>了解过 Linux 的都知道，在 Linux 中有一个叫 shell 的 <code>“东西”</code>，这个 shell 是什么呢？Google 一下 shell 的含义：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230418094620363.png" alt="image-20230418094620363"></p><p>你可以把 Linux 系统想象成一个<code>“鸡蛋”</code>，shell 就是鸡蛋的壳，蛋心就是 Linux 系统内核，用户想要与系统内核通信，那必定是通过<code>壳</code>的交互来实现。与 Linux 类似，像 Windows 也是有自己的 shell（command.com 程序）。</p><p>同样，Linux 系统的 shell 本身是一个由 C 编写的程序，目前的 Linux 系统发行版一般都是以 bash 作为默认的 shell，因此，shell 既是一种命令解释程序，也是一种解释型程序设计语言。作为命令解释程序，shell 可以解释用户的输入命令，然后提交到内核处理，最后把结果返回给用户。</p><p>为了加快命令的运行，shell 中定义了一些例如 cp、cd、echo、pwd 等内置命令。当用户登录操作系统后，这些内置命令就会被装载至内存并一直运行，直到用户退出系统为止。</p><p>当然，为了满足某些生产上的需求，仅凭这些内置命令是不够的，因此引入了<code>外置命令</code>的概念。与<code>内置命令</code>不同的是，只有当外置命令被调用时，这些外置命令才会被装载至内存执行。</p><p>因此，shell 执行命令解释的过程为：</p><ul><li>用户命令行中提交可执行命令；</li><li>shell 程序检测用户输入的命令是否为内置命令。<ul><li>如果是：就通过内部的解释器将命令解释为系统调用，然后提交给内核执行；</li><li>如果不是：那 shell 会根据用户给出的命令路径或系统环境变量的路径配置寻找到可用的二进制命令，然后将其装载至内存，再将其解释为系统调用，最后提交给内核执行。</li></ul></li></ul><p><strong>综上不难看出，其实 Linux 系统其实就是用户通过与 shell 的交互来实现与系统内核的通信！</strong></p>]]></content>
    
    
    <summary type="html">Linux 用户与系统内核通信。</summary>
    
    
    
    <category term="Linux 服务器运维实战" scheme="https://blog.rabcnops.cn/categories/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E7%BB%B4%E5%AE%9E%E6%88%98/"/>
    
    <category term="系统基础运维篇" scheme="https://blog.rabcnops.cn/categories/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E7%BB%B4%E5%AE%9E%E6%88%98/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E8%BF%90%E7%BB%B4%E7%AF%87/"/>
    
    
    <category term="Linux" scheme="https://blog.rabcnops.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 安全优化</title>
    <link href="https://blog.rabcnops.cn/posts/articles/c1852d71.html"/>
    <id>https://blog.rabcnops.cn/posts/articles/c1852d71.html</id>
    <published>2023-04-13T02:51:14.000Z</published>
    <updated>2023-04-23T09:49:43.843Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230413105645046.png" alt="image-20230413105645046"></p><hr><p>作为混迹于 IT 行业的一员，相信大家都接触过 Nginx Web 服务，不管是开发、运维、测试、还是算法都离不开 Nginx，而且大家对于 Nginx 的部署也是得心应手。但有的时候我们只局限于部署应用层面，没有考虑其运行在 Internet 上的安全问题，接下来将总结常用也是生产环境上有必要配置的一些安全策略。</p><h3 id="1、使用-SSL-x2F-TLS-证书"><a href="#1、使用-SSL-x2F-TLS-证书" class="headerlink" title="1、使用 SSL&#x2F;TLS 证书"></a>1、使用 SSL&#x2F;TLS 证书</h3><p>传统的 HTTP 是一种以明文形式在端到端的超文本传输协议，在数据传输上存在很大的安全问题，如：窃听、篡改、冒充等安全问题。因此我们需要采用  SSL&#x2F;TLS 证书来实现数据加密，SSL&#x2F;TLS 证书是一种加密数字证书，<code>用于对客户端（Web 浏览器）和服务器之间的流量进行加密</code>。通过这样做，加密是安全的，并且可以防止攻击者使用中间人攻击来窃听和窃取机密信息，例如<code>用户名、密码和信用卡信息等</code>。</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen              443 ssl;</span><br><span class="line">    ssl_certificate     /etc/nginx/ssl/bundle.pem;</span><br><span class="line">    ssl_certificate_key /etc/nginx/ssl/hello.com.key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当然，在我们实际应用中，不同的云厂商会提供相应的参考配置</span></span><br></pre></td></tr></table></figure><h3 id="2、使用安全密钥交换机制"><a href="#2、使用安全密钥交换机制" class="headerlink" title="2、使用安全密钥交换机制"></a>2、使用安全密钥交换机制</h3><p>DH 参数的目的是允许交换一个秘密，该秘密将用于加密会话中的消息副本。临时 DH 提供前向安全性，这意味着会话密钥在会话终止时被删除。因此，攻击者无法检索超过上一个会话的两方之间交换的消息。</p><p>使用 OpenSSL 生成至少 2048 位的唯一 DH 组：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl dhparam -out /etc/ssl/dhparam.pem 2048</span><br></pre></td></tr></table></figure><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssl_dhparam  /etc/ssl/dhparam.pem; </span><br></pre></td></tr></table></figure><h3 id="3、禁用旧的-SSL-x2F-TLS-协议"><a href="#3、禁用旧的-SSL-x2F-TLS-协议" class="headerlink" title="3、禁用旧的 SSL&#x2F;TLS 协议"></a>3、禁用旧的 SSL&#x2F;TLS 协议</h3><p>较弱的 SSL&#x2F;TLS 协议（SSLv2.0、SSL v3.0、TLSv1.0 和 TLSv1.1）可能容易受到攻击并导致诸如 BEAST（针对 SSL&#x2F;TLS 的浏览器漏洞利用）、POODLE（在降级的旧版上填充 Oracle ）等攻击。因此建议使用更新和安全的 SSL&#x2F;TLS 协议。</p><p>什么是 BEAST 攻击？BEAST (CVE-2011-3389) 是一种明文攻击，通过从 SSL&#x2F;TLS 加密的会话中获取受害者的 COOKIE 值（通过进行一次会话劫持攻击），进而篡改一个加密算法的 CBC（密码块链）的模式以实现攻击目录，其主要针对 TLS1.0 和更早版本的协议中的对称加密算法 CBC 模式。</p><p>什么是 POODLE 攻击？很多系统与软体都会使用 Secure Socket Layer (SSL) 3.0 中的 cipher-block chaining (CBC) 模式来做资料 的加解密，而这套演算法已经被发现漏洞，其中 POODLE 是最出名的攻击方式， POODLE 全名 Padding Oracle On Downgraded Legacy Encryption ，它可以破解 web server 跟 web browser 之间的 SSLv3 传输加密。</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen              443 ssl;</span><br><span class="line">    ssl_certificate     /etc/nginx/ssl/bundle.pem;</span><br><span class="line">    ssl_certificate_key /etc/nginx/ssl/mytechnix.com.key;</span><br><span class="line">    ssl_protocols TLSv1.2 TLSv1.3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、禁用-SSL-x2F-TLS-弱密码套件"><a href="#4、禁用-SSL-x2F-TLS-弱密码套件" class="headerlink" title="4、禁用 SSL&#x2F;TLS 弱密码套件"></a>4、禁用 SSL&#x2F;TLS 弱密码套件</h3><p>较弱且旧的密码套件配置可能会很容易使你的网站受到攻击，比如攻击者可能会拦截或修改传输中的数据。因此，你可以更具你不同的 Nginx 版本和 SSL&#x2F;TLS 版本来选择更佳的密码套件，大家可以通过该网站来评估出最佳方案 —&gt; <a href="https://ssl-config.mozilla.org/">传送门</a>。输入 nginx 和 SSL&#x2F;TLS 版本后，会为你自动生成最佳配置文件，比如我输入的 Nginx 版本为 1.18.0、SSL&#x2F;TLS 版本为 1.1.1，则会生成如下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">generated 2022-04-27, Mozilla Guideline v5.6, nginx 1.18.0, OpenSSL 1.1.1k, intermediate configuration</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">https://ssl-config.mozilla.org/<span class="comment">#server=nginx&amp;version=1.18.0&amp;config=intermediate&amp;openssl=1.1.1k&amp;guideline=5.6</span></span></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    listen [::]:80 default_server;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        return 301 https://$host$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl http2;</span><br><span class="line">    listen [::]:443 ssl http2;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /path/to/signed_cert_plus_intermediates;</span><br><span class="line">    ssl_certificate_key /path/to/private_key;</span><br><span class="line">    ssl_session_timeout 1d;</span><br><span class="line">    ssl_session_cache shared:MozSSL:10m;  # about 40000 sessions</span><br><span class="line">    ssl_session_tickets off;</span><br><span class="line"></span><br><span class="line">    # curl https://ssl-config.mozilla.org/ffdhe2048.txt &gt; /path/to/dhparam</span><br><span class="line">    ssl_dhparam /path/to/dhparam;</span><br><span class="line"></span><br><span class="line">    # intermediate configuration</span><br><span class="line">    ssl_protocols TLSv1.2 TLSv1.3;</span><br><span class="line">    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;</span><br><span class="line">    ssl_prefer_server_ciphers off;  # 需要使用的时候改为on即可</span><br><span class="line"></span><br><span class="line">    # HSTS (ngx_http_headers_module is required) (63072000 seconds)</span><br><span class="line">    add_header Strict-Transport-Security &quot;max-age=63072000&quot; always;</span><br><span class="line"></span><br><span class="line">    # OCSP stapling</span><br><span class="line">    ssl_stapling on;</span><br><span class="line">    ssl_stapling_verify on;</span><br><span class="line"></span><br><span class="line">    # verify chain of trust of OCSP response using Root CA and Intermediate certs</span><br><span class="line">    ssl_trusted_certificate /path/to/root_CA_cert_plus_intermediates;</span><br><span class="line"></span><br><span class="line">    # replace with the IP address of your resolver</span><br><span class="line">    resolver 127.0.0.1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、禁用不需要的-HTTP-方法"><a href="#5、禁用不需要的-HTTP-方法" class="headerlink" title="5、禁用不需要的 HTTP 方法"></a>5、禁用不需要的 HTTP 方法</h3><p>常用的 HTTP 方法是 GET 和 POST，如果允许其他方法如 TRACE、DELETE、PUT 和 OPTIONS 是有风险的，因为这可能允许攻击者发起<code>跨站点跟踪攻击</code>并从您的网站窃取 <code>cookie</code> 信息，因此建议禁用不需要的和未使用的 HTTP 方法。</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置方式1：此时，服务器将只允许 GET、HEAD 和 POST 方法。</span></span><br><span class="line">location / &#123;</span><br><span class="line">    limit_except GET HEAD POST &#123; deny all; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置方式2：效果同1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务器只允许 GET、HEAD 和 POST 方法，并通过发出 444 No Response 状态代码过滤掉任何其他 HTTP 方法。</span></span><br><span class="line">if ($request_method !~ ^(GET|HEAD|POST)$ )</span><br><span class="line">&#123;</span><br><span class="line">    return 444;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、防止缓冲区溢出攻击"><a href="#6、防止缓冲区溢出攻击" class="headerlink" title="6、防止缓冲区溢出攻击"></a>6、防止缓冲区溢出攻击</h3><p>缓冲区是系统内存中的一个小型存储位置，当数据开始从一个内存位置传输到另一个内存位置时，它可以暂时容纳数据。当数据大小超过缓冲区大小的容量时，就会发生缓冲区溢出。因此，攻击者可以利用此漏洞注入可以危害系统的恶意代码。</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">client_body_buffer_size 1K;</span><br><span class="line">client_header_buffer_size 1k;</span><br><span class="line">client_max_body_size 1k;</span><br><span class="line">large_client_header_buffers 2 1k;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其值如何设置，具体参考《Nginx性能优化》篇</span></span><br></pre></td></tr></table></figure><h3 id="7、防止-CSP、XSS-攻击"><a href="#7、防止-CSP、XSS-攻击" class="headerlink" title="7、防止 CSP、XSS 攻击"></a>7、防止 CSP、XSS 攻击</h3><p>CSP（内容安全策略）是额外的安全层，有助于缓解某些攻击，如 XSS 跨站脚本攻击。通过添加 CSP 标头，可以告诉浏览器它只能从你明确允许的域下载内容，包括 Javascript 和 CSS 文件。</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_header Content-Security-Policy &quot;default-src &#x27;self&#x27; http: https: data: blob: &#x27;unsafe-inline&#x27;&quot; always;</span><br></pre></td></tr></table></figure><p>针对 XSS 跨站脚本攻击，可做以下参数配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_header X-XSS-Protection &quot;1; mode=block&quot;;</span><br></pre></td></tr></table></figure><h3 id="8、防止-Click-jacking-劫持"><a href="#8、防止-Click-jacking-劫持" class="headerlink" title="8、防止 Click-jacking 劫持"></a>8、防止 Click-jacking 劫持</h3><p>Click-jacking（即点击劫持）是一种 Web 应用程序漏洞，攻击者利用该漏洞强制用户在未经用户同意的情况下点击，导致重定向到未知网站。HTTP 响应标头中的 X-Frame -Option 可用于指示 Web 浏览器是否应在框架或 iframe 中加载页面。因此，在 nginx.conf 文件的 HTTP 标头中附加 X-Frame-Options，这将指示浏览器仅从同一来源加载资源。</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_header X-Frame-Options &quot;SAMEORIGIN&quot;;</span><br></pre></td></tr></table></figure><h3 id="9、禁用内容嗅探"><a href="#9、禁用内容嗅探" class="headerlink" title="9、禁用内容嗅探"></a>9、禁用内容嗅探</h3><p>内容嗅探，也称为 <code>MIME（Multipurpose Internet Mail Extensions）</code>嗅探，即<code>多用途网络邮件扩展</code>嗅探，是一种用于检查字节流内容以确定其中数据的文件格式的技术。这也可能导致安全漏洞，因为攻击者可以利用 MIME 嗅探来发送 XSS 跨站点脚本攻击。</p><p>例如，如果你的网站允许用户上传图片等媒体内容，攻击者可能会上传包含一些 JavaScript 代码的恶意图片文件。当浏览器进行内容嗅探时，可能会被诱骗执行该恶意文件。为了防止内容嗅探攻击，可将 <code>X-Content-Type-Options</code> 响应标头设置为 <code>nosniff</code>，这告诉浏览器避免猜测响应类型并仅依赖 <code>Content-Type</code> 头。</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_header X-Content-Type-Options nosniff;</span><br></pre></td></tr></table></figure><h3 id="10、图片防盗链"><a href="#10、图片防盗链" class="headerlink" title="10、图片防盗链"></a>10、图片防盗链</h3><p>“图片防盗链”顾名思义就是防止别人盗用你的图片链接，这可能会导致你的带宽使用量增加，尤其是在现的服务器带宽使用策略中基本上都是按量付费的，因此这可能会间接性造成你们公司经济损失。</p><p>例如，假设在你 web 服务器根目录中有一个名为 images 的目录，其中存储了你在站点中使用的所有图像。为了防止其他方使用你的图像，你需要在 Nginx web 服务器上做如下配置。</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /images/ &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">只允许www.hello.com hello.com请求资源</span></span><br><span class="line">  valid_referers none blocked www.hello.com hello.com;</span><br><span class="line">   if ($invalid_referer) &#123;</span><br><span class="line">     return   403;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11、启用-HSTS-功能"><a href="#11、启用-HSTS-功能" class="headerlink" title="11、启用 HSTS 功能"></a>11、启用 HSTS 功能</h3><p>HSTS 功能只允许客户端（Web 浏览器）使用 HTTPS 进行通信，这 return 和 rewrite 方法的概念不同。当浏览器接收到 HSTS 标头时，它不会在指定的时间内以 HTTP 的形式与 web 服务端通信，保证了 HTTPS 严格安全传输问题。</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_header Strict-Transport-Security &quot;max-age=31536000; includeSubDomains&quot; always;</span><br></pre></td></tr></table></figure><h3 id="12、仅允许通过域名访问"><a href="#12、仅允许通过域名访问" class="headerlink" title="12、仅允许通过域名访问"></a>12、仅允许通过域名访问</h3><p>上线过 web 应用的同志都知道，上线完成后 IP 或域名形式我们都可以访问，如果你不想允许使用 IP 地址的请求，那只需要在 Nginx 做以下配置即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ($host !~ ^(hello.com|www.hello.com)$ ) &#123;</span><br><span class="line">    return 301 https://hello.com$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13、禁止自动用户代理"><a href="#13、禁止自动用户代理" class="headerlink" title="13、禁止自动用户代理"></a>13、禁止自动用户代理</h3><p>为了保护你的服务器免受机器人、脚本和其他自动网页检索方法的侵害，请明确拒绝这些用户代理。</p><p>例如，像 wget 这样的应用程序可以检索整个文档根目录结构，使它们成为有用的 DoS 攻击者或只是访问网站上的受保护文件。</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ($http_user_agent ~* LWP::Simple|BBBike|wget) &#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14、防止服务器信息泄露"><a href="#14、防止服务器信息泄露" class="headerlink" title="14、防止服务器信息泄露"></a>14、防止服务器信息泄露</h3><p>什么意思呢？Nginx 服务器的默认配置 server_tokens 指令在所有自动生成的错误页面以及 HTTP 响应标头上会显示 Nginx 版本号，我在之前做的一个项目中就存在这个问题，当时客户的安全工程师用工具扫出了这个问题。这可能会导致 web 服务器信息泄露，攻击者可以获得有关 Nginx 版本的信息，从而缩小攻击范围。因此，我们必须禁止在客户端（浏览器）显示 Nginx 版本号等相关信息。</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server_tokens off;</span><br></pre></td></tr></table></figure><h3 id="15、禁止指定浏览器访问"><a href="#15、禁止指定浏览器访问" class="headerlink" title="15、禁止指定浏览器访问"></a>15、禁止指定浏览器访问</h3><p>如果我们不希望有些浏览器访问我们 web 服务，则可做以下设置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">功能：如果是火狐或IE浏览器，则将会跳转到百度页面</span> </span><br><span class="line"></span><br><span class="line">if ($http_user_agent ~* &quot;Firefox|MSIE&quot;) &#123;</span><br><span class="line">    rewrite ^(.*) http://www.baidu.com/$1 permanent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16、升级-Nginx-版本"><a href="#16、升级-Nginx-版本" class="headerlink" title="16、升级 Nginx 版本"></a>16、升级 Nginx 版本</h3><p>建议将您的 Nginx 服务器更新到最新和稳定的版本，因为有很多性能改进、安全修复和新功能实现。</p><hr><h5 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h5><blockquote><p>通过上面的基础配置，现整合出完整的配置</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">==========全局配置文件============</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">避免 Nginx 版本信息泄露</span></span><br><span class="line">server_tokens off;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">防止 Click-jacking 点击劫持</span></span><br><span class="line">add_header X-Frame-Options SAMEORIGIN;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">禁用内容嗅探，防止 XSS 跨站脚本攻击</span></span><br><span class="line">add_header X-Content-Type-Options nosniff;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CSP 内容安全策略，告诉浏览器它只能从你明确允许的域下载内容，防止 XSS 跨站脚本攻击</span></span><br><span class="line">add_header X-XSS-Protection &quot;1; mode=block&quot;;</span><br><span class="line">add_header Content-Security-Policy &quot;default-src &#x27;self&#x27; http: https: data: blob: &#x27;unsafe-inline&#x27;&quot; always;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用 HSTS 功能，只允许客户端（Web 浏览器）使用 HTTPS 进行通信，保证了 HTTPS 严格安全传输问题。</span></span><br><span class="line">add_header Strict-Transport-Security &quot;max-age=31536000; includeSubDomains&quot; always;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">防止缓冲区溢出攻击，免密攻击者恶意代码注入</span></span><br><span class="line">client_body_buffer_size 1K;</span><br><span class="line">client_header_buffer_size 1k;</span><br><span class="line">client_max_body_size 1k;</span><br><span class="line">large_client_header_buffers 2 1k;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">==========虚拟主机配置============</span></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    listen [::]:80 default_server;</span><br><span class="line">    server_name hello.com;</span><br><span class="line">    return 301 https://$host$request_uri;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl http2;</span><br><span class="line">    listen [::]:443 ssl http2;</span><br><span class="line">    server_name hello.com;</span><br><span class="line"></span><br><span class="line">    # SSL/TLS 证书/密钥</span><br><span class="line">    ssl_certificate     /etc/nginx/ssl/bundle.pem;</span><br><span class="line">    ssl_certificate_key /etc/nginx/ssl/hello.com.key;</span><br><span class="line"></span><br><span class="line">    # DH 密钥交换机制，会话密钥在会话终止时被删除，攻击者无法检索双方之间交换的消息。</span><br><span class="line">    ssl_dhparam /etc/nginx/ssl/dhparam.pem;</span><br><span class="line"></span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">    # 禁用旧的 SSL/TLS 协议</span><br><span class="line">    ssl_protocols TLSv1.2 TLSv1.3;</span><br><span class="line"></span><br><span class="line">    # 禁用 SSL/TLS 弱密码套件</span><br><span class="line">    ssl_ciphers &#x27;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&#x27;;+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&#x27;;</span><br><span class="line"></span><br><span class="line">    # 禁用不需要的 HTTP 方法</span><br><span class="line">    if ($request_method !~ ^(GET|HEAD|POST)$ )&#123;</span><br><span class="line">        return 444;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 图片防盗链</span><br><span class="line">    location /images/ &#123;</span><br><span class="line">        valid_referers none blocked www.hello.com mytechnix.com;</span><br><span class="line">        if ($invalid_referer) &#123;</span><br><span class="line">            return   403;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    # 仅允许通过域名形式访问 web 服务器</span><br><span class="line">    if ($host !~ ^(hello.com|www.hello.com)$ ) &#123;</span><br><span class="line">        return 301 https://hello.com$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line">    # 禁止自动用户代理，防止 Dos 攻击</span><br><span class="line">    if ($http_user_agent ~* LWP::Simple|BBBike|wget) &#123;</span><br><span class="line">        return 403;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Nginx 安全优化及应用。</summary>
    
    
    
    <category term="优化篇" scheme="https://blog.rabcnops.cn/categories/%E4%BC%98%E5%8C%96%E7%AF%87/"/>
    
    <category term="Nginx" scheme="https://blog.rabcnops.cn/categories/%E4%BC%98%E5%8C%96%E7%AF%87/Nginx/"/>
    
    
    <category term="优化" scheme="https://blog.rabcnops.cn/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 性能优化</title>
    <link href="https://blog.rabcnops.cn/posts/articles/31a3358a.html"/>
    <id>https://blog.rabcnops.cn/posts/articles/31a3358a.html</id>
    <published>2023-04-13T02:51:14.000Z</published>
    <updated>2023-04-23T09:49:53.399Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230413105645046.png" alt="image-20230413105645046"></p><hr><h3 id="1、调整-worker-进程数"><a href="#1、调整-worker-进程数" class="headerlink" title="1、调整 worker 进程数"></a>1、调整 worker 进程数</h3><p>nginx 有一个 master 进程和多个 work 进程。master 进程的主要目的是读取和评估配置，并维护 work 进程。work 进程对请求进行实际处理。在高并发、高访问的场景下，需要提前启动更多的 nginx 进程，以保证快速响应，处理大量并发用户的请求。</p><p>现在的服务器基本上都是多线程和多进程的，而 Nginx 默认不允许处理多个工作负载，因此你可以修改配置文件中<code>worker_processes</code>参数使其作为多线程 web 服务器来工作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看CPU核心数</span></span><br><span class="line">grep processor /proc/cpuinfo | wc -l</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">于是可设置工作进程为4并绑定到不同CPU</span></span><br><span class="line">worker_processes  2;  # 如果设置未auto，就不需要手动绑定，它会自动绑定</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果你的服务器是2核</span></span><br><span class="line">worker_cpu_affinity 0101 1010;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果你的服务器是4核</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">worker_cpu_affinity 0001 0010 0100 1000;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果你的服务器是8核</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;</span></span><br></pre></td></tr></table></figure><p>这里放一个 <code>worker_cpu_affinity</code> 的计算脚本，该脚本会根据你服务器的 CPU 核数来自动计算 <code>worker_cpu_affinity</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># @file: nginx-affinity.sh</span></span><br><span class="line"><span class="comment"># @brief:</span></span><br><span class="line"><span class="comment"># @author: YoungJoo.Kim &lt;http://vozlt.com&gt;</span></span><br><span class="line"><span class="comment"># @version:</span></span><br><span class="line"><span class="comment"># @date:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Linux only.</span></span><br><span class="line"><span class="comment"># Nginx worker_cpu_affinity</span></span><br><span class="line"><span class="comment"># http://wiki.nginx.org/CoreModule</span></span><br><span class="line"></span><br><span class="line">n=$(awk <span class="string">&#x27;/^processor/&#123;n=$3&#125; END&#123;print n&#125;&#x27;</span> /proc/cpuinfo)</span><br><span class="line">aff=$(<span class="built_in">printf</span> <span class="string">&quot;0%0<span class="variable">$&#123;n&#125;</span>d&quot;</span> 0)</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;worker_processes %d;\n&quot;</span> $((n+<span class="number">1</span>))</span><br><span class="line">[ <span class="variable">$n</span> -eq 0 ] &amp;&amp; <span class="built_in">exit</span>;</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;worker_cpu_affinity &quot;</span></span><br><span class="line"><span class="keyword">for</span> ((a=<span class="number">0</span>; a &lt;= n; a++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    poss=$((n - a))</span><br><span class="line">    pose=$((n - poss))</span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$pose</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">printf</span> <span class="string">&quot;%0<span class="variable">$&#123;poss&#125;</span>d1&quot;</span> 0</span><br><span class="line">    <span class="keyword">elif</span> [ <span class="variable">$poss</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">        [ <span class="variable">$poss</span> -eq 0 ] &amp;&amp; <span class="built_in">printf</span> <span class="string">&quot;1%0<span class="variable">$&#123;pose&#125;</span>d&quot;</span> 0</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        [ <span class="variable">$pose</span> -ne 0 ] &amp;&amp; <span class="built_in">printf</span> <span class="string">&quot;%0<span class="variable">$&#123;poss&#125;</span>d1%0<span class="variable">$&#123;pose&#125;</span>d&quot;</span> 0 0</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    [ <span class="variable">$n</span> != <span class="variable">$a</span> ] &amp;&amp; <span class="built_in">echo</span> -n <span class="string">&quot; &quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;;&quot;</span>;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221221103441811.png" alt="image-20221221103441811"></p><h3 id="2、调整-worker-连接数"><a href="#2、调整-worker-连接数" class="headerlink" title="2、调整 worker 连接数"></a>2、调整 worker 连接数</h3><p><code>work 连接数</code>与<code>work 进程数</code>息息相关，可通过 <code>worker_connections</code> 参数设置 work 连接数。worker_connections 参数用于设置 Nginx 单个 work 进程（worker_processes）允许的最大客户端连接数。</p><p>而 Nginx 默认的 1024 在生产环境来说是比较小的，因此需要调整该参数。该配置参数位于 events 事件中，Linux 中 nginx 采用 epoll 的 I&#x2F;O 复用模型，FreeBSD 中使用 kqueue 的 I&#x2F;O 复用模型，Solaris 中使用 &#x2F;dev&#x2F;poll 的 I&#x2F;O 复用模型，Windows中使用 ICOP 等。</p><p>因此，我们需要针对不同的系统类型来选择不同的事件处理模型。我用的是 CentOS 7，所以把 nginx 的事件处理模型调整为 epoll 模型。</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    use epoll;</span><br><span class="line">    worker_connections  20240;</span><br><span class="line">    multi_accept on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个参数也是需要注意的，就是 <code>multi_accept on</code>，该参数告诉 nginx 收到一个新连接通知后接受尽可能多的连接，<code>默认是on</code>，且为串行处理连接数。当为 off 时为并行处理连接数，即多个 work 进程同时处理连接。因此，<code>当你的客户端连接数较少时，参数值置为 on，相反在连接数较多、服务器吞吐量较大时，参数值置 off，可提高 Nginx 性能。</code></p><p>当然，这个 work 连接数也不是说可无限设置大，它和系统自身<code>内存</code>、<code>最大文件打开数</code>有关。一个连接分别对应一个 <code>read_event</code> 和一个 <code>write_event</code> 事件。一个连接本身占用 232 字节左右，两个事件总占 96 字节左右，于是一个连接（连接 + read_event + write_event）总共就占 328 字节。</p><p>因此，上面的 20240 的连接数就会占用 20240*328&#x2F;1024&#x2F;1024 &#x3D; 6M 大小内存。</p><p>在来看看 worker 进程最大打开文件数，该值其实在我们设置系统最大打开文件数的时候已经指定（*&#x2F;指定用户），如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/security/limits.conf</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">root soft nofile 65535</span><br><span class="line">root hard nofile 65535</span><br><span class="line">* soft nofile 65535</span><br><span class="line">* hard nofile 65535</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">End of file</span></span><br></pre></td></tr></table></figure><p>因此，只需要设置 <code>worker_rlimit_nofile</code> 值为以上 65535 值即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置Nginx worker进程最大打开文件数</span></span><br><span class="line">worker_rlimit_nofile 65535;</span><br></pre></td></tr></table></figure><h3 id="3、调整-work-进程最大打开文件数"><a href="#3、调整-work-进程最大打开文件数" class="headerlink" title="3、调整 work 进程最大打开文件数"></a>3、调整 work 进程最大打开文件数</h3><p>接下来调整配置 nginx 的 worker 进程的最大打开文件数，控制连接数的参数是 <code>worker_rlimit_nofile</code>，该值与 nginx 所在操作系统的最大打开文件数相关，也就是你 nginx 的 work 进程最大打开文件数必须小于或等于自身操作系统的最大打开文件数，要不然设置了也是没意义的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先查看系统自身最大打开文件数</span></span><br><span class="line">ulimit -n</span><br><span class="line">65536</span><br></pre></td></tr></table></figure><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">控制在系统最大打开文件数内即可</span></span><br><span class="line">worker_rlimit_nofile 65536;</span><br></pre></td></tr></table></figure><p>需要注意：</p><h3 id="4、开启高效文件传输模式"><a href="#4、开启高效文件传输模式" class="headerlink" title="4、开启高效文件传输模式"></a>4、开启高效文件传输模式</h3><p><code>sendfile on|off</code> 参数用于启用高效文件传输模式，默认是 off 的，作用域：http、server、location。该参数通常结合 <code>tcp_nopush on|off</code> 参数和 <code>tcp_nodelay on|off</code> 来防止网络和磁盘 I&#x2F;O 阻塞，提升 nginx 效率。当开启 sendfile 后 <code>tcp_nopush on|off</code> 参数和 <code>tcp_nodelay on|off</code> 只能二选一，而且开启 sendfile 后默认启用的是 <code>tcp_nopush on</code>。</p><ul><li><strong>tcp_nopush on|off</strong>：该参数会启用 tcp_cork 方法，仅当 sendfile 开启后生效，其功能是：当应用程序收到数据包时不会马上传送出去，而是等到数据包最大时，才一次性的传输出去。这样解决了网络堵塞问题。</li><li><strong>tcp_nodelay on|off</strong>：该参数会启用 tcp_nodelay 方法，其功能是：当应用程序收到数据包时会尽量发送小数据块，而不是等一定数据量满了之后才发送。这样解决了磁盘I&#x2F;O问题。</li></ul><p>如何选择？下面注释写得比较清楚</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sendfile on;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决网络拥塞问题</span></span><br><span class="line">tcp_nopush on;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决磁盘I/O问题</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcp_nodelay on;</span></span><br></pre></td></tr></table></figure><h3 id="5、限制文件上传大小"><a href="#5、限制文件上传大小" class="headerlink" title="5、限制文件上传大小"></a>5、限制文件上传大小</h3><p><code>限制文件上传大小</code> 指的是 <code>限制 HTTP 请求正文大小</code>，通过 <code>client_ max_ body_ Size</code> 参数设置。如果上传文件的大小超过此设置，则会响应 <code>413 Request Entity Too Large</code> 错误代码。如果服务器涉及上传文件的业务，就可以通过该参数来限制。</p><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client_max_body_Size 10m;</span><br></pre></td></tr></table></figure><p>nginx 对上传文件大小默认为 1m 大小，如果很大，还要适当调整上传超时时间。</p><ul><li><strong>client_header_timeout</strong>：读取请求头的超时时间，默认60秒。若超过所设定的大小，返回 408 错误。</li><li><strong>client_body_timeout</strong>：读取请求实体的超时时间，默认60秒。若超过所设定的大小，返回 413 错误。</li></ul><p>作为代理时的超时时间：</p><ul><li><strong>proxy_connect_timeout</strong>：HTTP 请求无法立即被容器（tomcat, netty 等）处理，被放在 nginx 的待处理池中等待被处理超时时间。默认为 60s，官方推荐最长不要超过 75s。</li><li><strong>proxy_read_timeout</strong>：HTTP 请求被容器（tomcat, netty 等）处理完后，nginx 等待处理结果的时长，默认60秒。</li><li><strong>proxy_send_timeout</strong>：HTTP 请求被容器（tomcat, netty 等）处理完后，把数据传返回给 nginx 的时长，默认60秒。</li></ul><p>最终配置参考：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">client_max_body_Size 10m;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其实以下参数你不配置，它都是默认生效的</span></span><br><span class="line">client_header_timeout 60;</span><br><span class="line">client_body_timeout 60;</span><br><span class="line">proxy_connect_timeout 60;</span><br><span class="line">proxy_read_timeout 60;</span><br><span class="line">proxy_send_timeout 60;</span><br></pre></td></tr></table></figure><h3 id="6、开启-gzip-压缩"><a href="#6、开启-gzip-压缩" class="headerlink" title="6、开启 gzip 压缩"></a>6、开启 gzip 压缩</h3><p>gzip 压缩模块提供了压缩文件内容的功能，在用户请求的内容发送到用户客户端之前，nginx 服务器会根据一些具体的策略执行压缩策略，从而节省网站的出口带宽，加快数据传输效率，提升用户体验。</p><p><code>最好是在有大文件时启用它，因为它本身也会消耗CPU资源。</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gzip  on;</span><br><span class="line">gzip_min_length  1k;</span><br><span class="line">gzip_buffers     4 16k;</span><br><span class="line">gzip_http_version 1.1;</span><br><span class="line">gzip_comp_level 9;</span><br><span class="line">gzip_types text/plain text/javascript application/javascript text/css application/xml application/json;</span><br><span class="line">gzip_disable &quot;MSIE [1-6]\.&quot;;</span><br><span class="line">gzip_vary on;</span><br></pre></td></tr></table></figure><h3 id="7、本地缓存静态资源"><a href="#7、本地缓存静态资源" class="headerlink" title="7、本地缓存静态资源"></a>7、本地缓存静态资源</h3><p>每个网站都有页面、图像和其他内容，这些内容在访问者在网站上的会话期间基本保持不变。现代网页上几乎 30% 的数据是静态的，应该缓存这些内容以提高 Nginx 的性能。</p><p>优点：</p><ul><li>静态资源加载快：因为不经过 Nginx 连接请求；</li><li>降低了 Nginx 的连接请求压力：可降低 Nginx 服务器负载。</li></ul><p><strong>如何在 Nginx 服务器上配置？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ~* .(jpg|jpeg|png|gif|ico|css|js)$ &#123;</span><br><span class="line">    expires 365d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">该语句将会在客户端（浏览器）请求后，将这些静态资源缓存于本地（浏览器），并且设置有效期365天</span></span><br></pre></td></tr></table></figure><h3 id="8、调整缓冲区大小"><a href="#8、调整缓冲区大小" class="headerlink" title="8、调整缓冲区大小"></a>8、调整缓冲区大小</h3><ul><li><p><strong>Client_header_buffer_size</strong>：限制客户端（浏览器）请求头大小，一般设置为 1k 左右。如果（请求行 + 请求头）的大小如果没超过1k，则放行请求。如果（请求行 + 请求头）的大小如果超过1k，则以<code>large_client_header_buffers</code>配置为准决定是否放行。</p></li><li><p><strong>large_client_header_buffers</strong>：Client_header_buffer_size 的最大值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如：</span></span><br><span class="line">large_client_header_buffers 2 1k</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">请求行不能超过1k，否则返回414错误代码</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">请求头不能超过1k，否则返回400错误代码</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">请求行+请求头不能超过2k（2*1k），否则报错</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Client_body_buffer_size</strong>：客户端（浏览器）在 web 网站上发布请求的缓冲区大小，一般设置 128k 左右。</p></li><li><p><strong>Client_max_body_size</strong>：客户端（浏览器）在 web 网站上发布请求的最大主体大小，比如设置为 10m，当超过该值将向客户端返回 <code>Request Entity Too Large</code> 错误。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client_header_buffer_size 1k；</span><br><span class="line">large_client_header_buffers 2 1k;  # 这里是2个1k的大小（即最大为2*1K=2K）</span><br><span class="line">client_body_buffer_size 128k；</span><br><span class="line">client_max_body_size 10m；</span><br></pre></td></tr></table></figure><h3 id="9、尽可能少使用-if-检查-server-name-语句"><a href="#9、尽可能少使用-if-检查-server-name-语句" class="headerlink" title="9、尽可能少使用 if 检查 server_name 语句"></a>9、尽可能少使用 if 检查 server_name 语句</h3><p>你想想，每一个请求连接进来都要进行一次 if 判断，这势必会增加 web 服务器开销，尤其是在十万&#x2F;百万并发场景下。因此，你也可以在 if 语句层面来优化。</p><p>例如：server_name 指定 hello.com 和 <a href="http://www.hello.com/">www.hello.com</a> 两个域名，当 Nginx 收到请求时，无论请求的是哪个子域，如果始终对 if 指令进行评估，那效率都是很低的。</p><ul><li><p>低效率配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  server_name     hello.com www.hello.com;</span><br><span class="line">  if ($host = www.hello.com) &#123;</span><br><span class="line">    return   301 https://hello.com$request_uri;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>高效率配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name      www.hello.com;</span><br><span class="line">    return           301 $scheme://hello.com$request_uri;</span><br><span class="line">    ## If you force your web traffic to use HTTPS:</span><br><span class="line">    # return 301 https://domain.com$request_uri;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="10、避免过多正则表达"><a href="#10、避免过多正则表达" class="headerlink" title="10、避免过多正则表达"></a>10、避免过多正则表达</h3><ul><li><p>低效率配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">rewrite ^/(.*)$ https://example.com/$1 permanent;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">rewrite ^ https://example.com$request_uri? permanent;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>高效率配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">return 301 https://example.com$request_uri;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$request_uri</span>就是完整url中刨去最前面<span class="variable">$host</span>剩下的部分</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比如：http://www.baidu.com/test</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">那么<span class="variable">$request_uri</span>的值就是/test</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果只有：http://www.baidu.com，那么<span class="variable">$request_uri</span>的值就是/</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h3 id="11、return-代替-rewrite-实现重定向"><a href="#11、return-代替-rewrite-实现重定向" class="headerlink" title="11、return 代替 rewrite 实现重定向"></a>11、return 代替 rewrite 实现重定向</h3><ul><li><p>低效率配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  ...</span><br><span class="line">  if ($host = api.domain.com) &#123;</span><br><span class="line">    rewrite     ^/(.*)$ http://example.com/$1 permanent;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>高效率配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  ...</span><br><span class="line">  if ($host = api.domain.com) &#123;</span><br><span class="line">    return      403;</span><br><span class="line">    ## or other examples:</span><br><span class="line">    ##   return    301 https://domain.com$request_uri;</span><br><span class="line">    ##   return    301 $scheme://$host$request_uri;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="12、使用-try-files-指令确认文件是否存在"><a href="#12、使用-try-files-指令确认文件是否存在" class="headerlink" title="12、使用 try_files 指令确认文件是否存在"></a>12、使用 try_files 指令确认文件是否存在</h3><ul><li><p>低效率配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">root /var/www/example.com;</span><br><span class="line">location /images &#123;</span><br><span class="line">  if (-f $request_filename) &#123;</span><br><span class="line">    expires 30d;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>高效率配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  ...</span><br><span class="line">  root /var/www/example.com;</span><br><span class="line">  location /images &#123;</span><br><span class="line">    try_files $uri $uri/ =404;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比如，我请求 http://www.hello.com/images  那<span class="variable">$uri</span>的值就是/images</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$uri</span>：Nginx 首先判断images是否是个文件且存不存在，如果是且存在则返回，否则继续<span class="variable">$uri</span>/判断</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$uri</span>/：Nginx 再次判断images/是否是个目录且存不存在，如果是且存在则返回，否则将返回404错误代码</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="13、设置-keepalive-timeout"><a href="#13、设置-keepalive-timeout" class="headerlink" title="13、设置 keepalive_timeout"></a>13、设置 keepalive_timeout</h3><p>一般地，在我们的 web 网站中，为了避免同一个客户长时间占用连接，造成资源浪费，可设置相应的超时时间，实现对连接访问时间的控制。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">keepalive_timeout 65 180</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一个参数值65：表示客户发送请求头的超时时间，服务器会在这个时间之后关闭连接</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第二个参数值180：表示请求体读超时时间，客户端（浏览器）会在这个时间后关闭连接</span></span><br></pre></td></tr></table></figure><p>企业生产环境中，我们一般设置为该值就可以了（当然也需要根据实际情况来调整）。</p><h3 id="14、TCP-backlog"><a href="#14、TCP-backlog" class="headerlink" title="14、TCP_ backlog"></a>14、TCP_ backlog</h3><p>在 TCP 的优化一节中，我们提到了<code>tcp_max_syn_backlog</code>参数，该参数为 Linux 内核级别，指的是 TCP 半连接队列长度，而我们的 web 服务，如： nginx、tomcat、Apache 的默认值均为 511，因此我们可以根据不同 web 服务进行调整。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server ｛</span><br><span class="line">    listen 8089 default backlog=1024;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    ....</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><h3 id="15、日志文件轮转"><a href="#15、日志文件轮转" class="headerlink" title="15、日志文件轮转"></a>15、日志文件轮转</h3><p>随着业务量的增加，web 服务的日志访问量也越来越大，久而久之将会耗尽系统磁盘空间。因此，日志轮转就显得非常重要了，有关日志轮转的相关知识的可查看我之前的博文<a href="https://blog.csdn.net/IT_ZRS/article/details/108418623?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165166874716782425159797%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=165166874716782425159797&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-108418623.nonecase&utm_term=%E6%97%A5%E5%BF%97%E8%BD%AE%E8%BD%AC&spm=1018.2226.3001.4450">《Linux系统之计划任务及日志轮转》</a>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑nginx轮转文件</span></span><br><span class="line">cat /etc/logrotate.d/nginx</span><br><span class="line"></span><br><span class="line">/data/nginx/logs/access.log &#123;</span><br><span class="line">    missingok   # 丢失不提醒</span><br><span class="line">    notifempty  # 空文件不轮转</span><br><span class="line">    maxsize 4G  # 只要到了4G日志大小就轮转</span><br><span class="line">    rotate 4    # 保留文件数</span><br><span class="line">    daily       # 每天轮转一次</span><br><span class="line">    create 0600 root root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志轮转可配合计划任务来实现自动轮转！！</p>]]></content>
    
    
    <summary type="html">Nginx 性能优化及应用。</summary>
    
    
    
    <category term="优化篇" scheme="https://blog.rabcnops.cn/categories/%E4%BC%98%E5%8C%96%E7%AF%87/"/>
    
    <category term="Nginx" scheme="https://blog.rabcnops.cn/categories/%E4%BC%98%E5%8C%96%E7%AF%87/Nginx/"/>
    
    
    <category term="优化" scheme="https://blog.rabcnops.cn/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>K8s 应用版本升级与回退</title>
    <link href="https://blog.rabcnops.cn/posts/articles/b808de0b.html"/>
    <id>https://blog.rabcnops.cn/posts/articles/b808de0b.html</id>
    <published>2023-04-04T08:11:14.000Z</published>
    <updated>2023-04-04T08:13:11.428Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/k8s-cert.png" alt="k8s-cert"></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Rolling Update</code> 即滚动更新，先更新一部分副本，成功后再继续更新更多副本，最终完成所有的副本更新。前面说到动态伸缩容并不会触发上线，仅当 Deployment Pod 模板（即 <code>.spec.template</code>）发生改变时才会触发上线。且上线实现了滚动特点，其好处就是无需停服的状态下即可完成服务升级，从而保证了业务的连续性。</p><p>接下来以更新 Nginx 容器镜像的版本号为例进行演示与验证。</p><h2 id="一、升级"><a href="#一、升级" class="headerlink" title="一、升级"></a>一、升级</h2><p>刚刚把副本数从 <code>2 ——&gt; 3</code>，执行 <code>kubectl apply -f nginx.yml</code> 启动服务，可看到并没有触发上线&#x2F;滚动更新：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220143311821.png" alt="image-20221220143311821"></p><p>接着修改镜像的版本号，从 <code>1.20.0 ——&gt; 1.21.4</code>：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220143737833.png" alt="image-20221220143737833"></p><p>再次启动服务，看看镜像版本是否已更新：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220144111103.png" alt="image-20221220144111103"></p><p>看看 Pod 是否正常运行：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220144225750.png" alt="image-20221220144225750"></p><p><mark>小结：</mark>可看到，原来 <code>ReplicaSet nginx-6b6cf7569</code> 的三个 <code>nginx:1.20.0 Pod</code>已经被<code>ReplicaSet nginx-7bfd89cc74</code>的三个<code>nginx:1.21.4 Pod</code>替换了。</p><p>再来看看 <code>deployment</code> 的详情，看看具实现过程：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe deployment nginx</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220144900690.png" alt="image-20221220144900690"></p><p>其流程就是：</p><ul><li><code>ReplicaSet nginx-7bfd89cc74</code> 新增一个 Pod，总数为 1；</li><li><code>ReplicaSet nginx-6b6cf7569</code> 减少一个 Pod，总数为 2（也就是说至少还有两个 Pod 是正常对外提供服务的）；</li><li><code>ReplicaSet nginx-7bfd89cc74</code> 新增一个 Pod，总数为 2；</li><li><code>ReplicaSet nginx-6b6cf7569</code> 减少一个 Pod，总数为 1（也就是说至少还有一个 Pod 是正常对外提供服务的）；</li><li><code>ReplicaSet nginx-7bfd89cc74</code> 新增一个 Pod，总数为 3；</li><li><code>ReplicaSet nginx-6b6cf7569</code> 减少一个 Pod，总数为 0（此时 <code>ReplicaSet nginx-6b6cf7569</code> 已经没有 Pod 了）。</li></ul><p><mark>可看到，其更新方式是以滚动的形式实现的，从而保证了业务的连续性。</mark></p><h2 id="二、回滚"><a href="#二、回滚" class="headerlink" title="二、回滚"></a>二、回滚</h2><p>K8s 在每次 <code>kubectl apply</code> 更新应用时，都会记录当前的配置，比如我原本的 Nginx 镜像为 1.20.0，那这个 1.20.0 及其其他信息都会被记录下来，其目的就是方便我们上线失败后可以回到正常的那个镜像版本。</p><p>默认情况下，K8s 只会保留近 10 个的 <code>revision</code>，我们可以在 Deployment 配置文件中使用 <code>revisionHistoryLimit</code> 字段来指定 revision 的保留数量。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit deployment nginx</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220150436717.png" alt="image-20221220150436717"></p><p>看看可回滚的历史版本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout <span class="built_in">history</span> deployment nginx</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220151203399.png" alt="image-20221220151203399"></p><p>虽然可看到有 2、3、4 这三个可会退的版本，但是 <code>CHANGE-CAUSE</code> 这个字段均为 <code>&lt;none&gt;</code>，这就不太利于我们进行版本会退，想要显示<code>CHANGE-CAUSE</code> 值，需要在 <code>kubectl apply</code> 时添加 <code>--record</code> 参数。所以这里重新在写两个 Deployment 的 YML 文件再来启动服务。</p><ul><li><p>nginx-a.yml</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220151707689.png" alt="image-20221220151707689"></p></li><li><p>nginx-b.yml</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220151801454.png" alt="image-20221220151801454"></p></li></ul><p>分别进行 <code>kubectl apply</code> 更新应用：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx-a.yml --record</span><br><span class="line">kubectl apply -f nginx-b.yml --record</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220152324505.png" alt="image-20221220152324505"></p><p>这样就能看到你是指定的哪个 YAML 文件启动的，但是这个 <code>--record</code> <mark>已经被弃用了</mark>，除了这种方法之外，我们可以通过指定具体的 revision 编号来查看其详细信息，这样你就可以根据实际情况会退到具体版本，比如我们查看 revision 为 4 的版本信息。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout <span class="built_in">history</span> deployment nginx --revision=4</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220153002310.png" alt="image-20221220153002310"></p><p>版本会退验证：</p><ul><li><p>先看看当前的 Pod 的 image 版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get deployment nginx -o wide</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220153136787.png" alt="image-20221220153136787"></p></li><li><p>比如就回到我们 revision 为 4 的版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout undo deployment nginx --to-revision=4</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220153805798.png" alt="image-20221220153805798"></p></li><li><p>会退完成，再次验证当前 image 镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get deployment nginx -o wide</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221220154136759.png" alt="image-20221220154136759"></p><blockquote><p>可看到版本会退成功！</p></blockquote></li></ul><p><mark>以上就是 K8s Pod 版本升级&#x2F;回滚的详细流程。</mark></p>]]></content>
    
    
    <summary type="html">K8s 应用版本升级与回退。</summary>
    
    
    
    <category term="云原生" scheme="https://blog.rabcnops.cn/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    <category term="K8s" scheme="https://blog.rabcnops.cn/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/K8s/"/>
    
    
    <category term="K8s" scheme="https://blog.rabcnops.cn/tags/K8s/"/>
    
  </entry>
  
  <entry>
    <title>K8s 的 DNS 机制</title>
    <link href="https://blog.rabcnops.cn/posts/articles/6d84ddb0.html"/>
    <id>https://blog.rabcnops.cn/posts/articles/6d84ddb0.html</id>
    <published>2023-04-04T07:50:14.000Z</published>
    <updated>2023-04-04T08:13:11.424Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/k8s-cert.png" alt="k8s-cert"></p><hr><p>在 K8s 集群中，除了可以通过 Cluster IP 访问 Service 外，还可通过 DNS 进行访问，在查看系统名称空间的 deployment 时，你会发现有个叫 <code>coredns</code> 的组件，如下图所示：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221219101713029.png" alt="image-20221219101713029"></p><p><code>coredns</code> 是一个 DNS 服务器，每次创建 Service 时，coredns 都会添加该 Service 的 DNS 记录。</p><p>接下来创建一个临时 Pod 来验证通过 DNS 来访问 Service：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建Pod</span></span><br><span class="line">kubectl run busybox --<span class="built_in">rm</span> -it --image=busybox /bin/sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证（由于namespace都是default，所以可以忽略不写）</span></span><br><span class="line">wget &lt;ServiceName&gt;.&lt;namaspace&gt;</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221219105634832.png" alt="image-20221219105634832"></p><p>如果 namespace 不同，就需要跟上 namespace，具体案例如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先创建个namespace</span></span><br><span class="line">kubectl create namespace dns-test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再启动一个测试deployment/Service资源</span></span><br><span class="line">kubectl apply -f nginx1.yml</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221219112206001.png" alt="image-20221219112206001"></p><p><strong>验证：</strong></p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221219112721041.png" alt="image-20221219112721041"></p><p><mark>以上就是 DNS 访问 Service 的具体方法。</mark></p>]]></content>
    
    
    <summary type="html">在 K8s 集群中，除了可以通过 Cluster IP 访问 Service 外，还可通过 DNS 进行访问。</summary>
    
    
    
    <category term="云原生" scheme="https://blog.rabcnops.cn/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    <category term="K8s" scheme="https://blog.rabcnops.cn/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/K8s/"/>
    
    
    <category term="K8s" scheme="https://blog.rabcnops.cn/tags/K8s/"/>
    
  </entry>
  
  <entry>
    <title>K8s Service 负载均衡底层分析</title>
    <link href="https://blog.rabcnops.cn/posts/articles/ed05778b.html"/>
    <id>https://blog.rabcnops.cn/posts/articles/ed05778b.html</id>
    <published>2023-04-04T07:30:14.000Z</published>
    <updated>2023-04-04T07:33:40.599Z</updated>
    
    <content type="html"><![CDATA[<p>当我们创建完 Pod 后，Pod 的 IP 是在容器中配置的，那创建完 Service 后，Service 的 Cluster IP 又是在哪配置的呢？答案是通过 Host 的 <code>iptables</code>（即 K8s 集群节点的 iptables）。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221216162035975.png" alt="image-20221216162035975"></p><p>Cluster IP 是一个虚拟 IP，由 K8s 集群节点的 iptables 规则管理，查看当前节点的 iptables，并过滤与 Service IP 有关的规则</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables-save |grep <span class="string">&#x27;10.99.153.224&#x27;</span></span><br></pre></td></tr></table></figure><p>下图中，我起了 2 个 Pod 副本和一个 Service 资源：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221216164110744.png" alt="image-20221216164110744"></p><p>上图中两条 iptables 规则含义为：</p><ul><li><strong>第一条规则</strong>：当其他源地址访问 Service IP（nginx-srv）时，跳转到 <code>KUBE-SVC-QEOPNOJG5FJIEAZE</code> 规则；</li><li><strong>第二条规则</strong>：当 Service IP（nginx-srv）收到来自集群 Pod IP（Pod）的请求时，则允许。</li></ul><p>那 K8s 集群外部是如何实现访问 Pod 的呢？我们继续看上图中第一条规则跳转后的 <code>KUBE-SVC-QEOPNOJG5FJIEAZE</code> 规则。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221216170246332.png" alt="image-20221216170246332"></p><p>看红框部分：<code>KUBE-SVC-QEOPNOJG5FJIEAZE</code> 分别有两次 50% 的机会转发到下一条规则</p><ul><li><p>第一条规则：其后的 <code>--probability 0.50000000000</code> 表示外部请求时，有 50% 的概率跳转到规则 <code>KUBE-SEP-JASFIS5KUS7Z3IZQ</code></p></li><li><p>第二条规则：其后没有 <code>--probability 0.50000000000</code>，是因为我就起了 2 个 Pod，也就表示外部请求时，也有 50% 的概率跳转到规则 <code>KUBE-SEP-7BD4EFXYOH3EVXAM</code></p></li></ul><p>继续看这两条规则的具体功能实现：</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20221216171619741.png" alt="image-20221216171619741"></p><p>上面的这两条规则就分别对应 K8s 中的两个 Pod IP，也就是 Host 将集群外部的请求分别转发到后端 2 个 Pod，从 iptables 规则来看，iptables 将 K8s 集群外部的请求转发到后端 Pod，且使用了类似轮询的负载均衡策略。</p><p>之所以外部客户端都可以通过 K8s 集群任意一节点来请求&#x2F;访问 K8s 资源，是因为在整个 K8s 集群中的每个节点都配置了相同的 iptables 规则。</p>]]></content>
    
    
    <summary type="html">当我们创建完 Pod 后，Pod 的 IP 是在容器中配置的，那创建完 Service 后，Service 的 Cluster IP 又是在哪配置的呢？答案是通过 Host 的 `iptables`（即 K8s 集群节点的 iptables）。</summary>
    
    
    
    <category term="云原生" scheme="https://blog.rabcnops.cn/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    <category term="K8s" scheme="https://blog.rabcnops.cn/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/K8s/"/>
    
    
    <category term="K8s" scheme="https://blog.rabcnops.cn/tags/K8s/"/>
    
  </entry>
  
  <entry>
    <title>K8s Pod 迁移</title>
    <link href="https://blog.rabcnops.cn/posts/articles/dae759d1.html"/>
    <id>https://blog.rabcnops.cn/posts/articles/dae759d1.html</id>
    <published>2023-04-04T02:33:14.000Z</published>
    <updated>2023-04-04T02:43:13.210Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/yys.jpeg" alt="yys"></p><p>K8s 版本：v1.23.6<br>K8s 集群规模（三节点）：Master（1） + work（2） </p><hr><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>k8s集群中的 node 节点要升级内存，以应对服务迁入、pod扩缩容导致的资源短缺，需要对 node 节点进行停机维护，那么此时 node 节点上的 pod 应该如何处理呢？</p><p>测试环境：我 K8s 集群的 default namespace 有两个运行的 Pod。</p><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209144735128.png" alt="image-20230209144735128"></p><h2 id="一、默认迁移"><a href="#一、默认迁移" class="headerlink" title="一、默认迁移"></a>一、默认迁移</h2><p>当某个 node 节点关机后，k8s 集群并没有<code>立刻</code>发生任何自动迁移动作，如果该 node 节点上的副本数为1，则会出现服务中断的情况。<strong>其实事实并非如此，k8s在等待5分钟后，会自动将停机node节点上的pod自动迁移到其他node节点上</strong>。</p><p><strong>1、模拟节点宕机</strong></p><blockquote><p>此处为测试环境测试：对 k8s-work1 进行维护。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止kubelet</span></span><br><span class="line"></span><br><span class="line">systemctl stop kubelet.service</span><br></pre></td></tr></table></figure><p><strong>2、查看集群状态</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此时停机的node点处于NotReady状态</span></span><br><span class="line"></span><br><span class="line">kubectl get node</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209144948114.png" alt="image-20230209144948114"></p><p><strong>3、监控 Pod 状态</strong></p><blockquote><p>大约等待5分钟左右，集群开始有动作</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209145541573.png" alt="image-20230209145541573"></p><blockquote><p>5分钟后，pod终止并进行重建</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209145422644.png" alt="image-20230209145422644"></p><p>5 分钟后经过了 <strong>Terminating</strong>（终止）- - &gt; <strong>Pending</strong>（等待）- -&gt; <strong>ContainerCreating</strong>（创建）- -&gt; <strong>Running</strong>（运行）四个阶段。直到pod 在新节点启动并由 readiness 探针检测正常后并处于<code>1/1 Running</code> 状态才可以正式对外提供服务。</p><p>此时，停止维护的 k8s-work1 节点上的 Pod 一直是 Terminating 状态的（即使该节点上的 Pod 已经迁移至 k8s-work2 了），解决方法就是恢复 k8s-work1 可用即可。</p><p><mark>注意</mark>：在pod重新迁移到其他node节点时，服务是不可用的！</p><p><strong>4、可用性验证</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 10.244.84.191</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209152305390.png" alt="image-20230209152305390"></p><p><strong>迁移完毕！</strong></p><p><mark>在此大家可能有一个疑问：为什么 pod 在 5 分钟后开始迁移呢？</mark><br>此时需要涉及到 k8s 中的 Taint（污点）和 Toleration（容忍），这是从 Kubernetes 1.6 开始提供的高级调度功能。Taint 和 Toleration 相互配合，可以避免 pod 被分配到不合适的节点上。每个节点上都可以应用一个或多个 Taint，这表示对于那些不能容忍 Taint 的 pod，是不会被该节点接受的。如果将 Toleration 应用于 pod 上，则表示这些 pod 可以（但不要求）被调度到具有匹配 Taint 的节点上。</p><p>具体分析如下：</p><ul><li><p>查看停止服务节点的状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe node k8s-work1</span><br></pre></td></tr></table></figure><blockquote><p>kubelet 停止后，node 节点自动添加了 Taints，如下图所示。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209153207561.png" alt="image-20230209153207561"></p></li><li><p>查看 k8s-work1 上任一 Pod 的状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod nginx-6c75966567-r8h5r</span><br></pre></td></tr></table></figure><blockquote><p>此时 pod 的 Tolerations（容忍）默认对于具有相应 Taint 的 node 节点（即正在维护的 k8s-work1 节点）容忍时间为 300s（即 5 分钟），超过此时间 pod 将会被驱逐到其他可用 node 节点上。因此5分钟后 node 节点（即正在维护的 k8s-work1 节点）上所有的 pod 重新被调度，在此期间服务是中断的。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209153502626.png" alt="image-20230209153502626"></p></li></ul><p><mark>既然默认的 pod 迁移无法避免服务中断，那么我们在 node 节点停机前，我们手动迁移是否可以？</mark></p><h2 id="二、手动迁移"><a href="#二、手动迁移" class="headerlink" title="二、手动迁移"></a>二、手动迁移</h2><p>为避免等待默认的 5 分钟，我们还可以使用 cordon、drain、uncordor 三个命令实现节点的主动维护。此时需要用到以下三个命令：</p><ul><li>cordon：标记节点不可调度，后续新的 pod 不会被调度到此节点，但是该节点上的pod可以正常对外服务；</li><li>drain：驱逐节点上的pod至其他可调度节点；</li><li>uncordon：标记节点可调度。</li></ul><p><strong>1、环境准备</strong></p><p>为了方便实验，我先删除集群的 Pod，重新创建 Pod，使 k8s-work1 节点上也运行得有 Pod。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete -f nginx.yml</span><br></pre></td></tr></table></figure><blockquote><p>重新在创建 Pod</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx.yml</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209154702277.png" alt="image-20230209154702277"></p><p><strong>2、标记节点不可调度</strong></p><blockquote><p>同样来标记 k8s-work1。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl cordon k8s-work1</span><br></pre></td></tr></table></figure><p><strong>3、查看节点状态</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get node</span><br></pre></td></tr></table></figure><blockquote><p>此时 k8s-work1 被标记为不可调度状态。但是该节点上的 Pod 还是可正常对外服务的。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209155252769.png" alt="image-20230209155252769"></p><p><strong>4、驱逐 Pod</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl drain k8s-work1 --delete-local-data --ignore-daemonsets --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数解释：</span></span><br><span class="line"><span class="comment"># --delete-local-data  删除本地数据，即使emptyDir也将删除；</span></span><br><span class="line"><span class="comment"># --ignore-daemonsets  忽略DeamonSet，否则DeamonSet被删除后，仍会自动重建；</span></span><br><span class="line"><span class="comment"># --force  不加force参数只会删除该node节点上的ReplicationController, ReplicaSet, DaemonSet,StatefulSet or Job，加上后所有pod都将删除</span></span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209155652903.png" alt="image-20230209155652903"></p><p><strong>5、查看驱逐结果</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -o wide</span><br></pre></td></tr></table></figure><blockquote><p>可见 k8s-work1 上的 Pod 已经被成功驱逐到其他可用的 work 节点（k8s-work2 节点）上了。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209155832846.png" alt="image-20230209155832846"></p><p>此时与默认迁移不同的是，pod 会<code>先重建再终止</code>，此时的<strong>服务中断时间&#x3D;重建时间+服务启动时间+readiness探针检测正常时间</strong>，必须等到<code>1/1 Running</code>服务才会正常。<strong>因此在单副本时迁移时，服务中断是不可避免的</strong>。</p><p><mark>如何能够做到在驱逐过程中仍然保证对外服务不中断呢？</mark> <strong>- - &gt; 平滑迁移</strong></p><h2 id="三、平滑迁移"><a href="#三、平滑迁移" class="headerlink" title="三、平滑迁移"></a>三、平滑迁移</h2><p>要做到平滑迁移就需要用的 pdb（PodDisruptionBudget），即主动驱逐保护。无论是默认迁移和手动迁移，都会导致服务中断，而 pdb 可以实现节点维护期间不低于一定数量的 pod 正常运行，从而保证服务的可用性。</p><p><strong>1、环境准备</strong></p><p>先恢复 k8s-work2 节点为可用（可调度）状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl uncordon k8s-work1</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209161023651.png" alt="image-20230209161023651"></p><p>为了方便实验，同样我先删除集群的 Pod，重新创建 Pod，使 k8s-work1 节点上也运行得有 Pod。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete -f nginx.yml</span><br></pre></td></tr></table></figure><blockquote><p>重新在创建 Pod</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx.yml</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209161155498.png" alt="image-20230209161155498"></p><p><strong>2、标记节点不可调度</strong></p><blockquote><p>同样来标记 k8s-work1。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl cordon k8s-work1</span><br></pre></td></tr></table></figure><p><strong>3、查看节点状态</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get node</span><br></pre></td></tr></table></figure><blockquote><p>此时 k8s-work1 被标记为不可调度状态。但是该节点上的 Pod 还是可正常对外服务的。</p></blockquote><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209155252769.png" alt="image-20230209155252769"></p><p><strong>4、新建 pdb</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim pdb-nginx.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可定义selector、最小可用（minAvailable）等，根据需求调整即可</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: policy/v1</span><br><span class="line">kind: PodDisruptionBudget</span><br><span class="line">metadata:</span><br><span class="line">  name: pdb-nginx</span><br><span class="line">spec:</span><br><span class="line">  minAvailable: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      web: web-server</span><br></pre></td></tr></table></figure><p><strong>5、创建资源并查看状态</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f pdb-nginx.yaml</span><br><span class="line">kubectl get poddisruptionbudget</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209162125197.png" alt="image-20230209162125197"></p><p><strong>6、驱逐 Pod</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl drain k8s-work1 --delete-local-data --ignore-daemonsets --force</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209162442555.png" alt="image-20230209162442555"></p><p><strong>7、查看驱逐结果</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -o wide</span><br></pre></td></tr></table></figure><p><img src="https://csdn-rab.oss-cn-chengdu.aliyuncs.com/img/image-20230209162526240.png" alt="image-20230209162526240"></p><p><strong>8、维护完毕，将 node 调整为可调度</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl uncordon k8s-work1</span><br></pre></td></tr></table></figure><p><mark>注意</mark>：使用 pdb 方式时，在 Pod 只有一个副本的情况下 pdb 方式是不会发生驱逐的。解决方法就是临时调整 Pod 副本数，实现驱逐后再调整回来，并将node节点调整为可调度，维护完毕。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过简单了解了 Taint（污点）和 Toleration（容忍）作用，我们既可以通过设置 tolerationSeconds 来缩短等待时间，也可以自行定义匹配规则实现符合实际情况的调度规则。另外还要注意<code>先重建再终止</code>和<code>先终止再重建</code>，在此过程中服务启动时间和探针检测时间决定你的服务中断时间。</p>]]></content>
    
    
    <summary type="html">K8s Pod 迁移应用案例。</summary>
    
    
    
    <category term="云原生" scheme="https://blog.rabcnops.cn/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    <category term="K8s" scheme="https://blog.rabcnops.cn/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/K8s/"/>
    
    
    <category term="K8s" scheme="https://blog.rabcnops.cn/tags/K8s/"/>
    
  </entry>
  
</feed>
